<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Builder+Exporter (M1)</title>
    <style>
      body {
        font: 12px/1.4 -apple-system, BlinkMacSystemFont, Segoe UI, Roboto,
          Helvetica, Arial;
        margin: 12px;
      }
      textarea {
        width: 100%;
        height: 320px;
        font-family: ui-monospace, Consolas, Menlo, monospace;
      }
      .row {
        display: flex;
        gap: 8px;
        margin: 8px 0;
      }
      button {
        padding: 6px 10px;
        cursor: pointer;
      }
      #log {
        background: #0f172a;
        color: #e2e8f0;
        padding: 8px;
        height: 180px;
        overflow: auto;
      }
    </style>
  </head>
  <body>
    <h3>Figma Builder+Exporter (M1)</h3>
    <p>
      Вставьте <b>TaskSpec (JSON)</b> ниже и нажмите <b>Validate</b>. Перед
      Build/Export замените <code>REPLACE_WITH_FILE_ID</code> на свой fileId.
    </p>
    <textarea id="spec"></textarea>
    <div class="row">
      <button id="btn-validate">Validate</button>
      <button id="btn-build">Build</button>
      <button id="btn-export">Export</button>
      <button id="btn-fetch">Fetch</button>
      <a
        id="download"
        style="margin-left: auto; display: none"
        download="ExportSpec.json"
        >Download ExportSpec.json</a
      >
      <button id="btn-close">Close</button>
    </div>
    <pre
      id="relay-log"
      style="background: #f1f5f9; color: #0f172a; padding: 8px; max-height: 120px; overflow: auto"
    ></pre>
    <pre id="log"></pre>

    <script>
      const RELAY_URL = "http://localhost:3000";
      let lastTaskId = null;

      const log = (m) => {
        const el = document.getElementById("log");

        el.textContent +=
          (typeof m === "string" ? m : JSON.stringify(m, null, 2)) + "\n";
        el.scrollTop = el.scrollHeight;
      };

      const rlog = (m) => {
        const el = document.getElementById("relay-log");
        if (!el) return;
        el.textContent +=
          (typeof m === "string" ? m : JSON.stringify(m, null, 2)) + "\n";
        el.scrollTop = el.scrollHeight;
      };
      const sample = {
        meta: { specVersion: "0.1", id: "landing-v1" },
        target: {
          fileId: "REPLACE_WITH_FILE_ID",
          pageName: "Landing",
          frameName: "Home",
          frameSize: { w: 1440, h: 1024 },
        },
        grid: { container: 1200, columns: 12, gap: 24, margins: 24 },
        tokens: {
          fontFamily: "Inter",
          colors: { primary: "#6C5CE7", text: "#111827" },
        },
        sections: [
          {
            type: "hero",
            name: "Hero",
            padding: [64, 24],
            spacing: 24,
            layout: "stack",
            content: {
              title: "Заголовок",
              subtitle: "Подзаголовок",
              cta: "Купить",
            },
          },
          {
            type: "features",
            name: "Преимущества",
            layout: "grid-3",
            spacing: 32,
            content: {
              items: [
                { title: "Быстро" },
                { title: "Дёшево" },
                { title: "Точно" },
              ],
            },
          },
          {
            type: "cta",
            name: "Призыв",
            padding: [48, 24],
            content: { text: "Начать сейчас", button: "Попробовать" },
          },
          { type: "footer", name: "Подвал", padding: [48, 24] },
        ],
        acceptance: { maxSpacingDeviation: 2, checkAutoLayout: true },
      };
      document.getElementById("spec").value = JSON.stringify(sample, null, 2);

      const post = (type) => {
        const val = document.getElementById("spec").value;
        parent.postMessage({ pluginMessage: { type, taskSpec: val } }, "*");
      };

      document.getElementById("btn-validate").onclick = async () => {
        const textarea = document.getElementById("spec");
        const raw = textarea.value;
        let parsed;
        let parseError = false;
        try {
          parsed = JSON.parse(raw);
        } catch (_) {
          parseError = true;
        }
        let shouldPost = true;
        if (!parseError) {
          try {
            const res = await fetch(`${RELAY_URL}/validate/taskSpec`, {
              method: "POST",
              headers: { "Content-Type": "application/json" },
              body: JSON.stringify({ taskSpec: parsed }),
            });
            if (res.ok) {
              const data = await res.json();
              if (!data.valid) {
                shouldPost = false;
                log("TaskSpec schema validation failed:");
                const errors = Array.isArray(data.errors) ? data.errors : [];
                if (errors.length === 0) {
                  log(" - No details provided");
                } else {
                  for (const err of errors) {
                    const path = err.instancePath || "/";
                    log(` - ${path}: ${err.message}`);
                  }
                }
              }
            } else {
              rlog(`TaskSpec validation request failed: HTTP ${res.status}`);
            }
          } catch (err) {
            rlog(
              "TaskSpec validation request error: " +
                (err && err.message ? err.message : err)
            );
          }
        }
        if (shouldPost) post("validate");
      };
      document.getElementById("btn-build").onclick = () => post("build");
      document.getElementById("btn-export").onclick = () => post("export");
      document.getElementById("btn-fetch").onclick = async () => {
        try {
          const res = await fetch(`${RELAY_URL}/tasks/latest?status=pending`);
          if (!res.ok) {
            return rlog(`Fetch failed: ${res.status}`);
          }
          const data = await res.json();
          lastTaskId = data.id;
          document.getElementById("spec").value = JSON.stringify(
            data.taskSpec,
            null,
            2
          );
          rlog(`Fetched OK (id=${data.id})`);
          if (lastTaskId) {
            try {
              await fetch(`${RELAY_URL}/tasks/${lastTaskId}/log`, {
                method: "POST",
                headers: { "Content-Type": "application/json" },
                body: JSON.stringify({ message: "Plugin: fetched task into textarea" }),
              });
            } catch (logErr) {
              rlog(
                "Log append error: " +
                  (logErr && logErr.message ? logErr.message : logErr)
              );
            }
          }
        } catch (e) {
          rlog("Fetch error: " + (e && e.message ? e.message : e));
        }
      };
      document.getElementById("btn-close").onclick = () => post("close");

      onmessage = async (e) => {
        const msg = e.data && e.data.pluginMessage;
        if (!msg) return;
        if (msg.type === "validate:ok") {
          log("Validate OK");
          return;
        }
        if (msg.type === "validate:error") {
          log("ERROR: " + msg.error);
          return;
        }
        if (msg.type === "build:ok") {
          log("Build OK: sections=" + msg.sections);
          return;
        }
        if (msg.type === "export:ok") {
          const exportSpec = msg.exportSpec;
          let proceed = true;
          if (exportSpec) {
            try {
              const res = await fetch(`${RELAY_URL}/validate/exportSpec`, {
                method: "POST",
                headers: { "Content-Type": "application/json" },
                body: JSON.stringify({ exportSpec }),
              });
              if (res.ok) {
                const data = await res.json();
                if (!data.valid) {
                  proceed = false;
                  log("ExportSpec schema validation failed:");
                  const errors = Array.isArray(data.errors) ? data.errors : [];
                  if (errors.length === 0) {
                    log(" - No details provided");
                  } else {
                    for (const err of errors) {
                      const path = err.instancePath || "/";
                      log(` - ${path}: ${err.message}`);
                    }
                  }
                }
              } else {
                rlog(`ExportSpec validation request failed: HTTP ${res.status}`);
              }
            } catch (err) {
              rlog(
                "ExportSpec validation request error: " +
                  (err && err.message ? err.message : err)
              );
            }
          }
          if (!proceed) return;
          log(exportSpec);
          const blob = new Blob([JSON.stringify(exportSpec, null, 2)], {
            type: "application/json",
          });
          const url = URL.createObjectURL(blob);
          const a = document.getElementById("download");
          a.href = url;
          a.download = msg.filename || "ExportSpec.json";
          a.style.display = "inline-block";
          if (lastTaskId) {
            try {
              await fetch(`${RELAY_URL}/tasks/${lastTaskId}/result`, {
                method: "POST",
                headers: { "Content-Type": "application/json" },
                body: JSON.stringify({ result: exportSpec }),
              });
              rlog(`Result posted for task ${lastTaskId}`);
              try {
                await fetch(`${RELAY_URL}/tasks/${lastTaskId}/log`, {
                  method: "POST",
                  headers: { "Content-Type": "application/json" },
                  body: JSON.stringify({
                    message: "Plugin: result posted (export:ok)",
                  }),
                });
              } catch (logErr) {
                rlog(
                  "Log append error: " +
                    (logErr && logErr.message ? logErr.message : logErr)
                );
              }
            } catch (err) {
              rlog(
                "Post result error: " +
                  (err && err.message ? err.message : err)
              );
            }
          }
          return;
        }
        if (msg.type === "error") {
          log("ERROR: " + msg.error);
          return;
        }
        log(msg);
      };
    </script>
  </body>
</html>
