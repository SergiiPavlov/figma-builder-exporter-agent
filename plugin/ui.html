<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Builder+Exporter (M1)</title>
    <style>
      body {
        font: 12px/1.4 -apple-system, BlinkMacSystemFont, Segoe UI, Roboto,
          Helvetica, Arial;
        margin: 12px;
      }
      textarea {
        width: 100%;
        height: 320px;
        font-family: ui-monospace, Consolas, Menlo, monospace;
      }
      .row {
        display: flex;
        gap: 8px;
        margin: 8px 0;
      }
      button {
        padding: 6px 10px;
        cursor: pointer;
      }
      #log {
        background: #0f172a;
        color: #e2e8f0;
        padding: 8px;
        height: 180px;
        overflow: auto;
      }
      #status-panel {
        margin-top: 12px;
        border: 1px solid #cbd5f5;
        background: #f8fafc;
        border-radius: 6px;
        padding: 8px;
      }
      #status-panel .status-header {
        display: flex;
        align-items: center;
        gap: 8px;
        font-size: 12px;
        margin-bottom: 6px;
      }
      #status-text {
        font-weight: 600;
      }
      #status-connection {
        margin-left: auto;
        font-size: 10px;
        text-transform: uppercase;
        padding: 2px 6px;
        border-radius: 999px;
        background: #e2e8f0;
        color: #334155;
      }
      #status-connection[data-state='connecting'] {
        background: #fef3c7;
        color: #92400e;
      }
      #status-connection[data-state='connected'] {
        background: #bbf7d0;
        color: #166534;
      }
      #status-connection[data-state='error'] {
        background: #fecaca;
        color: #b91c1c;
      }
      #status-panel[data-state='pending'] #status-text {
        color: #c2410c;
      }
      #status-panel[data-state='done'] #status-text {
        color: #15803d;
      }
      #status-panel[data-state='error'] #status-text {
        color: #dc2626;
      }
      #status-log {
        background: #0f172a;
        color: #e2e8f0;
        padding: 8px;
        max-height: 180px;
        overflow: auto;
        margin: 0;
        white-space: pre-wrap;
        word-break: break-word;
      }
    </style>
  </head>
  <body>
    <h3>Figma Builder+Exporter (M1)</h3>
    <p>
      Вставьте <b>TaskSpec (JSON)</b> ниже и нажмите <b>Validate</b>. Перед
      Build/Export замените <code>REPLACE_WITH_FILE_ID</code> на свой fileId.
    </p>
    <textarea id="spec"></textarea>
    <div class="row">
      <button id="btn-validate">Validate</button>
      <button id="btn-build">Build</button>
      <button id="btn-export">Export</button>
      <button id="btn-fetch">Fetch</button>
      <a
        id="download"
        style="margin-left: auto; display: none"
        download="ExportSpec.json"
        >Download ExportSpec.json</a
      >
      <button id="btn-close">Close</button>
    </div>
    <pre
      id="relay-log"
      style="background: #f1f5f9; color: #0f172a; padding: 8px; max-height: 120px; overflow: auto"
    ></pre>
    <div id="status-panel" data-state="idle">
      <div class="status-header">
        <span>Status:</span>
        <span id="status-text">idle</span>
        <span id="status-connection" data-state="closed">disconnected</span>
      </div>
      <pre id="status-log"></pre>
    </div>
    <pre id="log"></pre>

    <script>
      const RELAY_URL = "http://localhost:3000";
      let lastTaskId = null;
      let statusSource = null;
      let currentWatchTaskId = null;
      let statusLogs = [];
      const STATUS_LOG_LIMIT = 200;

      const log = (m) => {
        const el = document.getElementById("log");

        el.textContent +=
          (typeof m === "string" ? m : JSON.stringify(m, null, 2)) + "\n";
        el.scrollTop = el.scrollHeight;
      };

      const rlog = (m) => {
        const el = document.getElementById("relay-log");
        if (!el) return;
        el.textContent +=
          (typeof m === "string" ? m : JSON.stringify(m, null, 2)) + "\n";
        el.scrollTop = el.scrollHeight;
      };
      const statusPanelEl = document.getElementById("status-panel");
      const statusTextEl = document.getElementById("status-text");
      const statusLogEl = document.getElementById("status-log");
      const statusConnectionEl = document.getElementById("status-connection");

      const formatStatusLogEntry = (entry) => {
        if (!entry) return "";
        if (typeof entry === "string") return entry;
        const msg = entry.message || "";
        if (entry.ts) {
          return `[${entry.ts}] ${msg}`;
        }
        return msg;
      };

      const renderStatusLogs = () => {
        if (!statusLogEl) return;
        statusLogEl.textContent = statusLogs.join("\n");
        statusLogEl.scrollTop = statusLogEl.scrollHeight;
      };

      const setStatusState = (state) => {
        if (!statusPanelEl || !statusTextEl) return;
        const normalized = typeof state === "string" && state ? state : "unknown";
        statusPanelEl.dataset.state = normalized.toLowerCase();
        statusTextEl.textContent = normalized;
      };

      const setStatusLogs = (entries) => {
        statusLogs = [];
        if (Array.isArray(entries)) {
          for (const entry of entries) {
            const line = formatStatusLogEntry(entry);
            if (line) statusLogs.push(line);
          }
        }
        if (statusLogs.length > STATUS_LOG_LIMIT) {
          statusLogs = statusLogs.slice(-STATUS_LOG_LIMIT);
        }
        renderStatusLogs();
      };

      const appendStatusLogEntry = (entry) => {
        const line = formatStatusLogEntry(entry);
        if (!line) return;
        statusLogs.push(line);
        if (statusLogs.length > STATUS_LOG_LIMIT) {
          statusLogs = statusLogs.slice(-STATUS_LOG_LIMIT);
        }
        renderStatusLogs();
      };

      const setConnectionState = (state, label) => {
        if (!statusConnectionEl) return;
        const value = state || "closed";
        statusConnectionEl.dataset.state = value;
        statusConnectionEl.textContent = label || value;
      };

      const closeStatusSource = () => {
        if (statusSource) {
          statusSource.close();
          statusSource = null;
        }
        currentWatchTaskId = null;
        setConnectionState("closed", "disconnected");
      };

      const openTaskWatch = (taskId) => {
        if (!taskId) return;
        if (taskId === currentWatchTaskId && statusSource) return;
        closeStatusSource();
        currentWatchTaskId = taskId;
        setStatusLogs([]);
        setStatusState("pending");
        setConnectionState("connecting", "connecting...");
        try {
          const source = new EventSource(`${RELAY_URL}/tasks/${taskId}/watch`);
          statusSource = source;
          source.onopen = () => {
            setConnectionState("connected", "connected");
          };
          source.addEventListener("status", (event) => {
            try {
              const data = JSON.parse(event.data);
              setStatusState(data && data.status ? data.status : "pending");
              setStatusLogs(data && data.logs ? data.logs : []);
            } catch (err) {
              rlog(
                "Failed to parse status event: " +
                  (err && err.message ? err.message : err)
              );
            }
          });
          source.addEventListener("log", (event) => {
            try {
              const data = JSON.parse(event.data);
              appendStatusLogEntry(data);
            } catch (err) {
              rlog(
                "Failed to parse log event: " +
                  (err && err.message ? err.message : err)
              );
            }
          });
          source.addEventListener("result", (event) => {
            try {
              const data = JSON.parse(event.data);
              setStatusState(data && data.status ? data.status : "done");
              setTimeout(() => {
                if (statusSource === source) {
                  closeStatusSource();
                }
              }, 3000);
            } catch (err) {
              rlog(
                "Failed to parse result event: " +
                  (err && err.message ? err.message : err)
              );
            }
          });
          source.onerror = () => {
            if (source.readyState === EventSource.CLOSED) {
              setConnectionState("closed", "disconnected");
            } else {
              setConnectionState("error", "error (retrying)");
            }
            rlog(`SSE connection error for task ${taskId}`);
          };
        } catch (err) {
          setConnectionState("error", "error");
          rlog(
            "Failed to open SSE subscription: " +
              (err && err.message ? err.message : err)
          );
        }
      };

      window.addEventListener("beforeunload", () => {
        closeStatusSource();
      });

      setStatusLogs([]);
      setStatusState("idle");
      setConnectionState("closed", "disconnected");
      const sample = {
        meta: { specVersion: "0.1", id: "landing-v1" },
        target: {
          fileId: "REPLACE_WITH_FILE_ID",
          pageName: "Landing",
          frameName: "Home",
          frameSize: { w: 1440, h: 1024 },
        },
        grid: { container: 1200, columns: 12, gap: 24, margins: 24 },
        tokens: {
          fontFamily: "Inter",
          colors: { primary: "#6C5CE7", text: "#111827" },
        },
        sections: [
          {
            type: "hero",
            name: "Hero",
            padding: [64, 24],
            spacing: 24,
            layout: "stack",
            content: {
              title: "Заголовок",
              subtitle: "Подзаголовок",
              cta: "Купить",
            },
          },
          {
            type: "features",
            name: "Преимущества",
            layout: "grid-3",
            spacing: 32,
            content: {
              items: [
                { title: "Быстро" },
                { title: "Дёшево" },
                { title: "Точно" },
              ],
            },
          },
          {
            type: "cta",
            name: "Призыв",
            padding: [48, 24],
            content: { text: "Начать сейчас", button: "Попробовать" },
          },
          { type: "footer", name: "Подвал", padding: [48, 24] },
        ],
        acceptance: { maxSpacingDeviation: 2, checkAutoLayout: true },
      };
      document.getElementById("spec").value = JSON.stringify(sample, null, 2);

      const post = (type) => {
        const val = document.getElementById("spec").value;
        parent.postMessage({ pluginMessage: { type, taskSpec: val } }, "*");
      };

      document.getElementById("btn-validate").onclick = async () => {
        const textarea = document.getElementById("spec");
        const raw = textarea.value;
        let parsed;
        let parseError = false;
        try {
          parsed = JSON.parse(raw);
        } catch (_) {
          parseError = true;
        }
        let shouldPost = true;
        if (!parseError) {
          try {
            const res = await fetch(`${RELAY_URL}/validate/taskSpec`, {
              method: "POST",
              headers: { "Content-Type": "application/json" },
              body: JSON.stringify({ taskSpec: parsed }),
            });
            if (res.ok) {
              const data = await res.json();
              if (!data.valid) {
                shouldPost = false;
                log("TaskSpec schema validation failed:");
                const errors = Array.isArray(data.errors) ? data.errors : [];
                if (errors.length === 0) {
                  log(" - No details provided");
                } else {
                  for (const err of errors) {
                    const path = err.instancePath || "/";
                    log(` - ${path}: ${err.message}`);
                  }
                }
              }
            } else {
              rlog(`TaskSpec validation request failed: HTTP ${res.status}`);
            }
          } catch (err) {
            rlog(
              "TaskSpec validation request error: " +
                (err && err.message ? err.message : err)
            );
          }
        }
        if (shouldPost) post("validate");
      };
      document.getElementById("btn-build").onclick = () => post("build");
      document.getElementById("btn-export").onclick = () => post("export");
      document.getElementById("btn-fetch").onclick = async () => {
        try {
          const res = await fetch(`${RELAY_URL}/tasks/latest?status=pending`);
          if (!res.ok) {
            return rlog(`Fetch failed: ${res.status}`);
          }
          const data = await res.json();
          lastTaskId = data.id;
          document.getElementById("spec").value = JSON.stringify(
            data.taskSpec,
            null,
            2
          );
          rlog(`Fetched OK (id=${data.id})`);
          openTaskWatch(lastTaskId);
          if (lastTaskId) {
            try {
              await fetch(`${RELAY_URL}/tasks/${lastTaskId}/log`, {
                method: "POST",
                headers: { "Content-Type": "application/json" },
                body: JSON.stringify({ message: "Plugin: fetched task into textarea" }),
              });
            } catch (logErr) {
              rlog(
                "Log append error: " +
                  (logErr && logErr.message ? logErr.message : logErr)
              );
            }
          }
        } catch (e) {
          rlog("Fetch error: " + (e && e.message ? e.message : e));
        }
      };
      document.getElementById("btn-close").onclick = () => {
        closeStatusSource();
        post("close");
      };

      onmessage = async (e) => {
        const msg = e.data && e.data.pluginMessage;
        if (!msg) return;
        if (msg.type === "validate:ok") {
          log("Validate OK");
          return;
        }
        if (msg.type === "validate:error") {
          log("ERROR: " + msg.error);
          return;
        }
        if (msg.type === "build:ok") {
          log("Build OK: sections=" + msg.sections);
          return;
        }
        if (msg.type === "export:ok") {
          const exportSpec = msg.exportSpec;
          let proceed = true;
          if (exportSpec) {
            try {
              const res = await fetch(`${RELAY_URL}/validate/exportSpec`, {
                method: "POST",
                headers: { "Content-Type": "application/json" },
                body: JSON.stringify({ exportSpec }),
              });
              if (res.ok) {
                const data = await res.json();
                if (!data.valid) {
                  proceed = false;
                  log("ExportSpec schema validation failed:");
                  const errors = Array.isArray(data.errors) ? data.errors : [];
                  if (errors.length === 0) {
                    log(" - No details provided");
                  } else {
                    for (const err of errors) {
                      const path = err.instancePath || "/";
                      log(` - ${path}: ${err.message}`);
                    }
                  }
                }
              } else {
                rlog(`ExportSpec validation request failed: HTTP ${res.status}`);
              }
            } catch (err) {
              rlog(
                "ExportSpec validation request error: " +
                  (err && err.message ? err.message : err)
              );
            }
          }
          if (!proceed) return;
          log(exportSpec);
          const blob = new Blob([JSON.stringify(exportSpec, null, 2)], {
            type: "application/json",
          });
          const url = URL.createObjectURL(blob);
          const a = document.getElementById("download");
          a.href = url;
          a.download = msg.filename || "ExportSpec.json";
          a.style.display = "inline-block";
          if (lastTaskId) {
            try {
              await fetch(`${RELAY_URL}/tasks/${lastTaskId}/result`, {
                method: "POST",
                headers: { "Content-Type": "application/json" },
                body: JSON.stringify({ result: exportSpec }),
              });
              rlog(`Result posted for task ${lastTaskId}`);
              try {
                await fetch(`${RELAY_URL}/tasks/${lastTaskId}/log`, {
                  method: "POST",
                  headers: { "Content-Type": "application/json" },
                  body: JSON.stringify({
                    message: "Plugin: result posted (export:ok)",
                  }),
                });
              } catch (logErr) {
                rlog(
                  "Log append error: " +
                    (logErr && logErr.message ? logErr.message : logErr)
                );
              }
            } catch (err) {
              rlog(
                "Post result error: " +
                  (err && err.message ? err.message : err)
              );
            }
          }
          return;
        }
        if (msg.type === "error") {
          log("ERROR: " + msg.error);
          return;
        }
        log(msg);
      };
    </script>
  </body>
</html>
