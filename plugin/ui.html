<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Builder+Exporter (M1)</title>
    <style>
      body {
        font: 12px/1.4 -apple-system, BlinkMacSystemFont, Segoe UI, Roboto,
          Helvetica, Arial;
        margin: 12px;
      }
      .auth-settings {
        display: flex;
        flex-wrap: wrap;
        gap: 8px;
        align-items: flex-end;
        margin: 10px 0;
      }
      .auth-settings label {
        display: flex;
        flex-direction: column;
        gap: 4px;
        font-size: 11px;
        color: #1e293b;
      }
      .auth-settings input {
        padding: 4px 6px;
        font-size: 12px;
        min-width: 220px;
      }
      .auth-settings small {
        font-size: 10px;
        color: #64748b;
      }
      .tabs {
        display: inline-flex;
        gap: 6px;
        margin-bottom: 12px;
      }
      .tab-button {
        padding: 6px 12px;
        border: 1px solid #cbd5f5;
        border-radius: 4px;
        background: #f8fafc;
        color: #0f172a;
        cursor: pointer;
        font-size: 12px;
        font-weight: 600;
      }
      .tab-button.is-active {
        background: #2563eb;
        border-color: #1d4ed8;
        color: #fff;
      }
      .tab-panel {
        display: none;
      }
      .tab-panel.is-active {
        display: block;
      }
      textarea {
        width: 100%;
        height: 320px;
        font-family: ui-monospace, Consolas, Menlo, monospace;
      }
      .row {
        display: flex;
        gap: 8px;
        margin: 8px 0;
      }
      button {
        padding: 6px 10px;
        cursor: pointer;
      }
      .mode-toggle {
        display: inline-flex;
        align-items: center;
        gap: 6px;
        font-size: 12px;
        margin: 6px 0;
      }
      a.button-link {
        display: inline-block;
        padding: 6px 10px;
        border-radius: 4px;
        text-decoration: none;
        font-weight: 500;
      }
      #log {
        background: #0f172a;
        color: #e2e8f0;
        padding: 8px;
        height: 180px;
        overflow: auto;
      }
      #artifact-download {
        margin-top: 8px;
        background: #2563eb;
        color: #fff;
        border: 1px solid #1d4ed8;
      }
      #artifact-download[aria-disabled='true'] {
        opacity: 0.6;
        cursor: not-allowed;
        pointer-events: none;
      }
      #artifact-zip-download {
        margin-top: 8px;
        margin-left: 8px;
        background: #0f172a;
        color: #e2e8f0;
        border: 1px solid #0f172a;
      }
      #artifact-zip-download[aria-disabled='true'] {
        opacity: 0.6;
        cursor: not-allowed;
        pointer-events: none;
      }
      #status-panel {
        margin-top: 12px;
        border: 1px solid #cbd5f5;
        background: #f8fafc;
        border-radius: 6px;
        padding: 8px;
      }
      #status-panel .status-header {
        display: flex;
        align-items: center;
        gap: 8px;
        font-size: 12px;
        margin-bottom: 6px;
      }
      #status-text {
        font-weight: 600;
      }
      #status-connection {
        margin-left: auto;
        font-size: 10px;
        text-transform: uppercase;
        padding: 2px 6px;
        border-radius: 999px;
        background: #e2e8f0;
        color: #334155;
      }
      #status-connection[data-state='connecting'] {
        background: #fef3c7;
        color: #92400e;
      }
      #status-connection[data-state='connected'] {
        background: #bbf7d0;
        color: #166534;
      }
      #status-connection[data-state='error'] {
        background: #fecaca;
        color: #b91c1c;
      }
      #status-panel[data-state='pending'] #status-text {
        color: #c2410c;
      }
      #status-panel[data-state='running'] #status-text {
        color: #2563eb;
      }
      #status-panel[data-state='done'] #status-text {
        color: #15803d;
      }
      #status-panel[data-state='error'] #status-text {
        color: #dc2626;
      }
      #status-log {
        background: #0f172a;
        color: #e2e8f0;
        padding: 8px;
        max-height: 180px;
        overflow: auto;
        margin: 0;
        white-space: pre-wrap;
        word-break: break-word;
      }
      #panel-artifacts {
        border: 1px solid #cbd5f5;
        border-radius: 6px;
        padding: 12px;
        background: #f8fafc;
      }
      #panel-artifacts[data-loading='true'] {
        opacity: 0.75;
      }
      .artifacts-controls {
        display: flex;
        flex-wrap: wrap;
        gap: 10px;
        align-items: flex-end;
        margin-bottom: 12px;
      }
      .artifacts-controls label {
        display: flex;
        flex-direction: column;
        gap: 4px;
        font-size: 11px;
        color: #1e293b;
      }
      .artifacts-controls input,
      .artifacts-controls select {
        padding: 4px 6px;
        font-size: 12px;
      }
      .artifacts-controls button {
        margin-left: 0;
      }
      .artifacts-error {
        display: none;
        color: #b91c1c;
        background: #fee2e2;
        border: 1px solid #fecaca;
        border-radius: 4px;
        padding: 6px 8px;
        margin-bottom: 12px;
      }
      .artifacts-table {
        width: 100%;
        border-collapse: collapse;
        font-size: 12px;
      }
      .artifacts-table th,
      .artifacts-table td {
        border: 1px solid #e2e8f0;
        padding: 6px 8px;
        text-align: left;
        vertical-align: middle;
      }
      .artifacts-table tbody tr:nth-child(even) {
        background: #f1f5f9;
      }
      .artifacts-table tbody tr[data-clickable='true'] {
        cursor: pointer;
      }
      .artifacts-table tbody tr[data-selected='true'] {
        background: #dbeafe;
      }
      .artifacts-table .actions {
        white-space: nowrap;
      }
      .artifacts-table .muted {
        text-align: center;
        color: #64748b;
        font-style: italic;
      }
      .artifacts-pagination {
        display: flex;
        align-items: center;
        flex-wrap: wrap;
        gap: 10px;
        margin-top: 12px;
        font-size: 12px;
      }
      .artifacts-pagination button {
        margin-left: 0;
      }
      #artifacts-bulk-download {
        margin-left: auto;
        padding: 6px 10px;
        font-weight: 600;
      }
      #artifacts-bulk-download[disabled] {
        opacity: 0.6;
        cursor: not-allowed;
      }
      .artifact-details {
        position: fixed;
        inset: 0;
        display: flex;
        justify-content: flex-end;
        pointer-events: none;
        z-index: 50;
      }
      .artifact-details[data-open='true'] {
        pointer-events: auto;
      }
      .artifact-details__overlay {
        flex: 1;
        background: rgba(15, 23, 42, 0.45);
        backdrop-filter: blur(2px);
        opacity: 0;
        transition: opacity 0.2s ease;
      }
      .artifact-details[data-open='true'] .artifact-details__overlay {
        opacity: 1;
      }
      .artifact-details__panel {
        width: min(420px, 100%);
        max-width: 100%;
        background: #ffffff;
        border-left: 1px solid #cbd5f5;
        box-shadow: -4px 0 16px rgba(15, 23, 42, 0.12);
        padding: 16px;
        overflow-y: auto;
        transform: translateX(100%);
        transition: transform 0.2s ease;
        display: flex;
        flex-direction: column;
        gap: 12px;
      }
      .artifact-details[data-open='true'] .artifact-details__panel {
        transform: translateX(0);
      }
      .artifact-details__header {
        display: flex;
        align-items: center;
        gap: 8px;
      }
      .artifact-details__title {
        margin: 0;
        font-size: 14px;
        font-weight: 600;
        color: #0f172a;
      }
      .artifact-details__close {
        margin-left: auto;
        border: none;
        background: transparent;
        color: #0f172a;
        font-size: 18px;
        line-height: 1;
        padding: 2px 6px;
        cursor: pointer;
      }
      .artifact-details__meta {
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(140px, 1fr));
        gap: 10px;
        font-size: 12px;
      }
      .artifact-details__meta-item {
        display: flex;
        flex-direction: column;
        gap: 2px;
      }
      .artifact-details__meta-label {
        font-size: 11px;
        text-transform: uppercase;
        color: #64748b;
        letter-spacing: 0.02em;
      }
      .artifact-details__meta-value {
        color: #0f172a;
        word-break: break-all;
      }
      .artifact-details__actions {
        display: flex;
        flex-wrap: wrap;
        gap: 8px;
      }
      .artifact-details__actions a,
      .artifact-details__actions button {
        font-size: 12px;
      }
      .artifact-details__share {
        display: flex;
        flex-direction: column;
        gap: 6px;
        padding: 8px;
        border: 1px solid #e2e8f0;
        border-radius: 6px;
        background: #f8fafc;
      }
      .artifact-details__share-actions {
        display: flex;
        flex-wrap: wrap;
        gap: 6px;
      }
      .artifact-details__share-actions button {
        font-size: 12px;
      }
      .artifact-details__share-feedback {
        display: none;
        flex-direction: column;
        gap: 4px;
        font-size: 11px;
        color: #0f172a;
        word-break: break-word;
      }
      .artifact-details__share-feedback[data-visible='true'] {
        display: flex;
      }
      .artifact-details__share-link {
        display: flex;
        align-items: center;
        gap: 6px;
        flex-wrap: wrap;
      }
      .artifact-details__share-url {
        max-width: 100%;
        overflow-wrap: anywhere;
        font-weight: 600;
        color: #1d4ed8;
      }
      .artifact-details__share-feedback button {
        font-size: 11px;
      }
      .artifact-details__share-ttl {
        color: #475569;
      }
      .artifact-details__share-error {
        display: none;
        font-size: 11px;
        color: #b91c1c;
      }
      .artifact-details__share-error[data-visible='true'] {
        display: block;
      }
      .artifact-details__notice {
        font-size: 12px;
        background: #e0f2fe;
        border: 1px solid #bae6fd;
        color: #0c4a6e;
        border-radius: 4px;
        padding: 8px;
        display: none;
        gap: 8px;
      }
      .artifact-details__notice[data-visible='true'] {
        display: flex;
        flex-direction: column;
      }
      .artifact-details__notice-actions {
        display: flex;
        flex-wrap: wrap;
        gap: 6px;
        margin-top: 6px;
      }
      .artifact-details__toast {
        font-size: 11px;
        color: #0f172a;
        background: rgba(226, 232, 240, 0.8);
        border-radius: 4px;
        padding: 4px 6px;
        align-self: flex-start;
        display: none;
      }
      .artifact-details__toast[data-visible='true'] {
        display: inline-block;
      }
      .artifact-details__section-title {
        margin: 0 0 4px;
        font-size: 13px;
        font-weight: 600;
        color: #0f172a;
      }
      .artifact-details__logs {
        max-height: 160px;
        overflow-y: auto;
        border: 1px solid #e2e8f0;
        background: #0f172a;
        color: #e2e8f0;
        padding: 8px;
        font-family: ui-monospace, Consolas, Menlo, monospace;
        font-size: 11px;
        white-space: pre-wrap;
      }
      .artifact-details__logs[data-empty='true'] {
        color: #cbd5f5;
        font-style: italic;
      }
      .artifact-details__export-header {
        display: flex;
        align-items: center;
        gap: 8px;
        flex-wrap: wrap;
      }
      .artifact-details__export-controls {
        display: flex;
        align-items: center;
        gap: 6px;
        margin-left: auto;
      }
      .artifact-details__export-controls input[type='search'] {
        padding: 4px 6px;
        font-size: 12px;
        width: 160px;
      }
      .artifact-details__export-viewer {
        border: 1px solid #e2e8f0;
        background: #f8fafc;
        padding: 8px;
        max-height: 280px;
        overflow: auto;
        font-family: ui-monospace, Consolas, Menlo, monospace;
        font-size: 11px;
      }
      .artifact-details__export-viewer[data-empty='true'] {
        color: #64748b;
        font-style: italic;
      }
      .json-node {
        margin-left: 0;
      }
      .json-node > details > summary {
        cursor: pointer;
        list-style: none;
      }
      .json-node > details > summary::-webkit-details-marker {
        display: none;
      }
      .json-node > details > summary::before {
        content: '▸';
        display: inline-block;
        margin-right: 6px;
        transform: rotate(0deg);
        transition: transform 0.15s ease;
        color: #2563eb;
      }
      .json-node > details[open] > summary::before {
        transform: rotate(90deg);
      }
      .json-node > details > .json-children {
        margin-left: 14px;
      }
      .json-leaf {
        margin-left: 18px;
      }
      .json-key {
        color: #1d4ed8;
      }
      .json-value-string {
        color: #047857;
      }
      .json-value-number,
      .json-value-bigint {
        color: #b91c1c;
      }
      .json-value-boolean {
        color: #7c3aed;
      }
      .json-value-null,
      .json-value-undefined {
        color: #0f172a;
        font-style: italic;
      }
      .artifact-details__export-viewer mark {
        background: #fde68a;
        color: inherit;
        padding: 0;
      }
      .json-node[data-search-active='true'][data-has-match='false'] {
        opacity: 0.45;
      }
      .artifact-details__loading,
      .artifact-details__error {
        font-size: 12px;
      }
      .artifact-details__loading {
        color: #1d4ed8;
      }
      .artifact-details__error {
        color: #b91c1c;
      }
      .artifact-details__empty {
        color: #64748b;
        font-style: italic;
      }
      .artifact-details__content {
        display: flex;
        flex-direction: column;
        gap: 12px;
      }
      .artifact-details__body {
        display: flex;
        flex-direction: column;
        gap: 10px;
      }
    </style>
  </head>
  <body>
    <h3>Figma Builder+Exporter (M1)</h3>
    <div class="tabs">
      <button type="button" class="tab-button is-active" data-target="panel-builder">
        Builder
      </button>
      <button type="button" class="tab-button" data-target="panel-artifacts">
        Artifacts
      </button>
    </div>
    <div id="panel-builder" class="tab-panel is-active">
      <p>
        Вставьте <b>TaskSpec (JSON)</b> ниже и нажмите <b>Validate</b>. Перед
        Build/Export замените <code>REPLACE_WITH_FILE_ID</code> на свой fileId.
      </p>
      <textarea id="spec"></textarea>
      <div class="auth-settings">
        <label>
          API key
          <input
            type="password"
            id="api-key-input"
            placeholder="Enter API key"
            autocomplete="off"
          />
        </label>
        <button type="button" id="api-key-clear">Clear</button>
        <small>Stored locally (Figma plugin settings)</small>
      </div>
      <label class="mode-toggle">
        <input type="checkbox" id="pull-mode" />
        <span>Pull mode</span>
      </label>
      <div class="row">
        <button id="btn-validate">Validate</button>
        <button id="btn-build">Build</button>
        <button id="btn-export">Export</button>
        <button id="btn-fetch">Fetch</button>
        <a
          id="download"
          style="margin-left: auto; display: none"
          download="ExportSpec.json"
          >Download ExportSpec.json</a
        >
        <button id="btn-close">Close</button>
      </div>
      <pre
        id="relay-log"
        style="background: #f1f5f9; color: #0f172a; padding: 8px; max-height: 120px; overflow: auto"
      ></pre>
      <div id="status-panel" data-state="idle">
        <div class="status-header">
          <span>Status:</span>
          <span id="status-text">idle</span>
          <span id="status-connection" data-state="closed">disconnected</span>
        </div>
        <pre id="status-log"></pre>
      </div>
      <pre id="log"></pre>
      <a
        id="artifact-download"
        class="button-link"
        href="#"
        aria-disabled="true"
        rel="noopener noreferrer"
        >Download artifact</a
      >
      <a
        id="artifact-zip-download"
        class="button-link"
        href="#"
        aria-disabled="true"
        rel="noopener noreferrer"
        >Download ZIP</a
      >
    </div>
    <div id="panel-artifacts" class="tab-panel">
      <div id="artifacts-error" class="artifacts-error" role="alert"></div>
      <div class="artifacts-controls">
        <label>
          Search by ID
          <input type="text" id="artifacts-search" placeholder="Substring" />
        </label>
        <label>
          Order
          <select id="artifacts-order">
            <option value="desc" selected>desc</option>
            <option value="asc">asc</option>
          </select>
        </label>
        <label>
          Limit
          <input type="number" id="artifacts-limit" min="1" max="50" value="10" />
        </label>
        <button type="button" id="artifacts-prev">Prev</button>
        <button type="button" id="artifacts-next">Next</button>
      </div>
      <table class="artifacts-table">
        <thead>
          <tr>
            <th>Select</th>
            <th>ID</th>
            <th>Created</th>
            <th>Size</th>
            <th class="actions">JSON</th>
            <th class="actions">ZIP</th>
          </tr>
        </thead>
        <tbody id="artifacts-tbody">
          <tr>
            <td colspan="6" class="muted">No artifacts loaded</td>
          </tr>
        </tbody>
      </table>
      <div class="artifacts-pagination">
        <div id="artifacts-pagination-info">No artifacts</div>
        <button type="button" id="artifacts-bulk-download" disabled>
          Download selected as ZIP
        </button>
      </div>
      <div
        id="artifact-details"
        class="artifact-details"
        data-open="false"
        aria-hidden="true"
      >
        <div class="artifact-details__overlay" id="artifact-details-overlay"></div>
        <aside
          class="artifact-details__panel"
          role="dialog"
          aria-modal="true"
          aria-labelledby="artifact-details-title"
        >
          <div class="artifact-details__header">
            <h4 class="artifact-details__title" id="artifact-details-title">
              Artifact details
            </h4>
            <button
              type="button"
              class="artifact-details__close"
              id="artifact-details-close"
              aria-label="Close details"
            >
              ×
            </button>
          </div>
          <div
            class="artifact-details__toast"
            id="artifact-details-toast"
            aria-live="polite"
          ></div>
          <div class="artifact-details__body">
            <div
              class="artifact-details__loading"
              id="artifact-details-loading"
              hidden
            >
              Loading details…
            </div>
            <div class="artifact-details__error" id="artifact-details-error" hidden></div>
            <div class="artifact-details__content" id="artifact-details-content" hidden>
              <div class="artifact-details__meta">
                <div class="artifact-details__meta-item">
                  <span class="artifact-details__meta-label">Task ID</span>
                  <span class="artifact-details__meta-value" id="artifact-details-task-id">—</span>
                </div>
                <div class="artifact-details__meta-item">
                  <span class="artifact-details__meta-label">Created</span>
                  <span class="artifact-details__meta-value" id="artifact-details-created">—</span>
                </div>
                <div class="artifact-details__meta-item">
                  <span class="artifact-details__meta-label">Status</span>
                  <span class="artifact-details__meta-value" id="artifact-details-status">—</span>
                </div>
              </div>
              <div class="artifact-details__actions">
                <a
                  id="artifact-details-json"
                  class="button-link"
                  href="#"
                  target="_blank"
                  rel="noopener noreferrer"
                  aria-disabled="true"
                  >Download JSON</a
                >
                <a
                  id="artifact-details-zip"
                  class="button-link"
                  href="#"
                  target="_blank"
                  rel="noopener noreferrer"
                  aria-disabled="true"
                  >Download ZIP</a
                >
                <button type="button" id="artifact-details-copy-id">
                  Copy Task ID
                </button>
                <button type="button" id="artifact-details-rerun">Re-run task</button>
              </div>
              <div class="artifact-details__share">
                <div class="artifact-details__share-actions">
                  <button type="button" id="artifact-details-share-json">Share JSON</button>
                  <button type="button" id="artifact-details-share-zip">Share ZIP</button>
                </div>
                <div
                  class="artifact-details__share-feedback"
                  id="artifact-details-share-feedback"
                  data-visible="false"
                >
                  <div
                    class="artifact-details__share-summary"
                    id="artifact-details-share-summary"
                  ></div>
                  <div class="artifact-details__share-link">
                    <a
                      id="artifact-details-share-url"
                      class="artifact-details__share-url"
                      href="#"
                      target="_blank"
                      rel="noopener noreferrer"
                    ></a>
                    <button type="button" id="artifact-details-share-copy">Copy link</button>
                  </div>
                  <div class="artifact-details__share-ttl" id="artifact-details-share-ttl"></div>
                </div>
                <div
                  class="artifact-details__share-error"
                  id="artifact-details-share-error"
                  data-visible="false"
                ></div>
              </div>
              <div
                class="artifact-details__notice"
                id="artifact-details-notice"
                data-visible="false"
                role="status"
                aria-live="polite"
              ></div>
              <section>
                <h5 class="artifact-details__section-title">Logs</h5>
                <div
                  id="artifact-details-logs"
                  class="artifact-details__logs"
                  data-empty="true"
                >
                  No logs yet
                </div>
              </section>
              <section>
                <div class="artifact-details__export-header">
                  <h5 class="artifact-details__section-title">ExportSpec</h5>
                  <div class="artifact-details__export-controls">
                    <input
                      type="search"
                      id="artifact-details-export-search"
                      placeholder="Search JSON"
                      aria-label="Search ExportSpec"
                    />
                    <button type="button" id="artifact-details-copy-export">
                      Copy JSON
                    </button>
                  </div>
                </div>
                <div
                  id="artifact-details-export-viewer"
                  class="artifact-details__export-viewer"
                  data-empty="true"
                >
                  No ExportSpec available
                </div>
              </section>
            </div>
          </div>
        </aside>
      </div>
    </div>

    <script>
      const RELAY_URL = "http://localhost:3000";
      const PULL_PLUGIN_ID = "plugin-ui";
      const API_KEY_STORAGE_KEY = "relay:api-key";
      let RELAY_API_KEY = "";
      let lastTaskId = null;
      let statusSource = null;
      let currentWatchTaskId = null;
      let statusLogs = [];
      const STATUS_LOG_LIMIT = 200;
      let pullModeEnabled = false;

      const buildRelayUrl = (path, { includeApiKey = false } = {}) => {
        try {
          const url = new URL(path, RELAY_URL);
          if (includeApiKey && RELAY_API_KEY) {
            url.searchParams.set("apiKey", RELAY_API_KEY);
          }
          return url.toString();
        } catch (err) {
          console.warn("Failed to build relay URL", err);
          return `${RELAY_URL}${path}`;
        }
      };

      const applyApiKeyToInit = (init = {}) => {
        const finalInit = init ? { ...init } : {};
        const headers = new Headers(init && init.headers ? init.headers : undefined);
        if (RELAY_API_KEY) {
          if (!headers.has("Authorization")) {
            headers.set("Authorization", `Bearer ${RELAY_API_KEY}`);
          }
          if (!headers.has("X-API-Key")) {
            headers.set("X-API-Key", RELAY_API_KEY);
          }
        }
        finalInit.headers = headers;
        return finalInit;
      };

      const relayFetch = (input, init = {}) => {
        try {
          return fetch(input, applyApiKeyToInit(init));
        } catch (err) {
          return Promise.reject(err);
        }
      };

      const artifactsPanelEl = document.getElementById("panel-artifacts");
      const tabButtons = Array.from(document.querySelectorAll(".tab-button"));
      const tabPanels = new Map(
        Array.from(document.querySelectorAll(".tab-panel")).map((panel) => [panel.id, panel])
      );

      const artifactsElements = {
        tableBody: document.getElementById("artifacts-tbody"),
        searchInput: document.getElementById("artifacts-search"),
        orderSelect: document.getElementById("artifacts-order"),
        limitInput: document.getElementById("artifacts-limit"),
        prevButton: document.getElementById("artifacts-prev"),
        nextButton: document.getElementById("artifacts-next"),
        paginationInfo: document.getElementById("artifacts-pagination-info"),
        bulkButton: document.getElementById("artifacts-bulk-download"),
        errorBox: document.getElementById("artifacts-error"),
      };

      const artifactDetailsElements = {
        container: document.getElementById("artifact-details"),
        overlay: document.getElementById("artifact-details-overlay"),
        closeButton: document.getElementById("artifact-details-close"),
        toast: document.getElementById("artifact-details-toast"),
        loading: document.getElementById("artifact-details-loading"),
        error: document.getElementById("artifact-details-error"),
        content: document.getElementById("artifact-details-content"),
        taskId: document.getElementById("artifact-details-task-id"),
        created: document.getElementById("artifact-details-created"),
        status: document.getElementById("artifact-details-status"),
        jsonLink: document.getElementById("artifact-details-json"),
        zipLink: document.getElementById("artifact-details-zip"),
        copyIdButton: document.getElementById("artifact-details-copy-id"),
        copyExportButton: document.getElementById("artifact-details-copy-export"),
        rerunButton: document.getElementById("artifact-details-rerun"),
        shareJsonButton: document.getElementById("artifact-details-share-json"),
        shareZipButton: document.getElementById("artifact-details-share-zip"),
        shareFeedback: document.getElementById("artifact-details-share-feedback"),
        shareSummary: document.getElementById("artifact-details-share-summary"),
        shareLink: document.getElementById("artifact-details-share-url"),
        shareCopyButton: document.getElementById("artifact-details-share-copy"),
        shareTtl: document.getElementById("artifact-details-share-ttl"),
        shareError: document.getElementById("artifact-details-share-error"),
        notice: document.getElementById("artifact-details-notice"),
        logs: document.getElementById("artifact-details-logs"),
        exportViewer: document.getElementById("artifact-details-export-viewer"),
        exportSearch: document.getElementById("artifact-details-export-search"),
      };

      const apiKeyInput = document.getElementById("api-key-input");
      const apiKeyClearButton = document.getElementById("api-key-clear");
      const storage = (() => {
        try {
          return window.localStorage;
        } catch (err) {
          console.warn("localStorage unavailable", err);
          return null;
        }
      })();

      const persistApiKey = (value) => {
        if (!storage) return;
        if (value) {
          storage.setItem(API_KEY_STORAGE_KEY, value);
        } else {
          storage.removeItem(API_KEY_STORAGE_KEY);
        }
      };

      const loadStoredApiKey = () => {
        if (!storage) return "";
        try {
          return storage.getItem(API_KEY_STORAGE_KEY) || "";
        } catch (err) {
          console.warn("Failed to read API key from storage", err);
          return "";
        }
      };

      const applyApiKeyChange = (value) => {
        const normalized = typeof value === "string" ? value.trim() : "";
        if (normalized === RELAY_API_KEY) {
          return;
        }
        RELAY_API_KEY = normalized;
        persistApiKey(normalized);
        updateArtifactLinks();
        renderArtifactDetails();
        if (currentWatchTaskId) {
          if (normalized) {
            openTaskWatch(currentWatchTaskId);
          } else {
            closeStatusSource();
          }
        }
      };

      const storedKey = loadStoredApiKey();
      if (storedKey) {
        RELAY_API_KEY = storedKey;
      }
      if (apiKeyInput) {
        apiKeyInput.value = RELAY_API_KEY;
        apiKeyInput.addEventListener("input", (event) => {
          applyApiKeyChange(event.target.value || "");
        });
      }
      if (apiKeyClearButton) {
        apiKeyClearButton.addEventListener("click", () => {
          if (apiKeyInput) {
            apiKeyInput.value = "";
          }
          applyApiKeyChange("");
        });
      }

      const artifactDetailsState = {
        open: false,
        loading: false,
        taskId: null,
        task: null,
        result: null,
        logs: [],
        exportSpec: null,
        exportSearch: "",
        notice: null,
        toast: "",
        rerunPending: false,
        error: "",
        share: { info: null, pendingType: null, error: "" },
      };

      let currentDetailsReqId = 0;
      let currentDetailsAbort = null;

      let artifactDetailsToastTimer = null;

      const artifactsState = {
        order: "desc",
        limit: 10,
        offset: 0,
        total: 0,
        items: [],
        searchTerm: "",
        selection: new Set(),
        loading: false,
        initialized: false,
      };

      const setArtifactsError = (message) => {
        if (!artifactsElements.errorBox) return;
        if (message) {
          artifactsElements.errorBox.textContent = message;
          artifactsElements.errorBox.style.display = "block";
        } else {
          artifactsElements.errorBox.textContent = "";
          artifactsElements.errorBox.style.display = "none";
        }
      };

      const formatBytes = (bytes) => {
        const value = Number(bytes);
        if (!Number.isFinite(value) || value < 0) return "—";
        if (value === 0) return "0 B";
        const units = ["B", "KB", "MB", "GB", "TB"];
        const exponent = Math.min(Math.floor(Math.log(value) / Math.log(1024)), units.length - 1);
        const normalized = value / Math.pow(1024, exponent);
        const formatted = exponent === 0 ? normalized.toFixed(0) : normalized.toFixed(1);
        return `${formatted} ${units[exponent]}`;
      };

      const formatDateTime = (value) => {
        if (!Number.isFinite(value)) return "—";
        const date = new Date(value);
        if (Number.isNaN(date.getTime())) return "—";
        return date.toLocaleString();
      };

      const formatShareSummary = (type) => {
        return type === "json" ? "Public JSON link" : "Public ZIP link";
      };

      const formatShareTtl = (expiresAt) => {
        if (!Number.isFinite(expiresAt)) return "";
        const now = Date.now();
        const diffMs = expiresAt - now;
        if (diffMs <= 0) return "Expired";
        const minutes = Math.floor(diffMs / 60000);
        const seconds = Math.floor((diffMs % 60000) / 1000);
        let remaining = "";
        if (minutes >= 1) {
          const minuteLabel = `${minutes} min${minutes === 1 ? "" : "s"}`;
          if (minutes < 5 && seconds > 0) {
            remaining = `${minuteLabel} ${seconds} sec`;
          } else {
            remaining = minuteLabel;
          }
        } else {
          remaining = `${Math.max(seconds, 1)} sec`;
        }
        return `${remaining} left (until ${formatDateTime(expiresAt)})`;
      };

      const copyTextToClipboard = async (text) => {
        if (typeof text !== "string") return false;
        try {
          if (navigator.clipboard && navigator.clipboard.writeText) {
            await navigator.clipboard.writeText(text);
            return true;
          }
        } catch (_) {}
        try {
          const textarea = document.createElement("textarea");
          textarea.value = text;
          textarea.setAttribute("readonly", "true");
          textarea.style.position = "fixed";
          textarea.style.opacity = "0";
          textarea.style.pointerEvents = "none";
          document.body.appendChild(textarea);
          textarea.select();
          const ok = document.execCommand("copy");
          document.body.removeChild(textarea);
          return ok;
        } catch (_) {
          return false;
        }
      };

      const formatJsonPrimitive = (value) => {
        if (value === null) return "null";
        if (value === undefined) return "undefined";
        if (typeof value === "string") {
          return JSON.stringify(value);
        }
        if (typeof value === "number" || typeof value === "bigint") {
          return String(value);
        }
        if (typeof value === "boolean") {
          return value ? "true" : "false";
        }
        try {
          return JSON.stringify(value);
        } catch (_) {
          return String(value);
        }
      };

      const createSummaryLabel = (key, value) => {
        const isArray = Array.isArray(value);
        const size = isArray
          ? value.length
          : value && typeof value === "object"
          ? Object.keys(value).length
          : 0;
        const baseLabel = isArray
          ? `Array (${size} ${size === 1 ? "item" : "items"})`
          : `Object (${size} ${size === 1 ? "key" : "keys"})`;
        if (key == null) {
          return baseLabel;
        }
        return `${key}: ${baseLabel}`;
      };

      const createHighlightedFragment = (text, search) => {
        const fragment = document.createDocumentFragment();
        const value = String(text ?? "");
        if (!search || !search.normalized) {
          fragment.appendChild(document.createTextNode(value));
          return fragment;
        }
        const lower = value.toLowerCase();
        const needle = search.normalized;
        let index = lower.indexOf(needle);
        if (index === -1) {
          fragment.appendChild(document.createTextNode(value));
          return fragment;
        }
        const length = search.raw.length;
        let start = 0;
        while (index !== -1) {
          if (index > start) {
            fragment.appendChild(document.createTextNode(value.slice(start, index)));
          }
          const mark = document.createElement("mark");
          mark.textContent = value.slice(index, index + length);
          fragment.appendChild(mark);
          start = index + length;
          index = lower.indexOf(needle, start);
        }
        if (start < value.length) {
          fragment.appendChild(document.createTextNode(value.slice(start)));
        }
        return fragment;
      };

      const buildJsonViewerNode = (key, value, search, depth = 0) => {
        const container = document.createElement("div");
        container.className = "json-node";
        const searchActive = !!(search && search.normalized);
        container.dataset.searchActive = searchActive ? "true" : "false";

        if (value instanceof Date) {
          return buildJsonViewerNode(key, value.toISOString(), search, depth + 1);
        }

        if (Array.isArray(value)) {
          const details = document.createElement("details");
          const summary = document.createElement("summary");
          const label = createSummaryLabel(key, value);
          summary.appendChild(createHighlightedFragment(label, search));
          details.appendChild(summary);

          const childrenWrapper = document.createElement("div");
          childrenWrapper.className = "json-children";
          let hasMatch = searchActive && label.toLowerCase().includes(search.normalized);
          if (value.length === 0) {
            const empty = document.createElement("div");
            empty.className = "artifact-details__empty";
            empty.textContent = "[]";
            childrenWrapper.appendChild(empty);
          } else {
            value.forEach((item, index) => {
              const childKey = `[${index}]`;
              const { element, hasMatch: childMatch } = buildJsonViewerNode(
                childKey,
                item,
                search,
                depth + 1,
              );
              if (childMatch) hasMatch = true;
              childrenWrapper.appendChild(element);
            });
          }
          details.appendChild(childrenWrapper);
          details.open = !searchActive && depth <= 0 ? true : hasMatch;
          container.dataset.hasMatch = hasMatch ? "true" : "false";
          container.appendChild(details);
          return { element: container, hasMatch };
        }

        if (value && typeof value === "object") {
          const details = document.createElement("details");
          const summary = document.createElement("summary");
          const label = createSummaryLabel(key, value);
          summary.appendChild(createHighlightedFragment(label, search));
          details.appendChild(summary);

          const childrenWrapper = document.createElement("div");
          childrenWrapper.className = "json-children";
          let hasMatch = searchActive && label.toLowerCase().includes(search.normalized);
          const entries = Object.entries(value);
          if (entries.length === 0) {
            const empty = document.createElement("div");
            empty.className = "artifact-details__empty";
            empty.textContent = "{}";
            childrenWrapper.appendChild(empty);
          } else {
            for (const [childKey, childValue] of entries) {
              const { element, hasMatch: childMatch } = buildJsonViewerNode(
                childKey,
                childValue,
                search,
                depth + 1,
              );
              if (childMatch) hasMatch = true;
              childrenWrapper.appendChild(element);
            }
          }
          details.appendChild(childrenWrapper);
          details.open = !searchActive && depth <= 0 ? true : hasMatch;
          container.dataset.hasMatch = hasMatch ? "true" : "false";
          container.appendChild(details);
          return { element: container, hasMatch };
        }

        const leaf = document.createElement("div");
        leaf.className = "json-leaf";
        let hasMatch = false;
        if (key != null) {
          const keyLabel = String(key);
          const keySpan = document.createElement("span");
          keySpan.className = "json-key";
          keySpan.appendChild(createHighlightedFragment(keyLabel, search));
          leaf.appendChild(keySpan);
          leaf.appendChild(document.createTextNode(": "));
          if (searchActive && keyLabel.toLowerCase().includes(search.normalized)) {
            hasMatch = true;
          }
        }
        const valueText = formatJsonPrimitive(value);
        const valueType = value === null ? "null" : value === undefined ? "undefined" : typeof value;
        const valueSpan = document.createElement("span");
        valueSpan.className = `json-value json-value-${valueType}`;
        valueSpan.appendChild(createHighlightedFragment(valueText, search));
        if (searchActive && valueText.toLowerCase().includes(search.normalized)) {
          hasMatch = true;
        }
        leaf.appendChild(valueSpan);
        container.dataset.hasMatch = hasMatch ? "true" : "false";
        container.appendChild(leaf);
        return { element: container, hasMatch };
      };

      const renderArtifactDetailsLogs = () => {
        const target = artifactDetailsElements.logs;
        if (!target) return;
        if (artifactDetailsState.loading) {
          target.dataset.empty = "true";
          target.textContent = "Loading logs…";
          return;
        }
        if (artifactDetailsState.error) {
          target.dataset.empty = "true";
          target.textContent = "—";
          return;
        }
        const logs = Array.isArray(artifactDetailsState.logs)
          ? artifactDetailsState.logs.map((line) => String(line))
          : [];
        if (logs.length === 0) {
          target.dataset.empty = "true";
          target.textContent = "No logs yet";
        } else {
          target.dataset.empty = "false";
          target.textContent = logs.join("\n");
        }
      };

      const renderExportSpecViewer = () => {
        const viewer = artifactDetailsElements.exportViewer;
        if (!viewer) return;
        const spec = artifactDetailsState.exportSpec;
        const rawSearch = artifactDetailsState.exportSearch || "";
        const trimmed = rawSearch.trim();
        const search = trimmed
          ? {
              raw: trimmed,
              normalized: trimmed.toLowerCase(),
            }
          : null;
        if (artifactDetailsState.loading) {
          viewer.dataset.empty = "true";
          viewer.innerHTML = "Loading ExportSpec…";
          return;
        }
        if (artifactDetailsState.error) {
          viewer.dataset.empty = "true";
          viewer.innerHTML = "—";
          return;
        }
        viewer.innerHTML = "";
        if (!spec || typeof spec !== "object") {
          viewer.dataset.empty = "true";
          viewer.textContent = "No ExportSpec available";
          return;
        }
        const { element, hasMatch } = buildJsonViewerNode(null, spec, search, 0);
        viewer.dataset.empty = "false";
        viewer.appendChild(element);
        if (search && !hasMatch) {
          const empty = document.createElement("div");
          empty.className = "artifact-details__empty";
          empty.textContent = `No matches for "${search.raw}"`;
          viewer.appendChild(empty);
        }
      };

      const renderArtifactDetails = () => {
        const container = artifactDetailsElements.container;
        if (!container) return;
        container.dataset.open = artifactDetailsState.open ? "true" : "false";
        container.setAttribute("aria-hidden", artifactDetailsState.open ? "false" : "true");

        if (!artifactDetailsState.open) {
          if (artifactDetailsElements.toast) {
            artifactDetailsElements.toast.dataset.visible = "false";
            artifactDetailsElements.toast.textContent = "";
          }
          return;
        }

        if (artifactDetailsElements.loading) {
          artifactDetailsElements.loading.hidden = !artifactDetailsState.loading;
        }
        if (artifactDetailsElements.error) {
          const hasError = Boolean(artifactDetailsState.error);
          artifactDetailsElements.error.hidden = !hasError;
          artifactDetailsElements.error.textContent = hasError ? artifactDetailsState.error : "";
        }
        const hasData = !artifactDetailsState.loading && !artifactDetailsState.error;
        if (artifactDetailsElements.content) {
          artifactDetailsElements.content.hidden = !hasData;
        }

        if (artifactDetailsElements.toast) {
          const toastVisible = Boolean(artifactDetailsState.toast);
          artifactDetailsElements.toast.dataset.visible = toastVisible ? "true" : "false";
          artifactDetailsElements.toast.textContent = toastVisible ? artifactDetailsState.toast : "";
        }

        if (artifactDetailsElements.jsonLink) {
          artifactDetailsElements.jsonLink.href = "#";
          artifactDetailsElements.jsonLink.setAttribute("aria-disabled", "true");
          artifactDetailsElements.jsonLink.tabIndex = -1;
        }
        if (artifactDetailsElements.zipLink) {
          artifactDetailsElements.zipLink.href = "#";
          artifactDetailsElements.zipLink.setAttribute("aria-disabled", "true");
          artifactDetailsElements.zipLink.tabIndex = -1;
        }
        if (artifactDetailsElements.copyIdButton) {
          artifactDetailsElements.copyIdButton.disabled = true;
        }
        if (artifactDetailsElements.copyExportButton) {
          artifactDetailsElements.copyExportButton.disabled = true;
        }
        if (artifactDetailsElements.rerunButton) {
          artifactDetailsElements.rerunButton.disabled = true;
          artifactDetailsElements.rerunButton.textContent = artifactDetailsState.rerunPending
            ? "Re-running…"
            : "Re-run task";
        }
        if (artifactDetailsElements.notice) {
          artifactDetailsElements.notice.dataset.visible = "false";
          artifactDetailsElements.notice.innerHTML = "";
        }
        if (artifactDetailsElements.exportSearch) {
          artifactDetailsElements.exportSearch.value = artifactDetailsState.exportSearch;
        }
        const shareState =
          artifactDetailsState.share || { info: null, pendingType: null, error: "" };
        if (artifactDetailsElements.shareJsonButton) {
          artifactDetailsElements.shareJsonButton.disabled = true;
          artifactDetailsElements.shareJsonButton.textContent =
            shareState.pendingType === "json" ? "Sharing…" : "Share JSON";
        }
        if (artifactDetailsElements.shareZipButton) {
          artifactDetailsElements.shareZipButton.disabled = true;
          artifactDetailsElements.shareZipButton.textContent =
            shareState.pendingType === "zip" ? "Sharing…" : "Share ZIP";
        }
        if (artifactDetailsElements.shareFeedback) {
          artifactDetailsElements.shareFeedback.dataset.visible = "false";
        }
        if (artifactDetailsElements.shareSummary) {
          artifactDetailsElements.shareSummary.textContent = "";
        }
        if (artifactDetailsElements.shareLink) {
          artifactDetailsElements.shareLink.textContent = "";
          artifactDetailsElements.shareLink.href = "#";
        }
        if (artifactDetailsElements.shareTtl) {
          artifactDetailsElements.shareTtl.textContent = "";
        }
        if (artifactDetailsElements.shareCopyButton) {
          artifactDetailsElements.shareCopyButton.disabled = true;
        }
        if (artifactDetailsElements.shareError) {
          artifactDetailsElements.shareError.dataset.visible = "false";
          artifactDetailsElements.shareError.textContent = "";
        }

        if (!hasData) {
          renderArtifactDetailsLogs();
          renderExportSpecViewer();
          return;
        }

        const taskId = artifactDetailsState.taskId;
        if (artifactDetailsElements.taskId) {
          artifactDetailsElements.taskId.textContent = taskId || "—";
        }
        if (artifactDetailsElements.created) {
          const createdAt =
            artifactDetailsState.task && Number.isFinite(artifactDetailsState.task.createdAt)
              ? artifactDetailsState.task.createdAt
              : null;
          artifactDetailsElements.created.textContent = createdAt != null ? formatDateTime(createdAt) : "—";
        }
        if (artifactDetailsElements.status) {
          const statusText =
            (artifactDetailsState.result && artifactDetailsState.result.status) ||
            (artifactDetailsState.task && artifactDetailsState.task.status) ||
            "unknown";
          artifactDetailsElements.status.textContent = statusText;
        }
        if (artifactDetailsElements.jsonLink && taskId) {
          artifactDetailsElements.jsonLink.href = buildRelayUrl(
            `/tasks/${encodeURIComponent(taskId)}/artifact`,
            { includeApiKey: !!RELAY_API_KEY },
          );
          artifactDetailsElements.jsonLink.setAttribute("aria-disabled", "false");
          artifactDetailsElements.jsonLink.tabIndex = 0;
        }
        if (artifactDetailsElements.zipLink && taskId) {
          artifactDetailsElements.zipLink.href = buildRelayUrl(
            `/tasks/${encodeURIComponent(taskId)}/package.zip`,
            { includeApiKey: !!RELAY_API_KEY },
          );
          artifactDetailsElements.zipLink.setAttribute("aria-disabled", "false");
          artifactDetailsElements.zipLink.tabIndex = 0;
        }
        if (artifactDetailsElements.copyIdButton) {
          artifactDetailsElements.copyIdButton.disabled = !taskId;
        }
        if (artifactDetailsElements.copyExportButton) {
          artifactDetailsElements.copyExportButton.disabled = !artifactDetailsState.exportSpec;
        }
        if (artifactDetailsElements.rerunButton) {
          const hasSpec = artifactDetailsState.task && artifactDetailsState.task.taskSpec;
          artifactDetailsElements.rerunButton.disabled = !hasSpec || artifactDetailsState.rerunPending;
          artifactDetailsElements.rerunButton.textContent = artifactDetailsState.rerunPending
            ? "Re-running…"
            : "Re-run task";
        }
        if (artifactDetailsElements.shareJsonButton) {
          const isPending = shareState.pendingType === "json";
          artifactDetailsElements.shareJsonButton.disabled = !taskId || Boolean(shareState.pendingType);
          artifactDetailsElements.shareJsonButton.textContent = isPending ? "Sharing…" : "Share JSON";
        }
        if (artifactDetailsElements.shareZipButton) {
          const isPending = shareState.pendingType === "zip";
          artifactDetailsElements.shareZipButton.disabled = !taskId || Boolean(shareState.pendingType);
          artifactDetailsElements.shareZipButton.textContent = isPending ? "Sharing…" : "Share ZIP";
        }
        if (artifactDetailsElements.shareCopyButton) {
          artifactDetailsElements.shareCopyButton.disabled =
            !shareState.info || !shareState.info.url;
        }
        if (shareState.info && shareState.info.url) {
          if (artifactDetailsElements.shareFeedback) {
            artifactDetailsElements.shareFeedback.dataset.visible = "true";
          }
          if (artifactDetailsElements.shareSummary) {
            artifactDetailsElements.shareSummary.textContent = formatShareSummary(shareState.info.type);
          }
          if (artifactDetailsElements.shareLink) {
            artifactDetailsElements.shareLink.textContent = shareState.info.url;
            artifactDetailsElements.shareLink.href = shareState.info.url;
          }
          if (artifactDetailsElements.shareTtl) {
            artifactDetailsElements.shareTtl.textContent = formatShareTtl(shareState.info.expiresAt);
          }
        }
        if (artifactDetailsElements.shareError) {
          const shareError = shareState.error ? String(shareState.error) : "";
          artifactDetailsElements.shareError.dataset.visible = shareError ? "true" : "false";
          artifactDetailsElements.shareError.textContent = shareError;
        }

        renderArtifactDetailsLogs();
        renderExportSpecViewer();

        if (artifactDetailsElements.notice) {
          const notice = artifactDetailsState.notice;
          if (notice && notice.message) {
            artifactDetailsElements.notice.dataset.visible = "true";
            artifactDetailsElements.notice.innerHTML = "";
            const messageSpan = document.createElement("span");
            messageSpan.textContent = notice.message;
            artifactDetailsElements.notice.appendChild(messageSpan);
            if (Array.isArray(notice.actions) && notice.actions.length > 0) {
              const actionsContainer = document.createElement("div");
              actionsContainer.className = "artifact-details__notice-actions";
              for (const action of notice.actions) {
                if (!action || typeof action.onClick !== "function" || !action.label) continue;
                const button = document.createElement("button");
                button.type = "button";
                button.textContent = action.label;
                button.addEventListener("click", () => action.onClick());
                actionsContainer.appendChild(button);
              }
              if (actionsContainer.childNodes.length > 0) {
                artifactDetailsElements.notice.appendChild(actionsContainer);
              }
            }
          } else {
            artifactDetailsElements.notice.dataset.visible = "false";
            artifactDetailsElements.notice.innerHTML = "";
          }
        }
      };

      const setArtifactDetailsToast = (message, duration = 2200) => {
        artifactDetailsState.toast = message ? String(message) : "";
        renderArtifactDetails();
        clearTimeout(artifactDetailsToastTimer);
        if (artifactDetailsState.toast) {
          artifactDetailsToastTimer = setTimeout(() => {
            artifactDetailsState.toast = "";
            renderArtifactDetails();
          }, duration);
        }
      };

      const setArtifactDetailsNotice = (notice) => {
        if (!notice) {
          artifactDetailsState.notice = null;
        } else if (typeof notice === "string") {
          artifactDetailsState.notice = { message: notice, actions: [] };
        } else {
          artifactDetailsState.notice = {
            message: notice.message || "",
            actions: Array.isArray(notice.actions) ? notice.actions : [],
          };
        }
        renderArtifactDetails();
      };

      const cloneTaskSpec = (taskSpec) => {
        if (!taskSpec || typeof taskSpec !== "object") return null;
        if (typeof structuredClone === "function") {
          try {
            return structuredClone(taskSpec);
          } catch (_) {}
        }
        try {
          return JSON.parse(JSON.stringify(taskSpec));
        } catch (_) {
          return null;
        }
      };

      const loadArtifactDetails = async (taskId) => {
        if (!taskId) return;
        const reqId = ++currentDetailsReqId;
        if (currentDetailsAbort) currentDetailsAbort.abort();
        currentDetailsAbort = new AbortController();
        const { signal } = currentDetailsAbort;

        const safeSetState = (mutator) => {
          if (reqId !== currentDetailsReqId) return;
          mutator();
          renderArtifactDetails();
        };

        artifactDetailsState.loading = true;
        artifactDetailsState.error = "";
        artifactDetailsState.task = null;
        artifactDetailsState.result = null;
        artifactDetailsState.logs = [];
        artifactDetailsState.exportSpec = null;
        renderArtifactDetails();

        try {
          const taskRes = await relayFetch(
            buildRelayUrl(`/tasks/${encodeURIComponent(taskId)}`),
            {
              signal,
            },
          );
          if (!taskRes.ok) {
            throw new Error(`Task request failed: HTTP ${taskRes.status}`);
          }
          const taskData = await taskRes.json();
          safeSetState(() => {
            artifactDetailsState.task = taskData;
            artifactDetailsState.logs = Array.isArray(taskData.logs)
              ? taskData.logs.map((line) => String(line))
              : [];
          });

          let resultPayload = null;
          try {
            const resultRes = await relayFetch(
              buildRelayUrl(`/tasks/${encodeURIComponent(taskId)}/result`),
              { signal },
            );
            if (resultRes.status === 404) resultPayload = null;
            else if (!resultRes.ok) throw new Error(`HTTP ${resultRes.status}`);
            else resultPayload = await resultRes.json();
          } catch (e) {
            if (e.name !== "AbortError") {
              throw new Error(`Result fetch failed: ${e?.message || e}`);
            }
          }

          safeSetState(() => {
            artifactDetailsState.result = resultPayload;
            artifactDetailsState.exportSpec =
              resultPayload && typeof resultPayload.exportSpec === "object"
                ? resultPayload.exportSpec
                : null;
            artifactDetailsState.error = "";
          });
        } catch (err) {
          if (err.name !== "AbortError") {
            safeSetState(() => {
              artifactDetailsState.error = `Failed to load details: ${err?.message || err}`;
            });
          }
        } finally {
          safeSetState(() => {
            artifactDetailsState.loading = false;
          });
          if (reqId === currentDetailsReqId) {
            currentDetailsAbort = null;
          }
        }
      };

      const shareArtifactLink = async (type) => {
        const taskId = artifactDetailsState.taskId;
        if (!taskId) return;
        if (!artifactDetailsState.share) {
          artifactDetailsState.share = { info: null, pendingType: null, error: "" };
        }
        artifactDetailsState.share.pendingType = type;
        artifactDetailsState.share.error = "";
        renderArtifactDetails();

        try {
          const response = await relayFetch(
            buildRelayUrl(`/tasks/${encodeURIComponent(taskId)}/share`),
            {
              method: "POST",
              headers: { "Content-Type": "application/json" },
              body: JSON.stringify({ type }),
            },
          );
          if (!response.ok) {
            let message = `HTTP ${response.status}`;
            try {
              const payload = await response.json();
              if (payload && typeof payload.error === "string" && payload.error.trim()) {
                message = payload.error.trim();
              }
            } catch (_) {
              try {
                const text = await response.text();
                if (text && text.trim()) {
                  message = text.trim();
                }
              } catch (_) {}
            }
            throw new Error(message);
          }

          const payload = await response.json();
          const url = typeof payload.url === "string" ? payload.url : "";
          const expiresAtRaw = Number(payload.expiresAt);
          if (!url) {
            throw new Error("Invalid share response");
          }
          artifactDetailsState.share.info = {
            type,
            url,
            expiresAt: Number.isFinite(expiresAtRaw) ? expiresAtRaw : null,
          };
          artifactDetailsState.share.error = "";
        } catch (err) {
          artifactDetailsState.share.error = `Share failed: ${err?.message || err}`;
        } finally {
          artifactDetailsState.share.pendingType = null;
          renderArtifactDetails();
        }
      };

      const openArtifactDetails = (taskId) => {
        if (!taskId) return;
        artifactDetailsState.open = true;
        artifactDetailsState.taskId = taskId; // фиксируем выбранный
        artifactDetailsState.notice = null;
        artifactDetailsState.toast = "";
        artifactDetailsState.exportSearch = "";
        artifactDetailsState.rerunPending = false;
        artifactDetailsState.error = "";
        artifactDetailsState.logs = [];
        artifactDetailsState.exportSpec = null;
        artifactDetailsState.task = null;
        artifactDetailsState.result = null;
        artifactDetailsState.share = { info: null, pendingType: null, error: "" };
        if (artifactDetailsElements.exportSearch) {
          artifactDetailsElements.exportSearch.value = "";
        }
        clearTimeout(artifactDetailsToastTimer);
        artifactDetailsToastTimer = null;
        renderArtifactDetails();
        loadArtifactDetails(taskId);
        renderArtifactsTable();
      };

      const closeArtifactDetails = () => {
        if (!artifactDetailsState.open) return;
        artifactDetailsState.open = false;
        artifactDetailsState.taskId = null;
        artifactDetailsState.task = null;
        artifactDetailsState.result = null;
        artifactDetailsState.logs = [];
        artifactDetailsState.exportSpec = null;
        artifactDetailsState.exportSearch = "";
        artifactDetailsState.notice = null;
        artifactDetailsState.toast = "";
        artifactDetailsState.error = "";
        artifactDetailsState.loading = false;
        artifactDetailsState.rerunPending = false;
        artifactDetailsState.share = { info: null, pendingType: null, error: "" };
        if (artifactDetailsElements.exportSearch) {
          artifactDetailsElements.exportSearch.value = "";
        }
        clearTimeout(artifactDetailsToastTimer);
        artifactDetailsToastTimer = null;
        renderArtifactDetails();
        renderArtifactsTable();
      };

      const handleArtifactDetailsKeydown = (event) => {
        if (event.key === "Escape" && artifactDetailsState.open) {
          event.preventDefault();
          closeArtifactDetails();
        }
      };

      const rerunArtifactTask = async () => {
        if (artifactDetailsState.rerunPending) return;
        const task = artifactDetailsState.task;
        if (!task || !task.taskSpec) {
          setArtifactDetailsToast("TaskSpec is not available");
          return;
        }
        const clonedSpec = cloneTaskSpec(task.taskSpec);
        if (!clonedSpec) {
          setArtifactDetailsToast("Failed to prepare TaskSpec");
          return;
        }
        const originalMeta =
          clonedSpec.meta && typeof clonedSpec.meta === "object" ? { ...clonedSpec.meta } : {};
        const originalId = artifactDetailsState.taskId;
        if (typeof originalMeta.id === "string" && originalMeta.id.trim()) {
          const suffix = Math.floor(Date.now() / 1000).toString(36);
          originalMeta.id = `${originalMeta.id}-rerun-${suffix}`;
        }
        if (originalId) {
          originalMeta.rerunOf = originalId;
        }
        clonedSpec.meta = originalMeta;
        artifactDetailsState.rerunPending = true;
        setArtifactDetailsNotice(null);
        renderArtifactDetails();
        try {
          const res = await relayFetch(buildRelayUrl(`/tasks`), {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify({ taskSpec: clonedSpec }),
          });
          if (!res.ok) {
            throw new Error(`HTTP ${res.status}`);
          }
          const data = await res.json();
          const newTaskId = data && typeof data.taskId === "string" ? data.taskId : null;
          if (!newTaskId) {
            throw new Error("Unexpected response");
          }
          artifactDetailsState.rerunPending = false;
          setArtifactDetailsNotice({
            message: `Task re-queued: ${newTaskId}`,
            actions: [
              {
                label: "Watch status",
                onClick: () => openTaskWatch(newTaskId),
              },
              {
                label: "Load in Builder",
                onClick: () =>
                  assignFetchedTask(
                    newTaskId,
                    clonedSpec,
                    "Re-run",
                    "Plugin: re-run queued from details",
                  ),
              },
            ],
          });
          setArtifactDetailsToast("Task re-run created");
        } catch (err) {
          artifactDetailsState.rerunPending = false;
          const message = err && err.message ? err.message : err;
          setArtifactDetailsNotice({ message: `Re-run failed: ${message}` });
        } finally {
          renderArtifactDetails();
        }
      };

      const updateBulkButtonState = () => {
        const button = artifactsElements.bulkButton;
        if (!button) return;
        const count = artifactsState.selection.size;
        button.textContent =
          count > 0
            ? `Download selected as ZIP (${count})`
            : "Download selected as ZIP";
        if (artifactsState.loading || count === 0) {
          button.setAttribute("disabled", "true");
        } else {
          button.removeAttribute("disabled");
        }
      };

      const updatePaginationControls = () => {
        const { prevButton, nextButton } = artifactsElements;
        if (prevButton) {
          if (artifactsState.loading || artifactsState.offset <= 0) {
            prevButton.setAttribute("disabled", "true");
          } else {
            prevButton.removeAttribute("disabled");
          }
        }
        if (nextButton) {
          const hasMore =
            artifactsState.total > 0 &&
            artifactsState.offset + artifactsState.limit < artifactsState.total;
          if (artifactsState.loading || !hasMore) {
            nextButton.setAttribute("disabled", "true");
          } else {
            nextButton.removeAttribute("disabled");
          }
        }
      };

      const renderArtifactsTable = () => {
        const tbody = artifactsElements.tableBody;
        if (!tbody) return;
        tbody.innerHTML = "";
        const searchTerm = artifactsState.searchTerm;
        const filtered = artifactsState.items.filter((item) => {
          if (!searchTerm) return true;
          const id = typeof item.id === "string" ? item.id : String(item.id ?? "");
          return id.toLowerCase().includes(searchTerm);
        });

        if (filtered.length === 0) {
          const emptyRow = document.createElement("tr");
          const cell = document.createElement("td");
          cell.colSpan = 6;
          cell.className = "muted";
          cell.textContent = artifactsState.items.length === 0 ? "No artifacts" : "No matches";
          emptyRow.appendChild(cell);
          tbody.appendChild(emptyRow);
        } else {
          for (const item of filtered) {
            const safeId = typeof item.id === "string" ? item.id : String(item.id ?? "");
            const row = document.createElement("tr");
            row.dataset.clickable = "true";
            row.tabIndex = 0;
            if (artifactDetailsState.open && artifactDetailsState.taskId === safeId) {
              row.dataset.selected = "true";
            } else {
              row.dataset.selected = "false";
            }

            row.addEventListener("click", (event) => {
              if (event.target && event.target.closest("input, button, a")) {
                return;
              }
              openArtifactDetails(safeId);
            });
            row.addEventListener("keydown", (event) => {
              if (event.key === "Enter" || event.key === " ") {
                if (event.target && event.target.closest("input, button, a")) {
                  return;
                }
                event.preventDefault();
                openArtifactDetails(safeId);
              }
            });

            const selectCell = document.createElement("td");
            const checkbox = document.createElement("input");
            checkbox.type = "checkbox";
            checkbox.checked = artifactsState.selection.has(safeId);
            checkbox.addEventListener("click", (event) => {
              event.stopPropagation();
            });
            checkbox.addEventListener("keydown", (event) => {
              if (event.key === " " || event.key === "Enter") {
                event.stopPropagation();
              }
            });
            checkbox.addEventListener("change", (event) => {
              if (event.target.checked) {
                artifactsState.selection.add(safeId);
              } else {
                artifactsState.selection.delete(safeId);
              }
              updateBulkButtonState();
            });
            selectCell.appendChild(checkbox);
            row.appendChild(selectCell);

            const idCell = document.createElement("td");
            idCell.textContent = safeId;
            row.appendChild(idCell);

            const createdCell = document.createElement("td");
            createdCell.textContent = formatDateTime(item.createdAt);
            row.appendChild(createdCell);

            const sizeCell = document.createElement("td");
            sizeCell.textContent = formatBytes(item.size);
            row.appendChild(sizeCell);

            const jsonCell = document.createElement("td");
            jsonCell.className = "actions";
            const jsonLink = document.createElement("a");
            jsonLink.href = buildRelayUrl(
              `/tasks/${encodeURIComponent(safeId)}/artifact`,
              { includeApiKey: !!RELAY_API_KEY },
            );
            jsonLink.textContent = "Download JSON";
            jsonLink.target = "_blank";
            jsonLink.rel = "noopener noreferrer";
            jsonLink.download = `${safeId}.json`;
            jsonLink.addEventListener("click", (event) => {
              event.stopPropagation();
            });
            jsonCell.appendChild(jsonLink);
            row.appendChild(jsonCell);

            const zipCell = document.createElement("td");
            zipCell.className = "actions";
            const zipLink = document.createElement("a");
            zipLink.href = buildRelayUrl(
              `/tasks/${encodeURIComponent(safeId)}/package.zip`,
              { includeApiKey: !!RELAY_API_KEY },
            );
            zipLink.textContent = "Download ZIP";
            zipLink.target = "_blank";
            zipLink.rel = "noopener noreferrer";
            zipLink.download = `${safeId}.zip`;
            zipLink.addEventListener("click", (event) => {
              event.stopPropagation();
            });
            zipCell.appendChild(zipLink);
            row.appendChild(zipCell);

            tbody.appendChild(row);
          }
        }

        const infoEl = artifactsElements.paginationInfo;
        if (infoEl) {
          if (artifactsState.total === 0) {
            infoEl.textContent = "No artifacts";
          } else {
            const currentPage = Math.floor(artifactsState.offset / artifactsState.limit) + 1;
            const totalPages = Math.max(1, Math.ceil(artifactsState.total / artifactsState.limit));
            const visibleLabel =
              filtered.length === artifactsState.items.length
                ? `showing ${filtered.length} of ${artifactsState.items.length}`
                : `filtered ${filtered.length} of ${artifactsState.items.length}`;
            infoEl.textContent = `Page ${currentPage}/${totalPages}, ${visibleLabel} (total ${artifactsState.total})`;
          }
        }
        updateBulkButtonState();
        updatePaginationControls();
      };

      const setArtifactsLoading = (loading) => {
        artifactsState.loading = loading;
        if (artifactsPanelEl) {
          artifactsPanelEl.dataset.loading = loading ? "true" : "false";
        }
        updateBulkButtonState();
        updatePaginationControls();
      };

      const fetchArtifacts = async () => {
        if (artifactsState.loading) return;
        setArtifactsError("");
        setArtifactsLoading(true);
        try {
          const params = new URLSearchParams();
          params.set("offset", String(artifactsState.offset));
          params.set("limit", String(artifactsState.limit));
          params.set("order", artifactsState.order);
          const res = await relayFetch(
            buildRelayUrl(`/artifacts?${params.toString()}`),
          );
          if (!res.ok) {
            throw new Error(`HTTP ${res.status}`);
          }
          const data = await res.json();
          artifactsState.items = Array.isArray(data.items) ? data.items : [];
          const totalValue = Number(data.total);
          const offsetValue = Number(data.offset);
          const limitValue = Number(data.limit);
          artifactsState.total = Number.isFinite(totalValue)
            ? totalValue
            : artifactsState.items.length;
          artifactsState.offset = Number.isFinite(offsetValue) ? offsetValue : artifactsState.offset;
          artifactsState.limit = Number.isFinite(limitValue) ? limitValue : artifactsState.limit;
          if (artifactsElements.limitInput) {
            artifactsElements.limitInput.value = String(artifactsState.limit);
          }
          if (artifactsElements.orderSelect) {
            artifactsElements.orderSelect.value = artifactsState.order;
          }
          const toRemove = [];
          artifactsState.selection.forEach((id) => {
            if (!artifactsState.items.some((item) => item && item.id === id)) {
              toRemove.push(id);
            }
          });
          for (const id of toRemove) {
            artifactsState.selection.delete(id);
          }
        } catch (err) {
          console.error("Failed to load artifacts", err);
          setArtifactsError(
            `Failed to load artifacts: ${err && err.message ? err.message : err}`
          );
          artifactsState.items = [];
          artifactsState.total = 0;
        } finally {
          setArtifactsLoading(false);
          renderArtifactsTable();
        }
      };

      const downloadSelectedArtifacts = async () => {
        const button = artifactsElements.bulkButton;
        if (!button || artifactsState.selection.size === 0) return;
        if (artifactsState.loading) return;
        setArtifactsError("");
        button.setAttribute("disabled", "true");
        button.dataset.loading = "true";
        try {
          const ids = Array.from(artifactsState.selection);
          const res = await relayFetch(buildRelayUrl(`/artifacts/bulk.zip`), {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify({ ids }),
          });
          if (!res.ok) {
            let errorText = `Bulk download failed: HTTP ${res.status}`;
            try {
              const text = await res.text();
              if (text) {
                errorText += ` (${text.slice(0, 160)})`;
              }
            } catch (_) {}
            throw new Error(errorText);
          }
          const blob = await res.blob();
          const url = URL.createObjectURL(blob);
          const link = document.createElement("a");
          const stamp = new Date().toISOString().replace(/[:.]/g, "-");
          link.href = url;
          link.download = `artifacts-${stamp}.zip`;
          document.body.appendChild(link);
          link.click();
          document.body.removeChild(link);
          setTimeout(() => {
            URL.revokeObjectURL(url);
          }, 1500);
        } catch (err) {
          setArtifactsError(
            `Bulk download error: ${err && err.message ? err.message : err}`
          );
        } finally {
          button.dataset.loading = "false";
          updateBulkButtonState();
        }
      };

      const setActiveTab = (targetId) => {
        for (const btn of tabButtons) {
          const isActive = btn.dataset.target === targetId;
          btn.classList.toggle("is-active", isActive);
        }
        for (const [id, panel] of tabPanels.entries()) {
          panel.classList.toggle("is-active", id === targetId);
        }
        if (targetId === "panel-artifacts" && !artifactsState.initialized) {
          artifactsState.initialized = true;
          fetchArtifacts();
        }
      };

      tabButtons.forEach((btn) => {
        btn.addEventListener("click", () => {
          const target = btn.dataset.target;
          if (target) {
            setActiveTab(target);
          }
        });
      });

      if (artifactsElements.searchInput) {
        artifactsElements.searchInput.addEventListener("input", (event) => {
          const value = event.target.value || "";
          artifactsState.searchTerm = value.toLowerCase();
          renderArtifactsTable();
        });
      }
      if (artifactsElements.orderSelect) {
        artifactsElements.orderSelect.addEventListener("change", (event) => {
          const value = String(event.target.value || "desc").toLowerCase();
          artifactsState.order = value === "asc" ? "asc" : "desc";
          artifactsState.offset = 0;
          if (artifactsState.initialized) {
            fetchArtifacts();
          }
        });
      }
      if (artifactsElements.limitInput) {
        artifactsElements.limitInput.addEventListener("change", (event) => {
          const value = Number(event.target.value);
          if (!Number.isFinite(value)) return;
          const clamped = Math.min(50, Math.max(1, Math.floor(value)));
          artifactsState.limit = clamped;
          artifactsState.offset = 0;
          artifactsElements.limitInput.value = String(clamped);
          if (artifactsState.initialized) {
            fetchArtifacts();
          }
        });
      }
      if (artifactsElements.prevButton) {
        artifactsElements.prevButton.addEventListener("click", () => {
          if (artifactsState.loading) return;
          const nextOffset = Math.max(0, artifactsState.offset - artifactsState.limit);
          if (nextOffset === artifactsState.offset) return;
          artifactsState.offset = nextOffset;
          fetchArtifacts();
        });
      }
      if (artifactsElements.nextButton) {
        artifactsElements.nextButton.addEventListener("click", () => {
          if (artifactsState.loading) return;
          const nextOffset = artifactsState.offset + artifactsState.limit;
          if (artifactsState.total > 0 && nextOffset >= artifactsState.total) return;
          artifactsState.offset = nextOffset;
          fetchArtifacts();
        });
      }
      if (artifactsElements.bulkButton) {
        artifactsElements.bulkButton.addEventListener("click", () => {
          downloadSelectedArtifacts();
        });
      }

      if (artifactDetailsElements.overlay) {
        artifactDetailsElements.overlay.addEventListener("click", () => {
          closeArtifactDetails();
        });
      }
      if (artifactDetailsElements.closeButton) {
        artifactDetailsElements.closeButton.addEventListener("click", () => {
          closeArtifactDetails();
        });
      }
      if (artifactDetailsElements.exportSearch) {
        artifactDetailsElements.exportSearch.addEventListener("input", (event) => {
          const value = typeof event.target.value === "string" ? event.target.value : "";
          artifactDetailsState.exportSearch = value;
          renderExportSpecViewer();
        });
      }
      if (artifactDetailsElements.copyIdButton) {
        artifactDetailsElements.copyIdButton.addEventListener("click", async () => {
          if (!artifactDetailsState.taskId) return;
          const ok = await copyTextToClipboard(artifactDetailsState.taskId);
          setArtifactDetailsToast(ok ? "Task ID copied" : "Copy failed");
        });
      }
      if (artifactDetailsElements.copyExportButton) {
        artifactDetailsElements.copyExportButton.addEventListener("click", async () => {
          if (!artifactDetailsState.exportSpec) return;
          try {
            const text = JSON.stringify(artifactDetailsState.exportSpec, null, 2);
            const ok = await copyTextToClipboard(text);
            setArtifactDetailsToast(ok ? "ExportSpec copied" : "Copy failed");
          } catch (err) {
            setArtifactDetailsToast(
              `Copy failed: ${err && err.message ? err.message : "Unexpected error"}`,
            );
          }
        });
      }
      if (artifactDetailsElements.shareJsonButton) {
        artifactDetailsElements.shareJsonButton.addEventListener("click", () => {
          shareArtifactLink("json");
        });
      }
      if (artifactDetailsElements.shareZipButton) {
        artifactDetailsElements.shareZipButton.addEventListener("click", () => {
          shareArtifactLink("zip");
        });
      }
      if (artifactDetailsElements.shareCopyButton) {
        artifactDetailsElements.shareCopyButton.addEventListener("click", async () => {
          const info = artifactDetailsState.share && artifactDetailsState.share.info;
          if (!info || !info.url) return;
          const ok = await copyTextToClipboard(info.url);
          setArtifactDetailsToast(ok ? "Link copied" : "Copy failed");
        });
      }
      if (artifactDetailsElements.rerunButton) {
        artifactDetailsElements.rerunButton.addEventListener("click", () => {
          rerunArtifactTask();
        });
      }

      renderArtifactDetails();
      document.addEventListener("keydown", handleArtifactDetailsKeydown);

      renderArtifactsTable();
      setActiveTab("panel-builder");

      const log = (m) => {
        const el = document.getElementById("log");

        el.textContent +=
          (typeof m === "string" ? m : JSON.stringify(m, null, 2)) + "\n";
        el.scrollTop = el.scrollHeight;
      };

      const rlog = (m) => {
        const el = document.getElementById("relay-log");
        if (!el) return;
        el.textContent +=
          (typeof m === "string" ? m : JSON.stringify(m, null, 2)) + "\n";
        el.scrollTop = el.scrollHeight;
      };
      const statusPanelEl = document.getElementById("status-panel");
      const statusTextEl = document.getElementById("status-text");
      const statusLogEl = document.getElementById("status-log");
      const statusConnectionEl = document.getElementById("status-connection");
      const artifactLinkEl = document.getElementById("artifact-download");
      const artifactZipLinkEl = document.getElementById("artifact-zip-download");
      const pullModeEl = document.getElementById("pull-mode");
      if (pullModeEl) {
        pullModeEnabled = !!pullModeEl.checked;
        pullModeEl.addEventListener("change", (event) => {
          pullModeEnabled = !!event.target.checked;
          rlog(`Pull mode ${pullModeEnabled ? "enabled" : "disabled"}`);
        });
      }

      function updateArtifactLinks() {
        if (artifactLinkEl) {
          if (lastTaskId) {
            artifactLinkEl.href = buildRelayUrl(
              `/tasks/${lastTaskId}/artifact`,
              { includeApiKey: !!RELAY_API_KEY },
            );
            artifactLinkEl.setAttribute("aria-disabled", "false");
          } else {
            artifactLinkEl.href = "#";
            artifactLinkEl.setAttribute("aria-disabled", "true");
          }
        }
        if (artifactZipLinkEl) {
          if (lastTaskId) {
            artifactZipLinkEl.href = buildRelayUrl(
              `/tasks/${lastTaskId}/package.zip`,
              { includeApiKey: !!RELAY_API_KEY },
            );
            artifactZipLinkEl.setAttribute("aria-disabled", "false");
          } else {
            artifactZipLinkEl.href = "#";
            artifactZipLinkEl.setAttribute("aria-disabled", "true");
          }
        }
      }

      const setTaskSpecTextarea = (taskSpec) => {
        const textarea = document.getElementById("spec");
        if (!textarea || taskSpec == null) return;
        if (typeof taskSpec === "string") {
          textarea.value = taskSpec;
          return;
        }
        try {
          textarea.value = JSON.stringify(taskSpec, null, 2);
        } catch (err) {
          textarea.value = String(taskSpec);
        }
      };

      const assignFetchedTask = async (taskId, taskSpec, label, logMessage) => {
        if (!taskId) {
          rlog(`${label}: no tasks available`);
          lastTaskId = null;
          updateArtifactLinks();
          closeStatusSource();
          return;
        }
        lastTaskId = taskId;
        updateArtifactLinks();
        setTaskSpecTextarea(taskSpec);
        rlog(`${label} OK (id=${taskId})`);
        openTaskWatch(taskId);
        if (!logMessage) return;
        try {
          await relayFetch(buildRelayUrl(`/tasks/${taskId}/log`), {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify({ message: logMessage }),
          });
        } catch (logErr) {
          rlog(
            "Log append error: " +
              (logErr && logErr.message ? logErr.message : logErr)
          );
        }
      };

      const formatStatusLogEntry = (entry) => {
        if (!entry) return "";
        if (typeof entry === "string") return entry;
        const msg = entry.message || "";
        if (entry.ts) {
          return `[${entry.ts}] ${msg}`;
        }
        return msg;
      };

      const renderStatusLogs = () => {
        if (!statusLogEl) return;
        statusLogEl.textContent = statusLogs.join("\n");
        statusLogEl.scrollTop = statusLogEl.scrollHeight;
      };

      const setStatusState = (state) => {
        if (!statusPanelEl || !statusTextEl) return;
        const normalized = typeof state === "string" && state ? state : "unknown";
        statusPanelEl.dataset.state = normalized.toLowerCase();
        statusTextEl.textContent = normalized;
      };

      const setStatusLogs = (entries) => {
        statusLogs = [];
        if (Array.isArray(entries)) {
          for (const entry of entries) {
            const line = formatStatusLogEntry(entry);
            if (line) statusLogs.push(line);
          }
        }
        if (statusLogs.length > STATUS_LOG_LIMIT) {
          statusLogs = statusLogs.slice(-STATUS_LOG_LIMIT);
        }
        renderStatusLogs();
      };

      const appendStatusLogEntry = (entry) => {
        const line = formatStatusLogEntry(entry);
        if (!line) return;
        statusLogs.push(line);
        if (statusLogs.length > STATUS_LOG_LIMIT) {
          statusLogs = statusLogs.slice(-STATUS_LOG_LIMIT);
        }
        renderStatusLogs();
      };

      const setConnectionState = (state, label) => {
        if (!statusConnectionEl) return;
        const value = state || "closed";
        statusConnectionEl.dataset.state = value;
        statusConnectionEl.textContent = label || value;
      };

      const closeStatusSource = () => {
        if (statusSource) {
          statusSource.close();
          statusSource = null;
        }
        currentWatchTaskId = null;
        setConnectionState("closed", "disconnected");
      };

      const openTaskWatch = (taskId) => {
        if (!taskId) return;
        if (taskId === currentWatchTaskId && statusSource) return;
        closeStatusSource();
        currentWatchTaskId = taskId;
        setStatusLogs([]);
        setStatusState("pending");
        setConnectionState("connecting", "connecting...");
        try {
          const watchUrl = buildRelayUrl(`/tasks/${taskId}/watch`, {
            includeApiKey: !!RELAY_API_KEY,
          });
          const source = new EventSource(watchUrl);
          statusSource = source;
          source.onopen = () => {
            setConnectionState("connected", "connected");
          };
          source.addEventListener("status", (event) => {
            try {
              const data = JSON.parse(event.data);
              setStatusState(data && data.status ? data.status : "pending");
              setStatusLogs(data && data.logs ? data.logs : []);
            } catch (err) {
              rlog(
                "Failed to parse status event: " +
                  (err && err.message ? err.message : err)
              );
            }
          });
          source.addEventListener("log", (event) => {
            try {
              const data = JSON.parse(event.data);
              appendStatusLogEntry(data);
            } catch (err) {
              rlog(
                "Failed to parse log event: " +
                  (err && err.message ? err.message : err)
              );
            }
          });
          source.addEventListener("result", (event) => {
            try {
              const data = JSON.parse(event.data);
              setStatusState(data && data.status ? data.status : "done");
              updateArtifactLinks();
              setTimeout(() => {
                if (statusSource === source) {
                  closeStatusSource();
                }
              }, 3000);
            } catch (err) {
              rlog(
                "Failed to parse result event: " +
                  (err && err.message ? err.message : err)
              );
            }
          });
          source.onerror = () => {
            if (source.readyState === EventSource.CLOSED) {
              setConnectionState("closed", "disconnected");
            } else {
              setConnectionState("error", "error (retrying)");
            }
            rlog(`SSE connection error for task ${taskId}`);
          };
        } catch (err) {
          setConnectionState("error", "error");
          rlog(
            "Failed to open SSE subscription: " +
              (err && err.message ? err.message : err)
          );
        }
      };

      window.addEventListener("beforeunload", () => {
        closeStatusSource();
      });

      setStatusLogs([]);
      setStatusState("idle");
      setConnectionState("closed", "disconnected");
      updateArtifactLinks();
      const sample = {
        meta: { specVersion: "0.1", id: "landing-v1" },
        target: {
          fileId: "REPLACE_WITH_FILE_ID",
          pageName: "Landing",
          frameName: "Home",
          frameSize: { w: 1440, h: 1024 },
        },
        grid: { container: 1200, columns: 12, gap: 24, margins: 24 },
        tokens: {
          fontFamily: "Inter",
          colors: { primary: "#6C5CE7", text: "#111827" },
        },
        sections: [
          {
            type: "hero",
            name: "Hero",
            padding: [64, 24],
            spacing: 24,
            layout: "stack",
            content: {
              title: "Заголовок",
              subtitle: "Подзаголовок",
              cta: "Купить",
            },
          },
          {
            type: "features",
            name: "Преимущества",
            layout: "grid-3",
            spacing: 32,
            content: {
              items: [
                { title: "Быстро" },
                { title: "Дёшево" },
                { title: "Точно" },
              ],
            },
          },
          {
            type: "cta",
            name: "Призыв",
            padding: [48, 24],
            content: { text: "Начать сейчас", button: "Попробовать" },
          },
          { type: "footer", name: "Подвал", padding: [48, 24] },
        ],
        acceptance: { maxSpacingDeviation: 2, checkAutoLayout: true },
      };
      document.getElementById("spec").value = JSON.stringify(sample, null, 2);

      const post = (type) => {
        const val = document.getElementById("spec").value;
        parent.postMessage({ pluginMessage: { type, taskSpec: val } }, "*");
      };

      document.getElementById("btn-validate").onclick = async () => {
        const textarea = document.getElementById("spec");
        const raw = textarea.value;
        let parsed;
        let parseError = false;
        try {
          parsed = JSON.parse(raw);
        } catch (_) {
          parseError = true;
        }
        let shouldPost = true;
        if (!parseError) {
          try {
            const res = await relayFetch(buildRelayUrl(`/validate/taskSpec`), {
              method: "POST",
              headers: { "Content-Type": "application/json" },
              body: JSON.stringify({ taskSpec: parsed }),
            });
            if (res.ok) {
              const data = await res.json();
              if (!data.valid) {
                shouldPost = false;
                log("TaskSpec schema validation failed:");
                const errors = Array.isArray(data.errors) ? data.errors : [];
                if (errors.length === 0) {
                  log(" - No details provided");
                } else {
                  for (const err of errors) {
                    const path = err.instancePath || "/";
                    log(` - ${path}: ${err.message}`);
                  }
                }
              }
            } else {
              rlog(`TaskSpec validation request failed: HTTP ${res.status}`);
            }
          } catch (err) {
            rlog(
              "TaskSpec validation request error: " +
                (err && err.message ? err.message : err)
            );
          }
        }
        if (shouldPost) post("validate");
      };
      document.getElementById("btn-build").onclick = () => post("build");
      document.getElementById("btn-export").onclick = () => post("export");
      document.getElementById("btn-fetch").onclick = async () => {
        try {
          if (pullModeEnabled) {
            const url = new URL(buildRelayUrl(`/tasks/pull`));
            if (PULL_PLUGIN_ID) {
              url.searchParams.set("pluginId", PULL_PLUGIN_ID);
            }
            const res = await relayFetch(url.toString());
            if (!res.ok) {
              return rlog(`Pull failed: ${res.status}`);
            }
            const data = await res.json();
            await assignFetchedTask(
              data && data.taskId ? data.taskId : null,
              data ? data.taskSpec : null,
              "Pull",
              "Plugin: pulled task into textarea"
            );
          } else {
            const res = await relayFetch(
              buildRelayUrl(`/tasks/latest?status=pending`),
            );
            if (!res.ok) {
              return rlog(`Fetch failed: ${res.status}`);
            }
            const data = await res.json();
            await assignFetchedTask(
              data && data.id ? data.id : null,
              data ? data.taskSpec : null,
              "Fetched",
              "Plugin: fetched task into textarea"
            );
          }
        } catch (e) {
          rlog("Fetch error: " + (e && e.message ? e.message : e));
        }
      };
      document.getElementById("btn-close").onclick = () => {
        closeStatusSource();
        lastTaskId = null;
        updateArtifactLinks();
        post("close");
      };

      onmessage = async (e) => {
        const msg = e.data && e.data.pluginMessage;
        if (!msg) return;
        if (msg.type === "validate:ok") {
          log("Validate OK");
          return;
        }
        if (msg.type === "validate:error") {
          log("ERROR: " + msg.error);
          return;
        }
        if (msg.type === "build:ok") {
          log("Build OK: sections=" + msg.sections);
          return;
        }
        if (msg.type === "export:ok") {
          const exportSpec = msg.exportSpec;
          let proceed = true;
          if (exportSpec) {
            try {
              const res = await relayFetch(buildRelayUrl(`/validate/exportSpec`), {
                method: "POST",
                headers: { "Content-Type": "application/json" },
                body: JSON.stringify({ exportSpec }),
              });
              if (res.ok) {
                const data = await res.json();
                if (!data.valid) {
                  proceed = false;
                  log("ExportSpec schema validation failed:");
                  const errors = Array.isArray(data.errors) ? data.errors : [];
                  if (errors.length === 0) {
                    log(" - No details provided");
                  } else {
                    for (const err of errors) {
                      const path = err.instancePath || "/";
                      log(` - ${path}: ${err.message}`);
                    }
                  }
                }
              } else {
                rlog(`ExportSpec validation request failed: HTTP ${res.status}`);
              }
            } catch (err) {
              rlog(
                "ExportSpec validation request error: " +
                  (err && err.message ? err.message : err)
              );
            }
          }
          if (!proceed) return;
          log(exportSpec);
          const blob = new Blob([JSON.stringify(exportSpec, null, 2)], {
            type: "application/json",
          });
          const url = URL.createObjectURL(blob);
          const a = document.getElementById("download");
          a.href = url;
          a.download = msg.filename || "ExportSpec.json";
          a.style.display = "inline-block";
          if (lastTaskId) {
            try {
              await relayFetch(buildRelayUrl(`/tasks/${lastTaskId}/result`), {
                method: "POST",
                headers: { "Content-Type": "application/json" },
                body: JSON.stringify({ result: exportSpec }),
              });
              rlog(`Result posted for task ${lastTaskId}`);
              updateArtifactLinks();
              try {
                await relayFetch(buildRelayUrl(`/tasks/${lastTaskId}/log`), {
                  method: "POST",
                  headers: { "Content-Type": "application/json" },
                  body: JSON.stringify({
                    message: "Plugin: result posted (export:ok)",
                  }),
                });
              } catch (logErr) {
                rlog(
                  "Log append error: " +
                    (logErr && logErr.message ? logErr.message : logErr)
                );
              }
            } catch (err) {
              rlog(
                "Post result error: " +
                  (err && err.message ? err.message : err)
              );
            }
          }
          return;
        }
        if (msg.type === "error") {
          log("ERROR: " + msg.error);
          return;
        }
        log(msg);
      };
    </script>
  </body>
</html>
