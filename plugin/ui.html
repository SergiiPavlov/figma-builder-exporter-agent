<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Builder+Exporter (M1)</title>
    <script>
      (() => {
// --- early vars to avoid TDZ (ReferenceError before initialization) ---
let specTextareaEl = null;
let validateButton = null;
let buildButton = null;
let importButton = null;
let exportButton = null;
let inferButton = null;
let proposeButton = null;
let artifactLinkEl = null;
let artifactZipLinkEl = null;
// --- end early vars ---

        function lsOk() {
          try {
            const k = "__ls_check_" + Math.random();
            window.localStorage.setItem(k, "1");
            window.localStorage.removeItem(k);
            return true;
          } catch (e) {
            return false;
          }
        }
        const mem = new Map();
        window.__storage = {
          getItem(k) {
            return lsOk() ? window.localStorage.getItem(k) : mem.get(k) ?? null;
          },
          setItem(k, v) {
            if (lsOk()) window.localStorage.setItem(k, v);
            else mem.set(k, v);
          },
          removeItem(k) {
            if (lsOk()) window.localStorage.removeItem(k);
            else mem.delete(k);
          },
          clear() {
            if (lsOk()) window.localStorage.clear();
            else mem.clear();
          },
        };
      })();
    </script>
    <style>
      body {
        font: 12px/1.4 -apple-system, BlinkMacSystemFont, Segoe UI, Roboto,
          Helvetica, Arial;
        margin: 12px;
      }
      .auth-settings {
        display: flex;
        flex-wrap: wrap;
        gap: 8px;
        align-items: flex-end;
        margin: 10px 0;
      }
      .auth-settings label {
        display: flex;
        flex-direction: column;
        gap: 4px;
        font-size: 11px;
        color: #1e293b;
      }
      .auth-settings input {
        padding: 4px 6px;
        font-size: 12px;
        min-width: 220px;
      }
      .auth-settings small {
        font-size: 10px;
        color: #64748b;
      }
      .tabs {
        display: inline-flex;
        gap: 6px;
        margin-bottom: 12px;
      }
      .tab-button {
        padding: 6px 12px;
        border: 1px solid #cbd5f5;
        border-radius: 4px;
        background: #f8fafc;
        color: #0f172a;
        cursor: pointer;
        font-size: 12px;
        font-weight: 600;
      }
      .tab-button.is-active {
        background: #2563eb;
        border-color: #1d4ed8;
        color: #fff;
      }
      .tab-panel {
        display: none;
      }
      .tab-panel.is-active {
        display: block;
      }
      textarea {
        width: 100%;
        height: 320px;
        font-family: ui-monospace, Consolas, Menlo, monospace;
      }
      .row {
        display: flex;
        gap: 8px;
        margin: 8px 0;
      }
      .row__note {
        font-size: 10px;
        color: #b45309;
        align-self: center;
      }
      .flow-panels {
        display: grid;
        gap: 8px;
        margin: 12px 0;
      }
      .flow-panel {
        border: 1px solid #cbd5f5;
        background: #f8fafc;
        border-radius: 6px;
        padding: 8px;
        display: flex;
        flex-direction: column;
        gap: 6px;
      }
      .flow-panel__header {
        display: flex;
        align-items: baseline;
        gap: 8px;
        font-size: 12px;
        font-weight: 600;
        color: #0f172a;
      }
      .flow-panel__status {
        margin-left: auto;
        font-weight: 600;
      }
      .flow-panel__message {
        font-size: 11px;
        color: #475569;
      }
      .flow-panel__hint {
        font-size: 10px;
        color: #64748b;
      }
      .flow-panel__errors {
        margin: 0;
        padding-left: 16px;
        font-size: 11px;
        color: #b91c1c;
      }
      .flow-panel__errors[data-visible='false'] {
        display: none;
      }
      .flow-panel__warnings {
        font-size: 11px;
        color: #b45309;
      }
      .flow-panel__warnings[data-visible='false'] {
        display: none;
      }
      .flow-panel__warnings ul {
        margin: 0;
        padding-left: 16px;
      }
      .flow-panel__summary {
        display: flex;
        flex-wrap: wrap;
        gap: 12px;
        font-size: 11px;
        color: #0f172a;
      }
      .flow-panel__summary span {
        display: inline-flex;
        gap: 4px;
        align-items: baseline;
      }
      .flow-panel__logs {
        font-size: 11px;
        background: #e2e8f0;
        color: #0f172a;
        border-radius: 4px;
        padding: 6px;
        margin: 0;
        max-height: 140px;
        overflow: auto;
      }
      .flow-panel__actions {
        display: flex;
        gap: 8px;
        flex-wrap: wrap;
        margin-top: 6px;
      }
      .flow-panel__logs[data-visible='false'] {
        display: none;
      }
      .flow-panel__sections {
        display: flex;
        flex-direction: column;
        gap: 6px;
        margin-top: 6px;
        font-size: 11px;
        color: #0f172a;
      }
      .flow-panel__sections[data-visible='false'] {
        display: none;
      }
      .flow-panel__section-item {
        background: #e2e8f0;
        border-radius: 4px;
        padding: 6px;
        display: flex;
        flex-direction: column;
        gap: 4px;
      }
      .flow-panel__section-header {
        display: flex;
        flex-wrap: wrap;
        gap: 8px;
        font-weight: 600;
      }
      .flow-panel__section-header span {
        display: inline-flex;
        gap: 4px;
        align-items: baseline;
      }
      .flow-panel__section-warning {
        color: #b45309;
        font-size: 10px;
      }
      .flow-panel__section-warning ul {
        margin: 4px 0 0;
        padding-left: 16px;
      }
      .flow-panel[data-state='valid'] .flow-panel__status,
      .flow-panel[data-state='done'] .flow-panel__status {
        color: #15803d;
      }
      .flow-panel[data-state='invalid'] .flow-panel__status,
      .flow-panel[data-state='error'] .flow-panel__status {
        color: #b91c1c;
      }
      .flow-panel[data-state='running'] .flow-panel__status {
        color: #2563eb;
      }
      button {
        padding: 6px 10px;
        cursor: pointer;
      }
      button[aria-disabled='true'],
      button:disabled {
        opacity: 0.6;
        cursor: not-allowed;
        pointer-events: none;
      }
      .toast-container {
        position: fixed;
        top: 16px;
        right: 16px;
        display: flex;
        flex-direction: column;
        gap: 8px;
        z-index: 9999;
        pointer-events: none;
      }
      .toast {
        min-width: 220px;
        max-width: 320px;
        padding: 10px 12px;
        border-radius: 6px;
        font-size: 12px;
        box-shadow: 0 8px 20px rgba(15, 23, 42, 0.15);
        color: #0f172a;
        background: rgba(255, 255, 255, 0.95);
        border-left: 4px solid transparent;
        pointer-events: auto;
        animation: toast-in 0.18s ease;
      }
      .toast--success {
        border-color: #22c55e;
      }
      .toast--error {
        border-color: #ef4444;
      }
      @keyframes toast-in {
        from {
          opacity: 0;
          transform: translateY(-6px);
        }
        to {
          opacity: 1;
          transform: translateY(0);
        }
      }
      .mode-toggle {
        display: inline-flex;
        align-items: center;
        gap: 6px;
        font-size: 12px;
        margin: 6px 0;
      }
      .runner-settings {
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(180px, 1fr));
        gap: 8px;
        align-items: end;
        margin: 12px 0;
      }
      .runner-settings label {
        display: flex;
        flex-direction: column;
        gap: 4px;
        font-size: 11px;
        color: #1e293b;
      }
      .runner-settings input[type='text'] {
        padding: 4px 6px;
        font-size: 12px;
      }
      .runner-settings__checkbox {
        display: inline-flex;
        align-items: center;
        gap: 6px;
        font-size: 12px;
      }
      .runner-settings__hint {
        grid-column: 1 / -1;
        font-size: 10px;
        color: #64748b;
      }
      .runner-panel {
        border: 1px solid #cbd5f5;
        background: #f8fafc;
        border-radius: 6px;
        padding: 8px;
        margin-bottom: 8px;
      }
      .runner-panel__header {
        display: flex;
        align-items: center;
        gap: 8px;
        font-size: 12px;
        margin-bottom: 6px;
      }
      .runner-panel__status {
        font-weight: 600;
      }
      .runner-panel__meta {
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(140px, 1fr));
        gap: 6px;
        font-size: 11px;
        color: #475569;
        margin-bottom: 6px;
      }
      .runner-panel__meta[data-visible='false'] {
        display: none;
      }
      .runner-panel__meta div {
        display: flex;
        gap: 4px;
        align-items: baseline;
      }
      .runner-panel__meta-label {
        color: #1e293b;
        font-weight: 600;
      }
      #runner-panel[data-state='idle'] .runner-panel__status {
        color: #475569;
      }
      #runner-panel[data-state='pending'] .runner-panel__status,
      #runner-panel[data-state='polling'] .runner-panel__status {
        color: #c2410c;
      }
      #runner-panel[data-state='running'] .runner-panel__status {
        color: #2563eb;
      }
      #runner-panel[data-state='success'] .runner-panel__status {
        color: #15803d;
      }
      #runner-panel[data-state='error'] .runner-panel__status {
        color: #dc2626;
      }
      .runner-panel__task {
        font-family: ui-monospace, Consolas, Menlo, monospace;
        font-size: 11px;
        color: #0f172a;
      }
      .runner-panel__progress {
        margin-left: auto;
        font-size: 11px;
        color: #475569;
      }
      .runner-panel__log {
        background: #0f172a;
        color: #e2e8f0;
        padding: 8px;
        max-height: 160px;
        overflow: auto;
        font-family: ui-monospace, Consolas, Menlo, monospace;
        font-size: 11px;
      }
      .runner-panel__hint {
        margin-top: 4px;
        font-size: 11px;
        color: #b91c1c;
        display: none;
      }
      .runner-panel__hint[data-visible='true'] {
        display: block;
      }
      .runner-panel__report {
        display: none;
        font-size: 11px;
        color: #1e293b;
        margin-bottom: 6px;
      }
      .runner-panel__report[data-visible='true'] {
        display: block;
      }
      .runner-panel__summary {
        display: flex;
        flex-wrap: wrap;
        gap: 12px;
        margin-bottom: 4px;
      }
      .runner-panel__summary span {
        display: inline-flex;
        align-items: baseline;
        gap: 4px;
      }
      .runner-panel__warnings {
        font-size: 11px;
        color: #b45309;
      }
      .runner-panel__warnings[data-visible='false'] {
        display: none;
      }
      .runner-panel__warnings ul {
        margin: 0;
        padding-left: 16px;
      }
      .runner-panel__share {
        display: none;
        align-items: center;
        gap: 6px;
        flex-wrap: wrap;
        margin-bottom: 6px;
        font-size: 11px;
        color: #1e293b;
      }
      .runner-panel__share[data-visible='true'] {
        display: inline-flex;
      }
      .runner-panel__share code {
        background: #e2e8f0;
        border-radius: 4px;
        padding: 2px 4px;
        font-family: ui-monospace, Consolas, Menlo, monospace;
        font-size: 11px;
      }
      .runner-panel .button-link[aria-disabled='true'] {
        opacity: 0.6;
        pointer-events: none;
      }
      .artifacts-empty {
        border: 1px dashed #cbd5f5;
        border-radius: 8px;
        background: #f8fafc;
        padding: 28px 16px;
        text-align: center;
        display: none;
        flex-direction: column;
        gap: 12px;
        align-items: center;
      }
      .artifacts-empty[data-visible='true'] {
        display: flex;
      }
      .artifacts-empty__icon {
        font-size: 32px;
      }
      .artifacts-empty__text {
        font-size: 13px;
        color: #475569;
      }
      .artifacts-refresh {
        display: inline-flex;
        align-items: center;
        gap: 6px;
      }
      .artifacts-refresh[data-loading='true']::after {
        content: '';
        width: 12px;
        height: 12px;
        border-radius: 999px;
        border: 2px solid rgba(37, 99, 235, 0.4);
        border-top-color: #2563eb;
        animation: spin 0.8s linear infinite;
      }
      @keyframes spin {
        to {
          transform: rotate(360deg);
        }
      }
      a.button-link {
        display: inline-block;
        padding: 6px 10px;
        border-radius: 4px;
        text-decoration: none;
        font-weight: 500;
      }
      #log {
        background: #0f172a;
        color: #e2e8f0;
        padding: 8px;
        height: 180px;
        overflow: auto;
      }
      #artifact-download {
        margin-top: 8px;
        background: #2563eb;
        color: #fff;
        border: 1px solid #1d4ed8;
      }
      #artifact-download[aria-disabled='true'] {
        opacity: 0.6;
        cursor: not-allowed;
        pointer-events: none;
      }
      #artifact-zip-download {
        margin-top: 8px;
        margin-left: 8px;
        background: #0f172a;
        color: #e2e8f0;
        border: 1px solid #0f172a;
      }
      #artifact-zip-download[aria-disabled='true'] {
        opacity: 0.6;
        cursor: not-allowed;
        pointer-events: none;
      }
      #status-panel {
        margin-top: 12px;
        border: 1px solid #cbd5f5;
        background: #f8fafc;
        border-radius: 6px;
        padding: 8px;
      }
      #status-panel .status-header {
        display: flex;
        align-items: center;
        gap: 8px;
        font-size: 12px;
        margin-bottom: 6px;
      }
      #status-text {
        font-weight: 600;
      }
      #status-connection {
        margin-left: auto;
        font-size: 10px;
        text-transform: uppercase;
        padding: 2px 6px;
        border-radius: 999px;
        background: #e2e8f0;
        color: #334155;
      }
      #status-connection[data-state='connecting'] {
        background: #fef3c7;
        color: #92400e;
      }
      #status-connection[data-state='connected'] {
        background: #bbf7d0;
        color: #166534;
      }
      #status-connection[data-state='error'] {
        background: #fecaca;
        color: #b91c1c;
      }
      #status-panel[data-state='pending'] #status-text {
        color: #c2410c;
      }
      #status-panel[data-state='running'] #status-text {
        color: #2563eb;
      }
      #status-panel[data-state='done'] #status-text {
        color: #15803d;
      }
      #status-panel[data-state='error'] #status-text {
        color: #dc2626;
      }
      #status-log {
        background: #0f172a;
        color: #e2e8f0;
        padding: 8px;
        max-height: 180px;
        overflow: auto;
        margin: 0;
        white-space: pre-wrap;
        word-break: break-word;
      }
      #panel-artifacts {
        border: 1px solid #cbd5f5;
        border-radius: 6px;
        padding: 12px;
        background: #f8fafc;
      }
      #panel-artifacts[data-loading='true'] {
        opacity: 0.75;
      }
      .artifacts-controls {
        display: flex;
        flex-wrap: wrap;
        gap: 10px;
        align-items: flex-end;
        margin-bottom: 12px;
      }
      .artifacts-controls label {
        display: flex;
        flex-direction: column;
        gap: 4px;
        font-size: 11px;
        color: #1e293b;
      }
      .artifacts-controls input,
      .artifacts-controls select {
        padding: 4px 6px;
        font-size: 12px;
      }
      .artifacts-controls button {
        margin-left: 0;
      }
      .artifacts-error {
        display: none;
        color: #b91c1c;
        background: #fee2e2;
        border: 1px solid #fecaca;
        border-radius: 4px;
        padding: 6px 8px;
        margin-bottom: 12px;
      }
      .artifacts-table {
        width: 100%;
        border-collapse: collapse;
        font-size: 12px;
      }
      .artifacts-table[data-state='loading'] {
        opacity: 0.65;
      }
      .artifacts-table th,
      .artifacts-table td {
        border: 1px solid #e2e8f0;
        padding: 6px 8px;
        text-align: left;
        vertical-align: middle;
      }
      .artifacts-table tbody tr:nth-child(even) {
        background: #f1f5f9;
      }
      .artifacts-table tbody tr[data-clickable='true'] {
        cursor: pointer;
      }
      .artifacts-table tbody tr[data-selected='true'] {
        background: #dbeafe;
      }
      .artifacts-table .actions {
        white-space: nowrap;
      }
      .artifacts-table .preview-col {
        width: 96px;
      }
      .artifacts-table .muted {
        text-align: center;
        color: #64748b;
        font-style: italic;
      }
      .artifacts-table__skeleton {
        display: block;
        width: 100%;
        height: 10px;
        border-radius: 4px;
        background: linear-gradient(
          90deg,
          rgba(148, 163, 184, 0.2) 0%,
          rgba(148, 163, 184, 0.45) 50%,
          rgba(148, 163, 184, 0.2) 100%
        );
        background-size: 200% 100%;
        animation: skeleton 1.2s ease-in-out infinite;
      }
      @keyframes skeleton {
        0% {
          background-position: 200% 0;
        }
        100% {
          background-position: -200% 0;
        }
      }
      .artifact-preview-thumb {
        display: block;
        max-width: 100%;
        max-height: 80px;
        border: 1px solid #cbd5f5;
        border-radius: 4px;
        background: #fff;
      }
      .artifact-details__preview {
        margin: 16px 0;
      }
      .artifact-details__preview[data-visible='false'] {
        display: none;
      }
      .artifact-details__preview-body {
        max-height: 320px;
        overflow: auto;
      }
      .artifact-details__preview-image {
        width: 100%;
        height: auto;
        border: 1px solid #cbd5f5;
        border-radius: 6px;
        background: #fff;
        display: block;
      }
      .artifact-details__preview-download {
        margin-top: 8px;
        display: inline-block;
      }
      .artifact-details__preview-download[aria-disabled='true'] {
        opacity: 0.6;
        pointer-events: none;
      }
      .artifacts-pagination {
        display: flex;
        align-items: center;
        flex-wrap: wrap;
        gap: 10px;
        margin-top: 12px;
        font-size: 12px;
      }
      .artifacts-pagination button {
        margin-left: 0;
      }
      .artifacts-pagination-actions {
        display: inline-flex;
        gap: 8px;
        margin-left: auto;
      }
      #artifacts-compare,
      #artifacts-bulk-download {
        padding: 6px 10px;
        font-weight: 600;
      }
      #artifacts-compare[disabled],
      #artifacts-bulk-download[disabled] {
        opacity: 0.6;
        cursor: not-allowed;
      }
      .artifact-details {
        position: fixed;
        inset: 0;
        display: flex;
        justify-content: flex-end;
        pointer-events: none;
        z-index: 50;
      }
      .artifact-details[data-open='true'] {
        pointer-events: auto;
      }
      .artifact-details__overlay {
        flex: 1;
        background: rgba(15, 23, 42, 0.45);
        backdrop-filter: blur(2px);
        opacity: 0;
        transition: opacity 0.2s ease;
      }
      .artifact-details[data-open='true'] .artifact-details__overlay {
        opacity: 1;
      }
      .artifact-details__panel {
        width: min(420px, 100%);
        max-width: 100%;
        background: #ffffff;
        border-left: 1px solid #cbd5f5;
        box-shadow: -4px 0 16px rgba(15, 23, 42, 0.12);
        padding: 16px;
        overflow-y: auto;
        transform: translateX(100%);
        transition: transform 0.2s ease;
        display: flex;
        flex-direction: column;
        gap: 12px;
      }
      .artifact-details[data-open='true'] .artifact-details__panel {
        transform: translateX(0);
      }
      .artifact-details__header {
        display: flex;
        align-items: center;
        gap: 8px;
      }
      .artifact-details__title {
        margin: 0;
        font-size: 14px;
        font-weight: 600;
        color: #0f172a;
      }
      .artifact-details__close {
        margin-left: auto;
        border: none;
        background: transparent;
        color: #0f172a;
        font-size: 18px;
        line-height: 1;
        padding: 2px 6px;
        cursor: pointer;
      }
      .artifact-details__meta {
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(140px, 1fr));
        gap: 10px;
        font-size: 12px;
      }
      .artifact-details__meta-item {
        display: flex;
        flex-direction: column;
        gap: 2px;
      }
      .artifact-details__meta-label {
        font-size: 11px;
        text-transform: uppercase;
        color: #64748b;
        letter-spacing: 0.02em;
      }
      .artifact-details__meta-value {
        color: #0f172a;
        word-break: break-all;
      }
      .artifact-details__actions {
        display: flex;
        flex-wrap: wrap;
        gap: 8px;
      }
      .artifact-details__actions a,
      .artifact-details__actions button {
        font-size: 12px;
      }
      .artifact-details__share {
        display: flex;
        flex-direction: column;
        gap: 6px;
        padding: 8px;
        border: 1px solid #e2e8f0;
        border-radius: 6px;
        background: #f8fafc;
      }
      .artifact-details__share-actions {
        display: flex;
        flex-wrap: wrap;
        gap: 6px;
      }
      .artifact-details__share-actions button {
        font-size: 12px;
      }
      .artifact-details__share-feedback {
        display: none;
        flex-direction: column;
        gap: 4px;
        font-size: 11px;
        color: #0f172a;
        word-break: break-word;
      }
      .artifact-details__share-feedback[data-visible='true'] {
        display: flex;
      }
      .artifact-details__share-link {
        display: flex;
        align-items: center;
        gap: 6px;
        flex-wrap: wrap;
      }
      .artifact-details__share-url {
        max-width: 100%;
        overflow-wrap: anywhere;
        font-weight: 600;
        color: #1d4ed8;
      }
      .artifact-details__share-feedback button {
        font-size: 11px;
      }
      .artifact-details__share-ttl {
        color: #475569;
      }
      .artifact-details__share-error {
        display: none;
        font-size: 11px;
        color: #b91c1c;
      }
      .artifact-details__share-error[data-visible='true'] {
        display: block;
      }
      .artifact-details__notice {
        font-size: 12px;
        background: #e0f2fe;
        border: 1px solid #bae6fd;
        color: #0c4a6e;
        border-radius: 4px;
        padding: 8px;
        display: none;
        gap: 8px;
      }
      .artifact-details__notice[data-visible='true'] {
        display: flex;
        flex-direction: column;
      }
      .artifact-details__notice-actions {
        display: flex;
        flex-wrap: wrap;
        gap: 6px;
        margin-top: 6px;
      }
      .artifact-details__toast {
        font-size: 11px;
        color: #0f172a;
        background: rgba(226, 232, 240, 0.8);
        border-radius: 4px;
        padding: 4px 6px;
        align-self: flex-start;
        display: none;
      }
      .artifact-details__toast[data-visible='true'] {
        display: inline-block;
      }
      .artifact-details__section-title {
        margin: 0 0 4px;
        font-size: 13px;
        font-weight: 600;
        color: #0f172a;
      }
      .artifact-details__logs-header {
        display: flex;
        align-items: center;
        gap: 8px;
      }
      .artifact-details__pause-button[aria-pressed='true'] {
        background: #0f172a;
        color: #e2e8f0;
      }
      .artifact-details__logs {
        max-height: 160px;
        overflow-y: auto;
        border: 1px solid #e2e8f0;
        background: #0f172a;
        color: #e2e8f0;
        padding: 8px;
        font-family: ui-monospace, Consolas, Menlo, monospace;
        font-size: 11px;
        white-space: pre-wrap;
      }
      .artifact-details__logs[data-empty='true'] {
        color: #cbd5f5;
        font-style: italic;
      }
      .artifact-details__export-header {
        display: flex;
        align-items: center;
        gap: 8px;
        flex-wrap: wrap;
      }
      .artifact-details__export-controls {
        display: flex;
        align-items: center;
        gap: 6px;
        margin-left: auto;
      }
      .artifact-details__export-controls input[type='search'] {
        padding: 4px 6px;
        font-size: 12px;
        width: 160px;
      }
      .artifact-details__export-viewer {
        border: 1px solid #e2e8f0;
        background: #f8fafc;
        padding: 8px;
        max-height: 280px;
        overflow: auto;
        font-family: ui-monospace, Consolas, Menlo, monospace;
        font-size: 11px;
      }
      .artifact-details__export-viewer[data-empty='true'] {
        color: #64748b;
        font-style: italic;
      }
      .json-node {
        margin-left: 0;
      }
      .json-node > details > summary {
        cursor: pointer;
        list-style: none;
      }
      .json-node > details > summary::-webkit-details-marker {
        display: none;
      }
      .json-node > details > summary::before {
        content: '▸';
        display: inline-block;
        margin-right: 6px;
        transform: rotate(0deg);
        transition: transform 0.15s ease;
        color: #2563eb;
      }
      .json-node > details[open] > summary::before {
        transform: rotate(90deg);
      }
      .json-node > details > .json-children {
        margin-left: 14px;
      }
      .json-leaf {
        margin-left: 18px;
      }
      .json-key {
        color: #1d4ed8;
      }
      .json-value-string {
        color: #047857;
      }
      .json-value-number,
      .json-value-bigint {
        color: #b91c1c;
      }
      .json-value-boolean {
        color: #7c3aed;
      }
      .json-value-null,
      .json-value-undefined {
        color: #0f172a;
        font-style: italic;
      }
      .artifact-details__export-viewer mark {
        background: #fde68a;
        color: inherit;
        padding: 0;
      }
      .json-node[data-search-active='true'][data-has-match='false'] {
        opacity: 0.45;
      }
      .artifact-details__loading,
      .artifact-details__error {
        font-size: 12px;
      }
      .artifact-details__loading {
        color: #1d4ed8;
      }
      .artifact-details__error {
        color: #b91c1c;
      }
      .artifact-details__empty {
        color: #64748b;
        font-style: italic;
      }
      .artifact-details__content {
        display: flex;
        flex-direction: column;
        gap: 12px;
      }
      .artifact-details__body {
        display: flex;
        flex-direction: column;
        gap: 10px;
      }
      .artifact-compare {
        position: fixed;
        inset: 0;
        display: flex;
        justify-content: flex-end;
        pointer-events: none;
        z-index: 60;
      }
      .artifact-compare[data-open='true'] {
        pointer-events: auto;
      }
      .artifact-compare__overlay {
        flex: 1;
        background: rgba(15, 23, 42, 0.45);
        backdrop-filter: blur(2px);
        opacity: 0;
        transition: opacity 0.2s ease;
      }
      .artifact-compare[data-open='true'] .artifact-compare__overlay {
        opacity: 1;
      }
      .artifact-compare__panel {
        width: min(520px, 100%);
        max-width: 100%;
        background: #ffffff;
        border-left: 1px solid #cbd5f5;
        box-shadow: -4px 0 18px rgba(15, 23, 42, 0.16);
        padding: 18px;
        overflow-y: auto;
        transform: translateX(100%);
        transition: transform 0.2s ease;
        display: flex;
        flex-direction: column;
        gap: 14px;
      }
      .artifact-compare[data-open='true'] .artifact-compare__panel {
        transform: translateX(0);
      }
      .artifact-compare__header {
        display: flex;
        align-items: center;
        gap: 8px;
      }
      .artifact-compare__title {
        margin: 0;
        font-size: 14px;
        font-weight: 600;
        color: #0f172a;
      }
      .artifact-compare__close {
        margin-left: auto;
        border: none;
        background: transparent;
        color: #0f172a;
        font-size: 18px;
        line-height: 1;
        padding: 2px 6px;
        cursor: pointer;
      }
      .artifact-compare__pair {
        display: flex;
        align-items: center;
        gap: 6px;
        flex-wrap: wrap;
        font-size: 12px;
      }
      .artifact-compare__id {
        font-family: ui-monospace, Consolas, Menlo, monospace;
        background: #f1f5f9;
        border: 1px solid #cbd5f5;
        border-radius: 4px;
        padding: 4px 6px;
        color: #0f172a;
        max-width: 100%;
        overflow-wrap: anywhere;
      }
      .artifact-compare__vs {
        font-weight: 600;
        color: #475569;
      }
      .artifact-compare__swap {
        margin-left: auto;
        padding: 4px 8px;
        font-size: 11px;
        border-radius: 4px;
        border: 1px solid #cbd5f5;
        background: #f8fafc;
        cursor: pointer;
      }
      .artifact-compare__swap:disabled {
        opacity: 0.6;
        cursor: not-allowed;
      }
      .artifact-compare__loading,
      .artifact-compare__error {
        font-size: 12px;
      }
      .artifact-compare__loading {
        color: #1d4ed8;
      }
      .artifact-compare__error {
        color: #b91c1c;
        background: #fee2e2;
        border: 1px solid #fecaca;
        border-radius: 4px;
        padding: 8px;
      }
      .artifact-compare__content {
        display: flex;
        flex-direction: column;
        gap: 12px;
      }
      .artifact-compare__controls {
        display: flex;
        align-items: center;
        gap: 10px;
        flex-wrap: wrap;
      }
      .artifact-compare__actions {
        display: inline-flex;
        gap: 8px;
        margin-left: auto;
        flex-wrap: wrap;
      }
      .artifact-compare__hint {
        font-size: 11px;
        color: #64748b;
        margin-top: 4px;
      }
      .artifact-compare__tabs {
        display: inline-flex;
        gap: 6px;
      }
      .artifact-compare__tab {
        padding: 6px 12px;
        border: 1px solid #cbd5f5;
        border-radius: 4px;
        background: #f8fafc;
        color: #0f172a;
        font-size: 12px;
        font-weight: 600;
        cursor: pointer;
      }
      .artifact-compare__tab.is-active {
        background: #2563eb;
        border-color: #1d4ed8;
        color: #ffffff;
      }
      .artifact-compare__download {
        padding: 6px 12px;
        border-radius: 4px;
        border: 1px solid #0f172a;
        background: #0f172a;
        color: #e2e8f0;
        font-size: 12px;
        cursor: pointer;
      }
      .artifact-compare__download[aria-disabled='true'] {
        opacity: 0.6;
        cursor: not-allowed;
      }
      .artifact-compare__section {
        display: none;
      }
      .artifact-compare__section[data-active='true'] {
        display: block;
      }
      .artifact-compare__summary-grid {
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(120px, 1fr));
        gap: 10px;
      }
      .artifact-compare__summary-card {
        border: 1px solid #e2e8f0;
        border-radius: 6px;
        padding: 10px;
        background: #f8fafc;
        display: flex;
        flex-direction: column;
        gap: 4px;
      }
      .artifact-compare__summary-label {
        font-size: 11px;
        text-transform: uppercase;
        color: #475569;
        letter-spacing: 0.04em;
      }
      .artifact-compare__summary-value {
        font-size: 20px;
        font-weight: 700;
        color: #0f172a;
      }
      .artifact-compare__search {
        display: flex;
        align-items: center;
        gap: 8px;
        margin-bottom: 8px;
      }
      .artifact-compare__search input {
        width: 100%;
        padding: 6px 8px;
        font-size: 12px;
      }
      .artifact-compare__empty {
        font-size: 12px;
        color: #64748b;
        font-style: italic;
      }
      .artifact-compare__diff-list {
        list-style: none;
        padding: 0;
        margin: 0;
        display: flex;
        flex-direction: column;
        gap: 8px;
      }
      .artifact-compare__diff-item {
        border: 1px solid #e2e8f0;
        border-radius: 6px;
        padding: 8px;
        background: #ffffff;
        display: flex;
        flex-direction: column;
        gap: 6px;
      }
      .artifact-compare__diff-header {
        display: flex;
        align-items: center;
        gap: 8px;
        font-family: ui-monospace, Consolas, Menlo, monospace;
        font-size: 12px;
        color: #0f172a;
        overflow-wrap: anywhere;
      }
      .artifact-compare__badge {
        padding: 2px 6px;
        border-radius: 999px;
        font-size: 10px;
        font-weight: 600;
        text-transform: uppercase;
        letter-spacing: 0.04em;
      }
      .artifact-compare__badge--added {
        background: #dcfce7;
        color: #166534;
      }
      .artifact-compare__badge--removed {
        background: #fee2e2;
        color: #b91c1c;
      }
      .artifact-compare__badge--changed {
        background: #dbeafe;
        color: #1d4ed8;
      }
      .artifact-compare__badge--unchanged {
        background: #e2e8f0;
        color: #475569;
      }
      .artifact-compare__diff-body {
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(180px, 1fr));
        gap: 10px;
        font-size: 12px;
      }
      .artifact-compare__diff-column {
        display: flex;
        flex-direction: column;
        gap: 4px;
      }
      .artifact-compare__diff-column strong {
        font-size: 11px;
        text-transform: uppercase;
        color: #475569;
      }
      .artifact-compare__diff-value {
        font-family: ui-monospace, Consolas, Menlo, monospace;
        background: #f1f5f9;
        border: 1px solid #cbd5f5;
        border-radius: 4px;
        padding: 6px;
        min-height: 28px;
        overflow-wrap: anywhere;
      }
      .artifact-compare__visual {
        border-top: 1px solid #e2e8f0;
        padding-top: 12px;
        display: flex;
        flex-direction: column;
        gap: 12px;
      }
      .artifact-compare__visual[data-visible='false'] {
        display: none;
      }
      .artifact-compare__visual-header {
        display: flex;
        align-items: center;
        gap: 12px;
      }
      .artifact-compare__visual-title {
        margin: 0;
        font-size: 13px;
        font-weight: 600;
        color: #0f172a;
      }
      .artifact-compare__visual-toggle {
        display: inline-flex;
        gap: 6px;
        margin-left: auto;
      }
      .artifact-compare__visual-toggle-button {
        padding: 4px 10px;
        border: 1px solid #cbd5f5;
        border-radius: 4px;
        background: #f8fafc;
        color: #0f172a;
        font-size: 11px;
        font-weight: 600;
        cursor: pointer;
      }
      .artifact-compare__visual-toggle-button.is-active {
        background: #2563eb;
        border-color: #1d4ed8;
        color: #ffffff;
      }
      .artifact-compare__visual-body {
        display: flex;
        flex-direction: column;
        gap: 12px;
      }
      .artifact-compare__visual-side {
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(140px, 1fr));
        gap: 10px;
      }
      .artifact-compare__visual-side[data-active='false'] {
        display: none;
      }
      .artifact-compare__visual-figure {
        margin: 0;
        display: flex;
        flex-direction: column;
        gap: 6px;
      }
      .artifact-compare__visual-caption {
        font-size: 11px;
        font-weight: 600;
        color: #475569;
        text-transform: uppercase;
        letter-spacing: 0.04em;
      }
      .artifact-compare__visual-image {
        width: 100%;
        border: 1px solid #cbd5f5;
        border-radius: 6px;
        background: #ffffff;
        object-fit: contain;
      }
      .artifact-compare__visual-overlay {
        display: flex;
        flex-direction: column;
        gap: 10px;
      }
      .artifact-compare__visual-overlay[data-active='false'] {
        display: none;
      }
      .artifact-compare__overlay-stage {
        position: relative;
        width: 100%;
        border: 1px solid #cbd5f5;
        border-radius: 6px;
        overflow: hidden;
        background: #ffffff;
      }
      .artifact-compare__overlay-base,
      .artifact-compare__overlay-foreground img {
        display: block;
        width: 100%;
        height: auto;
        object-fit: contain;
      }
      .artifact-compare__overlay-foreground {
        position: absolute;
        top: 0;
        left: 0;
        height: 100%;
        overflow: hidden;
        border-right: 2px solid rgba(37, 99, 235, 0.75);
      }
      .artifact-compare__overlay-slider {
        width: 100%;
      }
    </style>
  </head>
  <body>
    <div
      id="toast-container"
      class="toast-container"
      role="status"
      aria-live="polite"
      aria-atomic="true"
    ></div>
    <h3>Figma Builder+Exporter (M1)</h3>
    <div class="tabs">
      <button type="button" class="tab-button is-active" data-target="panel-builder">
        Builder
      </button>
      <button type="button" class="tab-button" data-target="panel-artifacts">
        Artifacts
      </button>
    </div>
    <div id="panel-builder" class="tab-panel is-active">
      <p>
        Вставьте <b>TaskSpec (JSON)</b> ниже и нажмите <b>Validate</b>. Перед
        Build/Export замените <code>REPLACE_WITH_FILE_ID</code> на свой fileId.
      </p>
      <textarea id="spec"></textarea>
      <div class="auth-settings">
        <label>
          API key
          <input
            type="password"
            id="api-key-input"
            placeholder="Enter API key"
            autocomplete="off"
          />
        </label>
        <button type="button" id="api-key-clear">Clear</button>
        <small>Stored locally (Figma plugin settings)</small>
      </div>
      <div class="runner-settings">
        <label class="mode-toggle">
          <input type="checkbox" id="runner-toggle" />
          <span>Enable Runner</span>
        </label>
        <label>
          Relay Base URL
          <input
            type="text"
            id="runner-host"
            placeholder="http://localhost:3000"
            autocomplete="off"
          />
        </label>
        <label>
          Plugin ID
          <input
            type="text"
            id="runner-plugin-id"
            placeholder="e.g. local"
            autocomplete="off"
          />
        </label>
        <label>
          Pull interval (sec)
          <input
            type="number"
            id="runner-poll-interval"
            min="1"
            step="1"
            placeholder="5"
            autocomplete="off"
          />
        </label>
        <label class="runner-settings__checkbox">
          <input type="checkbox" id="runner-auto-share" />
          <span>Auto-share on success</span>
        </label>
        <small class="runner-settings__hint">
          Runner polls <code>/tasks/pull</code>, performs Build → Export, uploads results (ExportSpec, logs, preview) automatically. Settings persist in plugin storage.
        </small>
      </div>
      <div id="runner-panel" class="runner-panel" data-state="idle">
        <div class="runner-panel__header">
          <span>Runner:</span>
          <span id="runner-status-text" class="runner-panel__status">disabled</span>
          <span>Task</span>
          <span id="runner-task-id" class="runner-panel__task">—</span>
          <span id="runner-progress" class="runner-panel__progress"></span>
        </div>
        <div
          id="runner-status-hint"
          class="runner-panel__hint"
          data-visible="false"
          aria-live="polite"
        ></div>
        <div id="runner-meta" class="runner-panel__meta" data-visible="false">
          <div>
            <span class="runner-panel__meta-label">Started</span>
            <span id="runner-started-at">—</span>
          </div>
          <div>
            <span class="runner-panel__meta-label">Finished</span>
            <span id="runner-finished-at">—</span>
          </div>
          <div>
            <span class="runner-panel__meta-label">Duration</span>
            <span id="runner-duration">—</span>
          </div>
        </div>
        <div id="runner-report" class="runner-panel__report" data-visible="false">
          <div class="runner-panel__summary">
            <span>
              <span class="runner-panel__meta-label">Created</span>
              <span id="runner-summary-created">0</span>
            </span>
            <span>
              <span class="runner-panel__meta-label">Updated</span>
              <span id="runner-summary-updated">0</span>
            </span>
            <span>
              <span class="runner-panel__meta-label">Removed</span>
              <span id="runner-summary-removed">0</span>
            </span>
          </div>
          <div id="runner-warnings" class="runner-panel__warnings" data-visible="false"></div>
        </div>
        <div id="runner-share" class="runner-panel__share" data-visible="false">
          <span>Share token:</span>
          <code id="runner-share-token">—</code>
          <button type="button" id="runner-copy-share">Copy</button>
          <a
            id="runner-share-link"
            class="button-link"
            href="#"
            target="_blank"
            rel="noopener noreferrer"
            aria-disabled="true"
            >Open</a
          >
        </div>
        <pre id="runner-log" class="runner-panel__log"></pre>
      </div>
      <label class="mode-toggle">
        <input type="checkbox" id="pull-mode" />
        <span>Pull mode</span>
      </label>
      <div class="row">
        <button id="btn-validate">Validate</button>
        <button id="btn-build">Build</button>
        <button id="btn-import">Import</button>
        <button id="btn-propose" aria-disabled="true" disabled>Propose TaskSpec</button>
        <span class="row__note">черновик — проверьте руками</span>
        <button id="btn-infer">Generate TaskSpec</button>
        <button id="btn-export">Export</button>
        <button id="btn-fetch">Fetch</button>
        <a
          id="download"
          style="margin-left: auto; display: none"
          download="ExportSpec.json"
          >Download ExportSpec.json</a
        >
        <button id="btn-close">Close</button>
      </div>
      <div class="flow-panels">
        <section id="import-panel" class="flow-panel" data-state="idle">
          <div class="flow-panel__header">
            <span>Import</span>
            <span id="import-status" class="flow-panel__status">idle</span>
          </div>
          <div id="import-message" class="flow-panel__message"></div>
          <div id="import-hint" class="flow-panel__hint"></div>
          <div id="import-warnings" class="flow-panel__warnings" data-visible="false"></div>
          <div id="import-sections" class="flow-panel__sections" data-visible="false"></div>
          <pre
            id="import-preview"
            class="flow-panel__logs"
            data-visible="false"
            aria-live="polite"
          ></pre>
          <div id="import-actions" class="flow-panel__actions">
            <button id="btn-import-save" type="button" aria-disabled="true" disabled>
              Сохранить .json
            </button>
          </div>
        </section>
        <section id="validate-panel" class="flow-panel" data-state="idle">
          <div class="flow-panel__header">
            <span>Validate</span>
            <span id="validate-status" class="flow-panel__status">idle</span>
          </div>
          <div id="validate-message" class="flow-panel__message"></div>
          <div id="validate-hint" class="flow-panel__hint"></div>
          <ul id="validate-errors" class="flow-panel__errors" data-visible="false"></ul>
        </section>
        <section id="build-panel" class="flow-panel" data-state="idle">
          <div class="flow-panel__header">
            <span>Build</span>
            <span id="build-status" class="flow-panel__status">idle</span>
          </div>
          <div id="build-message" class="flow-panel__message"></div>
          <div id="build-summary" class="flow-panel__summary"></div>
          <div id="build-warnings" class="flow-panel__warnings" data-visible="false"></div>
          <pre
            id="build-logs"
            class="flow-panel__logs"
            data-visible="false"
            aria-live="polite"
          ></pre>
        </section>
        <section id="export-panel" class="flow-panel" data-state="idle">
          <div class="flow-panel__header">
            <span>Export</span>
            <span id="export-status" class="flow-panel__status">idle</span>
          </div>
          <div id="export-message" class="flow-panel__message"></div>
          <ul id="export-errors" class="flow-panel__errors" data-visible="false"></ul>
          <pre
            id="export-logs"
            class="flow-panel__logs"
            data-visible="false"
            aria-live="polite"
          ></pre>
        </section>
      </div>
      <pre
        id="relay-log"
        style="background: #f1f5f9; color: #0f172a; padding: 8px; max-height: 120px; overflow: auto"
      ></pre>
      <div id="status-panel" data-state="idle">
        <div class="status-header">
          <span>Status:</span>
          <span id="status-text">idle</span>
          <span id="status-connection" data-state="closed">disconnected</span>
        </div>
        <pre id="status-log"></pre>
      </div>
      <pre id="log"></pre>
      <a
        id="artifact-download"
        class="button-link"
        href="#"
        aria-disabled="true"
        rel="noopener noreferrer"
        >Download artifact</a
      >
      <a
        id="artifact-zip-download"
        class="button-link"
        href="#"
        aria-disabled="true"
        rel="noopener noreferrer"
        >Download ZIP</a
      >
    </div>
    <div id="panel-artifacts" class="tab-panel">
      <div id="artifacts-error" class="artifacts-error" role="alert"></div>
      <div class="artifacts-controls">
        <label>
          Search by ID
          <input type="text" id="artifacts-search" placeholder="Substring" />
        </label>
        <label>
          Order
          <select id="artifacts-order">
            <option value="desc" selected>desc</option>
            <option value="asc">asc</option>
          </select>
        </label>
        <label>
          Limit
          <input type="number" id="artifacts-limit" min="1" max="50" value="10" />
        </label>
        <button type="button" id="artifacts-prev">Prev</button>
        <button type="button" id="artifacts-next">Next</button>
        <button type="button" id="artifacts-refresh" class="artifacts-refresh">
          Refresh
        </button>
      </div>
      <div id="artifacts-empty-state" class="artifacts-empty" data-visible="false">
        <div class="artifacts-empty__icon" aria-hidden="true">🗂️</div>
        <div class="artifacts-empty__text">No artifacts yet</div>
        <button type="button" id="artifacts-empty-refresh" class="artifacts-refresh">
          Refresh
        </button>
      </div>
      <table id="artifacts-table" class="artifacts-table">
        <thead>
          <tr>
            <th>Select</th>
            <th>ID</th>
            <th>Preview</th>
            <th>Created</th>
            <th>Size</th>
            <th class="actions">JSON</th>
            <th class="actions">ZIP</th>
          </tr>
        </thead>
        <tbody id="artifacts-tbody">
          <tr>
            <td colspan="7" class="muted">No artifacts loaded</td>
          </tr>
        </tbody>
      </table>
      <div class="artifacts-pagination">
        <div id="artifacts-pagination-info">No artifacts</div>
        <div class="artifacts-pagination-actions">
          <button type="button" id="artifacts-compare" disabled>Compare selected</button>
          <button type="button" id="artifacts-bulk-download" disabled>
            Download selected as ZIP
          </button>
        </div>
      </div>
      <div
        id="artifact-details"
        class="artifact-details"
        data-open="false"
        aria-hidden="true"
      >
        <div class="artifact-details__overlay" id="artifact-details-overlay"></div>
        <aside
          class="artifact-details__panel"
          role="dialog"
          aria-modal="true"
          aria-labelledby="artifact-details-title"
        >
          <div class="artifact-details__header">
            <h4 class="artifact-details__title" id="artifact-details-title">
              Artifact details
            </h4>
            <button
              type="button"
              class="artifact-details__close"
              id="artifact-details-close"
              aria-label="Close details"
            >
              ×
            </button>
          </div>
          <div
            class="artifact-details__toast"
            id="artifact-details-toast"
            aria-live="polite"
          ></div>
          <div class="artifact-details__body">
            <div
              class="artifact-details__loading"
              id="artifact-details-loading"
              hidden
            >
              Loading details…
            </div>
            <div class="artifact-details__error" id="artifact-details-error" hidden></div>
            <div class="artifact-details__content" id="artifact-details-content" hidden>
              <div class="artifact-details__meta">
                <div class="artifact-details__meta-item">
                  <span class="artifact-details__meta-label">Task ID</span>
                  <span class="artifact-details__meta-value" id="artifact-details-task-id">—</span>
                </div>
                <div class="artifact-details__meta-item">
                  <span class="artifact-details__meta-label">Created</span>
                  <span class="artifact-details__meta-value" id="artifact-details-created">—</span>
                </div>
                <div class="artifact-details__meta-item">
                  <span class="artifact-details__meta-label">Status</span>
                  <span class="artifact-details__meta-value" id="artifact-details-status">—</span>
                </div>
              </div>
              <div class="artifact-details__actions">
                <a
                  id="artifact-details-json"
                  class="button-link"
                  href="#"
                  target="_blank"
                  rel="noopener noreferrer"
                  aria-disabled="true"
                  >Download JSON</a
                >
                <a
                  id="artifact-details-zip"
                  class="button-link"
                  href="#"
                  target="_blank"
                  rel="noopener noreferrer"
                  aria-disabled="true"
                  >Download ZIP</a
                >
                <button type="button" id="artifact-details-copy-id">
                  Copy Task ID
                </button>
                <button type="button" id="artifact-details-rerun">Re-run task</button>
              </div>
              <section
                class="artifact-details__preview"
                id="artifact-details-preview-section"
                data-visible="false"
              >
                <h5 class="artifact-details__section-title">Preview</h5>
                <div class="artifact-details__preview-body">
                  <img
                    id="artifact-details-preview-image"
                    class="artifact-details__preview-image"
                    alt="Artifact preview"
                  />
                </div>
                <a
                  id="artifact-details-preview-download"
                  class="button-link artifact-details__preview-download"
                  href="#"
                  target="_blank"
                  rel="noopener noreferrer"
                  aria-disabled="true"
                  >Download preview</a
                >
              </section>
              <div class="artifact-details__share">
                <div class="artifact-details__share-actions">
                  <button type="button" id="artifact-details-share-json">Share JSON</button>
                  <button type="button" id="artifact-details-share-zip">Share ZIP</button>
                  <button type="button" id="artifact-details-share-copy-link">
                    Copy link
                  </button>
                </div>
                <div
                  class="artifact-details__share-feedback"
                  id="artifact-details-share-feedback"
                  data-visible="false"
                >
                  <div
                    class="artifact-details__share-summary"
                    id="artifact-details-share-summary"
                  ></div>
                  <div class="artifact-details__share-link">
                    <a
                      id="artifact-details-share-url"
                      class="artifact-details__share-url"
                      href="#"
                      target="_blank"
                      rel="noopener noreferrer"
                    ></a>
                    <button type="button" id="artifact-details-share-copy">Copy link</button>
                  </div>
                  <div class="artifact-details__share-ttl" id="artifact-details-share-ttl"></div>
                </div>
                <div
                  class="artifact-details__share-error"
                  id="artifact-details-share-error"
                  data-visible="false"
                ></div>
              </div>
              <div
                class="artifact-details__notice"
                id="artifact-details-notice"
                data-visible="false"
                role="status"
                aria-live="polite"
              ></div>
              <section>
                <div class="artifact-details__logs-header">
                  <h5 class="artifact-details__section-title">Logs</h5>
                  <button
                    type="button"
                    id="artifact-details-toggle-logs"
                    class="artifact-details__pause-button"
                    aria-pressed="false"
                  >
                    Pause logs
                  </button>
                </div>
                <div
                  id="artifact-details-logs"
                  class="artifact-details__logs"
                  data-empty="true"
                >
                  No logs yet
                </div>
              </section>
              <section>
                <div class="artifact-details__export-header">
                  <h5 class="artifact-details__section-title">ExportSpec</h5>
                  <div class="artifact-details__export-controls">
                    <input
                      type="search"
                      id="artifact-details-export-search"
                      placeholder="Search JSON"
                      aria-label="Search ExportSpec"
                    />
                    <button type="button" id="artifact-details-copy-export">
                      Copy JSON
                    </button>
                  </div>
                </div>
                <div
                  id="artifact-details-export-viewer"
                  class="artifact-details__export-viewer"
                  data-empty="true"
                >
                  No ExportSpec available
                </div>
              </section>
            </div>
          </div>
        </aside>
      </div>
      <div
        id="artifact-compare"
        class="artifact-compare"
        data-open="false"
        aria-hidden="true"
      >
        <div class="artifact-compare__overlay" id="artifact-compare-overlay"></div>
        <aside
          class="artifact-compare__panel"
          role="dialog"
          aria-modal="true"
          aria-labelledby="artifact-compare-title"
        >
          <div class="artifact-compare__header">
            <h4 class="artifact-compare__title" id="artifact-compare-title">Compare artifacts</h4>
            <button
              type="button"
              class="artifact-compare__close"
              id="artifact-compare-close"
              aria-label="Close compare panel"
            >
              ×
            </button>
          </div>
          <div class="artifact-compare__loading" id="artifact-compare-loading" hidden>
            Comparing artifacts…
          </div>
          <div class="artifact-compare__error" id="artifact-compare-error" hidden></div>
          <div class="artifact-compare__content" id="artifact-compare-content" hidden>
            <div class="artifact-compare__pair">
              <span class="artifact-compare__id" id="artifact-compare-left-id">—</span>
              <span class="artifact-compare__vs">vs</span>
              <span class="artifact-compare__id" id="artifact-compare-right-id">—</span>
              <button type="button" class="artifact-compare__swap" id="artifact-compare-swap">
                Swap
              </button>
            </div>
            <div class="artifact-compare__controls">
              <div class="artifact-compare__tabs" role="tablist">
                <button
                  type="button"
                  class="artifact-compare__tab is-active"
                  data-tab="summary"
                  id="artifact-compare-tab-summary"
                >
                  Summary
                </button>
                <button
                  type="button"
                  class="artifact-compare__tab"
                  data-tab="changes"
                  id="artifact-compare-tab-changes"
                >
                  Changes
                </button>
              </div>
              <div class="artifact-compare__actions">
                <button
                  type="button"
                  class="artifact-compare__download"
                  id="artifact-compare-download"
                  aria-disabled="true"
                >
                  Download diff.json
                </button>
                <button
                  type="button"
                  class="artifact-compare__download"
                  id="artifact-compare-download-zip"
                  aria-disabled="true"
                >
                  Download diff.zip
                </button>
                <button
                  type="button"
                  class="artifact-compare__download"
                  id="artifact-compare-export-html"
                  aria-disabled="true"
                >
                  Export diff as HTML
                </button>
              </div>
              <div class="artifact-compare__hint">
                Exported reports do not embed your API key.
              </div>
            </div>
            <section
              class="artifact-compare__visual"
              id="artifact-compare-visual"
              data-visible="false"
            >
              <div class="artifact-compare__visual-header">
                <h5 class="artifact-compare__visual-title">Visual compare</h5>
                <div
                  class="artifact-compare__visual-toggle"
                  role="tablist"
                  aria-label="Visual compare mode"
                >
                  <button
                    type="button"
                    class="artifact-compare__visual-toggle-button is-active"
                    data-mode="side-by-side"
                    id="artifact-compare-visual-mode-side"
                  >
                    Side-by-side
                  </button>
                  <button
                    type="button"
                    class="artifact-compare__visual-toggle-button"
                    data-mode="overlay"
                    id="artifact-compare-visual-mode-overlay"
                  >
                    Overlay slider
                  </button>
                </div>
              </div>
              <div class="artifact-compare__visual-body">
                <div
                  class="artifact-compare__visual-side"
                  id="artifact-compare-visual-side"
                  data-active="true"
                >
                  <figure class="artifact-compare__visual-figure">
                    <figcaption class="artifact-compare__visual-caption">Left</figcaption>
                    <img
                      id="artifact-compare-visual-left-image"
                      class="artifact-compare__visual-image"
                      alt="Left preview"
                      draggable="false"
                    />
                  </figure>
                  <figure class="artifact-compare__visual-figure">
                    <figcaption class="artifact-compare__visual-caption">Right</figcaption>
                    <img
                      id="artifact-compare-visual-right-image"
                      class="artifact-compare__visual-image"
                      alt="Right preview"
                      draggable="false"
                    />
                  </figure>
                </div>
                <div
                  class="artifact-compare__visual-overlay"
                  id="artifact-compare-visual-overlay"
                  data-active="false"
                >
                  <div class="artifact-compare__overlay-stage">
                    <img
                      id="artifact-compare-overlay-base"
                      class="artifact-compare__overlay-base"
                      alt="Left preview base"
                      draggable="false"
                    />
                    <div
                      class="artifact-compare__overlay-foreground"
                      id="artifact-compare-overlay-foreground"
                    >
                      <img
                        id="artifact-compare-overlay-top"
                        alt="Right preview overlay"
                        draggable="false"
                      />
                    </div>
                  </div>
                  <input
                    type="range"
                    min="0"
                    max="100"
                    value="50"
                    class="artifact-compare__overlay-slider"
                    id="artifact-compare-overlay-slider"
                    aria-label="Overlay position"
                  />
                </div>
              </div>
            </section>
            <div class="artifact-compare__section" data-tab-panel="summary" data-active="true">
              <div class="artifact-compare__summary-grid">
                <div class="artifact-compare__summary-card">
                  <span class="artifact-compare__summary-label">Added</span>
                  <span class="artifact-compare__summary-value" id="artifact-compare-summary-added"
                    >0</span
                  >
                </div>
                <div class="artifact-compare__summary-card">
                  <span class="artifact-compare__summary-label">Removed</span>
                  <span class="artifact-compare__summary-value" id="artifact-compare-summary-removed"
                    >0</span
                  >
                </div>
                <div class="artifact-compare__summary-card">
                  <span class="artifact-compare__summary-label">Changed</span>
                  <span class="artifact-compare__summary-value" id="artifact-compare-summary-changed"
                    >0</span
                  >
                </div>
                <div class="artifact-compare__summary-card">
                  <span class="artifact-compare__summary-label">Unchanged</span>
                  <span
                    class="artifact-compare__summary-value"
                    id="artifact-compare-summary-unchanged"
                    >0</span
                  >
                </div>
              </div>
            </div>
            <div class="artifact-compare__section" data-tab-panel="changes">
              <div class="artifact-compare__search">
                <input
                  type="search"
                  id="artifact-compare-search"
                  placeholder="Search by path"
                  aria-label="Search diff by path"
                />
              </div>
              <div class="artifact-compare__empty" id="artifact-compare-empty" hidden>
                No differences for current filter
              </div>
              <ul class="artifact-compare__diff-list" id="artifact-compare-list"></ul>
            </div>
          </div>
        </aside>
      </div>
    </div>

    <script>
const PluginUtils = (() => {
  const isObject = (value) => value !== null && typeof value === "object";

    const parseServerError = (payload, fallback = "Request failed") => {
      if (payload instanceof Error) {
        return payload.message || fallback;
      }
      if (typeof payload === "string") {
        const trimmed = payload.trim();
        return trimmed || fallback;
      }
      const tryExtract = (data) => {
        if (!data) return null;
        if (typeof data.message === "string") {
          const code = typeof data.code === "string" || typeof data.code === "number" ? data.code : null;
          if (code != null && data.message) {
            return `${code}: ${data.message}`;
          }
          return data.message;
        }
        if (typeof data.error === "string" && data.error.trim()) {
          return data.error.trim();
        }
        return null;
      };

      if (isObject(payload) && isObject(payload.error)) {
        const nested = tryExtract(payload.error) || tryExtract(payload.error.error);
        if (nested) return nested;
        const code = payload.error.code;
        const message = payload.error.message;
        if (code || message) {
          return [code, message].filter(Boolean).join(": ") || fallback;
        }
      }

      if (isObject(payload)) {
        const direct = tryExtract(payload);
        if (direct) return direct;
      }

      return fallback;
    };

    const createRaceGuard = () => {
      let activeToken = 0;
      let abortController = null;

      const start = () => {
        activeToken += 1;
        if (abortController) {
          try {
            abortController.abort();
          } catch (_) {}
        }
        abortController = typeof AbortController !== "undefined" ? new AbortController() : null;
        return {
          token: activeToken,
          signal: abortController ? abortController.signal : undefined,
        };
      };

      const isActive = (token) => token === activeToken;

      const finish = (token) => {
        if (token === activeToken) {
          abortController = null;
        }
      };

      return {
        start,
        isActive,
        finish,
        get signal() {
          return abortController ? abortController.signal : undefined;
        },
      };
    };

    const createPersistentState = (key, options = {}) => {
      const {
        storage = typeof window !== "undefined" && window.localStorage ? window.localStorage : null,
        parser = (value) => JSON.parse(value),
        serializer = (value) => JSON.stringify(value),
        fallback,
      } = options;

      const read = (defaultValue = fallback) => {
        if (!storage) return defaultValue;
        try {
          const raw = storage.getItem(key);
          if (raw == null) return defaultValue;
          return parser(raw);
        } catch (_) {
          return defaultValue;
        }
      };

      const write = (value) => {
        if (!storage) return false;
        try {
          if (value === undefined) {
            storage.removeItem(key);
            return true;
          }
          storage.setItem(key, serializer(value));
          return true;
        } catch (_) {
          return false;
        }
      };

      return { read, write };
    };

    const readBasicAutoLayoutValue = (source, key) => {
      if (!isObject(source)) {
        return null;
      }

      if (Number.isFinite(source[key])) {
        return source[key];
      }

      if (!key || !key.startsWith("padding")) {
        return null;
      }

      const side = key.slice("padding".length);
      if (!side) {
        return null;
      }

      const normalizedSide = side.charAt(0).toLowerCase() + side.slice(1);
      const paddingSource = source.padding;

      if (Number.isFinite(paddingSource)) {
        return paddingSource;
      }

      if (isObject(paddingSource)) {
        if (Number.isFinite(paddingSource[normalizedSide])) {
          return paddingSource[normalizedSide];
        }
        if (Number.isFinite(paddingSource[side])) {
          return paddingSource[side];
        }
      }

      return null;
    };

    const computeBasicDeviations = (expected, actual, tolerancePx) => {
      const tolerance = Number.isFinite(tolerancePx) ? Math.max(0, Math.abs(tolerancePx)) : 2;
      const properties = [
        "itemSpacing",
        "paddingTop",
        "paddingRight",
        "paddingBottom",
        "paddingLeft",
        "gridGap",
        "layoutMode",
      ];

      const result = [];

      for (const property of properties) {
        if (property === "layoutMode") {
          const expectedLayout =
            isObject(expected) && typeof expected.layoutMode === "string" ? expected.layoutMode : null;
          if (!expectedLayout) {
            continue;
          }

          const actualLayout =
            isObject(actual) && typeof actual.layoutMode === "string" ? actual.layoutMode : null;
          if (expectedLayout !== actualLayout) {
            result.push({ property, expected: expectedLayout, actual: actualLayout, delta: null });
          }
          continue;
        }

        const expectedValue = readBasicAutoLayoutValue(expected, property);
        const actualValue = readBasicAutoLayoutValue(actual, property);

        if (!Number.isFinite(expectedValue) || !Number.isFinite(actualValue)) {
          continue;
        }

        const delta = actualValue - expectedValue;
        if (Math.abs(delta) > tolerance) {
          result.push({ property, expected: expectedValue, actual: actualValue, delta });
        }
      }

      return result;
    };

    const normalizeSchemaErrors = (errors) => {
      if (!Array.isArray(errors)) return [];
      return errors
        .map((entry) => {
          if (!entry) return null;
          const pathCandidates = [
            typeof entry.path === "string" ? entry.path : null,
            typeof entry.instancePath === "string" ? entry.instancePath : null,
            typeof entry.dataPath === "string" ? entry.dataPath : null,
          ];
          const path = pathCandidates.find((value) => value && value.length) || "/";
          const message =
            entry && typeof entry.message === "string" && entry.message.trim()
              ? entry.message.trim()
              : "Invalid value";
          return { path, message };
        })
        .filter(Boolean);
    };

    const sanitizeFilename = (input, fallback = "ExportSpec") => {
      const fallbackName =
        typeof fallback === "string" && fallback.trim() ? fallback.trim() : "ExportSpec";
      if (typeof input !== "string") return fallbackName;
      const trimmed = input.trim();
      if (!trimmed) return fallbackName;
      const replaced = trimmed.replace(/[\\/:*?"<>|]+/g, "_");
      const collapsed = replaced.replace(/\s+/g, " ").trim();
      const withoutDots = collapsed.replace(/\.+$/, "");
      const limited = withoutDots.slice(0, 120);
      return limited || fallbackName;
    };

    const stringifyJson = (value, fallback = "") => {
      if (value === undefined) return typeof fallback === "string" ? fallback : "";
      try {
        return JSON.stringify(value, null, 2);
      } catch (error) {
        if (value == null) {
          return typeof fallback === "string" ? fallback : "";
        }
        try {
          return String(value);
        } catch (_) {
          return typeof fallback === "string" ? fallback : "";
        }
      }
    };

    const validateTaskSpecSchema = (value) => {
      const errors = [];
      const addError = (path, message) => {
        errors.push({ path, message });
      };

      const isFiniteNumber = (input) => typeof input === "number" && Number.isFinite(input);

      if (!isObject(value)) {
        addError("/", "TaskSpec must be an object");
        return { valid: false, errors };
      }

      const { meta, target, grid, sections, acceptance } = value;

      if (!isObject(meta)) {
        addError("/meta", "meta must be an object");
      } else {
        if (typeof meta.specVersion !== "string") {
          addError("/meta/specVersion", "specVersion must be a string");
        }
        if (typeof meta.id !== "string") {
          addError("/meta/id", "id must be a string");
        }
        if (
          Object.prototype.hasOwnProperty.call(meta, "inferred") &&
          typeof meta.inferred !== "boolean"
        ) {
          addError("/meta/inferred", "inferred must be a boolean");
        }
      }

      if (!isObject(target)) {
        addError("/target", "target must be an object");
      } else {
        if (typeof target.fileId !== "string") {
          addError("/target/fileId", "fileId must be a string");
        }
        if (typeof target.pageName !== "string") {
          addError("/target/pageName", "pageName must be a string");
        }
        if (typeof target.frameName !== "string") {
          addError("/target/frameName", "frameName must be a string");
        }
        if (!isObject(target.frameSize)) {
          addError("/target/frameSize", "frameSize must be an object");
        } else {
          const frameSize = target.frameSize;
          if (!isFiniteNumber(frameSize.w) || frameSize.w < 1) {
            addError("/target/frameSize/w", "w must be a number ≥ 1");
          }
          if (!isFiniteNumber(frameSize.h) || frameSize.h < 1) {
            addError("/target/frameSize/h", "h must be a number ≥ 1");
          }
          const allowedKeys = new Set(["w", "h"]);
          Object.keys(frameSize).forEach((key) => {
            if (!allowedKeys.has(key)) {
              addError(`/target/frameSize/${key}`, "Unknown property");
            }
          });
        }
      }

      if (!isObject(grid)) {
        addError("/grid", "grid must be an object");
      } else {
        if (!isFiniteNumber(grid.container) || grid.container < 1) {
          addError("/grid/container", "container must be a number ≥ 1");
        }
        if (!Number.isInteger(grid.columns) || grid.columns < 1) {
          addError("/grid/columns", "columns must be an integer ≥ 1");
        }
        if (!isFiniteNumber(grid.gap) || grid.gap < 0) {
          addError("/grid/gap", "gap must be a number ≥ 0");
        }
        if (!isFiniteNumber(grid.margins) || grid.margins < 0) {
          addError("/grid/margins", "margins must be a number ≥ 0");
        }
      }

      if (!Array.isArray(sections)) {
        addError("/sections", "sections must be an array");
      } else if (sections.length === 0) {
        addError("/sections", "sections must contain at least one item");
      } else {
        const allowedTypes = new Set(["hero", "features", "gallery", "cta", "footer", "custom"]);
        sections.forEach((section, index) => {
          const basePath = `/sections/${index}`;
          if (!isObject(section)) {
            addError(basePath, "section must be an object");
            return;
          }
          if (typeof section.type !== "string" || !allowedTypes.has(section.type)) {
            addError(
              `${basePath}/type`,
              "type must be one of hero, features, gallery, cta, footer, custom",
            );
          }
          if (typeof section.name !== "string") {
            addError(`${basePath}/name`, "name must be a string");
          }
        });
      }

      if (acceptance != null) {
        if (!isObject(acceptance)) {
          addError("/acceptance", "acceptance must be an object");
        } else {
          if (
            Object.prototype.hasOwnProperty.call(acceptance, "maxSpacingDeviation") &&
            !isFiniteNumber(acceptance.maxSpacingDeviation)
          ) {
            addError("/acceptance/maxSpacingDeviation", "maxSpacingDeviation must be a number");
          }
          if (
            Object.prototype.hasOwnProperty.call(acceptance, "checkAutoLayout") &&
            typeof acceptance.checkAutoLayout !== "boolean"
          ) {
            addError("/acceptance/checkAutoLayout", "checkAutoLayout must be a boolean");
          }
        }
      }

      return { valid: errors.length === 0, errors };
    };

    const normalizeHexColor = (input) => {
      if (typeof input !== "string") return null;
      const trimmed = input.trim();
      if (!trimmed) return null;
      const prefixed = trimmed.startsWith("#") ? trimmed : `#${trimmed}`;
      const upper = prefixed.toUpperCase();
      if (!/^#([0-9A-F]{6}|[0-9A-F]{8})$/.test(upper)) {
        return null;
      }
      if (upper.length === 9 && upper.endsWith("FF")) {
        return upper.slice(0, 7);
      }
      return upper;
    };

    const parseHexColor = (hex) => {
      const normalized = normalizeHexColor(hex);
      if (!normalized) return null;
      const value = normalized.slice(1);
      const hasAlpha = value.length === 8;
      const r = parseInt(value.slice(0, 2), 16);
      const g = parseInt(value.slice(2, 4), 16);
      const b = parseInt(value.slice(4, 6), 16);
      const a = hasAlpha ? parseInt(value.slice(6, 8), 16) / 255 : 1;
      return { r, g, b, a };
    };

    const srgbChannelToLinear = (value) => {
      const channel = value / 255;
      if (channel <= 0.04045) {
        return channel / 12.92;
      }
      return Math.pow((channel + 0.055) / 1.055, 2.4);
    };

    const computeRelativeLuminance = (color) => {
      if (!color) return 0;
      const r = srgbChannelToLinear(color.r);
      const g = srgbChannelToLinear(color.g);
      const b = srgbChannelToLinear(color.b);
      return 0.2126 * r + 0.7152 * g + 0.0722 * b;
    };

    const computeContrastRatio = (lumA, lumB) => {
      const [L1, L2] = lumA >= lumB ? [lumA, lumB] : [lumB, lumA];
      return (L1 + 0.05) / (L2 + 0.05);
    };

    const median = (values) => {
      if (!Array.isArray(values) || values.length === 0) return null;
      const sorted = values
        .filter((value) => Number.isFinite(value))
        .sort((a, b) => a - b);
      if (!sorted.length) return null;
      const mid = Math.floor(sorted.length / 2);
      if (sorted.length % 2 === 1) {
        return sorted[mid];
      }
      return (sorted[mid - 1] + sorted[mid]) / 2;
    };

    const slugify = (value, fallback = "item") => {
      if (typeof value !== "string") return fallback;
      const trimmed = value.trim().toLowerCase();
      if (!trimmed) return fallback;
      const normalized = trimmed
        .normalize("NFD")
        .replace(/[\u0300-\u036f]/g, "")
        .replace(/[^a-z0-9]+/g, "-")
        .replace(/^-+|-+$/g, "");
      return normalized || fallback;
    };

    const toInt = (value) => {
      if (!Number.isFinite(value)) return null;
      const rounded = Math.round(value);
      return Number.isFinite(rounded) ? rounded : null;
    };

    const normalizeFrameSize = (input) => {
      if (!isObject(input)) return null;
      const width = toInt(input.width != null ? input.width : input.w);
      const height = toInt(input.height != null ? input.height : input.h);
      if (width == null || height == null || width <= 0 || height <= 0) {
        return null;
      }
      return { w: width, h: height };
    };

    const ensureString = (value) => {
      if (typeof value === "string") {
        const trimmed = value.trim();
        return trimmed || null;
      }
      return null;
    };

    const normalizeSectionKey = (value) => {
      const normalized = ensureString(value);
      return normalized ? normalized.toLowerCase() : null;
    };

    const collectSectionDocumentNodes = (exportSpec) => {
      const map = new Map();
      if (!isObject(exportSpec)) return map;
      const document = isObject(exportSpec.document) ? exportSpec.document : null;
      const nodes = document && Array.isArray(document.nodes) ? document.nodes : [];
      nodes.forEach((node) => {
        if (!isObject(node)) return;
        const key = normalizeSectionKey(node.section);
        if (!key) return;
        if (!map.has(key)) {
          map.set(key, []);
        }
        map.get(key).push(node);
      });
      return map;
    };

    const normalizePadding = (input) => {
      if (!isObject(input)) return null;
      const result = {};
      [
        ["top", "top"],
        ["right", "right"],
        ["bottom", "bottom"],
        ["left", "left"],
      ].forEach(([key, alias]) => {
        const value = toInt(input[key] != null ? input[key] : input[alias]);
        if (value != null) {
          result[key] = value;
        }
      });
      return Object.keys(result).length ? result : null;
    };

    const collectTextSamples = (section) => {
      if (!section || !Array.isArray(section.texts)) return [];
      return section.texts
        .map((text) => {
          if (!text || typeof text !== "object") return null;
          const characters = ensureString(text.characters);
          if (!characters) return null;
          return {
            characters,
            fontFamily: ensureString(text.fontFamily),
            fontStyle: ensureString(text.fontStyle),
            fontSize: toInt(text.fontSize),
            fill: normalizeHexColor(text.fill && text.fill.hex ? text.fill.hex : null),
          };
        })
        .filter(Boolean);
    };

    const ACTION_WORD_PATTERN =
      /\b(get|start|try|join|learn|book|buy|shop|download|sign|contact|discover|explore|view|see|request|schedule|create|launch|build|watch|order|upgrade|subscribe)\b/i;

    const collectDraftTextInsights = (section) => {
      const samples = collectTextSamples(section);
      const entries = samples
        .map((sample) => {
          const characters = ensureString(sample && sample.characters);
          if (!characters) return null;
          const fontSize = toInt(sample.fontSize);
          const words = characters.trim().split(/\s+/).filter(Boolean);
          return {
            characters,
            fontSize: Number.isFinite(fontSize) ? fontSize : null,
            length: characters.length,
            wordCount: words.length,
            hasAction: ACTION_WORD_PATTERN.test(characters),
          };
        })
        .filter(Boolean);
      const fontSizes = entries
        .map((entry) => entry.fontSize)
        .filter((value) => value != null && Number.isFinite(value));
      const maxFontSize = fontSizes.length ? Math.max(...fontSizes) : null;
      const mediumContentCount = entries.filter(
        (entry) => entry.wordCount >= 4 || entry.length >= 16,
      ).length;
      const hasActionWord = entries.some((entry) => entry.hasAction);
      return { entries, maxFontSize, mediumContentCount, hasActionWord };
    };

    const isHeroDraftCandidate = (section, index) => {
      if (!section) return false;
      if (index > 1) return false;
      const insights = collectDraftTextInsights(section);
      if (!insights.entries.length) return false;
      if (insights.maxFontSize == null || insights.maxFontSize < 34) return false;
      if (insights.mediumContentCount === 0 && !insights.hasActionWord) {
        return false;
      }
      return true;
    };

    const isFeaturesDraftCandidate = (section) => {
      if (!section) return false;
      const grid = isObject(section.grid) ? section.grid : null;
      if (!grid || !Number.isFinite(grid.columns) || grid.columns < 2) {
        return false;
      }
      const samples = collectTextSamples(section);
      if (!samples.length) return false;
      const uniqueTexts = new Set(
        samples
          .map((sample) => ensureString(sample && sample.characters))
          .filter(Boolean)
          .map((text) => text.trim())
          .filter(Boolean),
      );
      return uniqueTexts.size >= Math.min(grid.columns, 2);
    };

    const detectGalleryDraft = (section, sectionNodes) => {
      const grid = isObject(section && section.grid) ? section.grid : null;
      const columns = grid && Number.isFinite(grid.columns) ? grid.columns : null;
      if (!columns || columns < 2) {
        return { match: false, warning: null };
      }

      const textCount = Array.isArray(sectionNodes)
        ? sectionNodes.filter((node) => node && node.type === "TEXT").length
        : 0;
      if (textCount > 3) {
        return { match: false, warning: null };
      }

      if (!Array.isArray(sectionNodes) || !sectionNodes.length) {
        return { match: false, warning: null };
      }

      const sectionWidth = isObject(section) && isObject(section.size)
        ? toInt(
            section.size.width != null
              ? section.size.width
              : section.size.w,
          )
        : null;

      const rectangleWidths = sectionNodes
        .filter((node) => node && node.type === "RECTANGLE")
        .map((node) => {
          const bounds = isObject(node.absBounds) ? node.absBounds : null;
          if (!bounds || !Number.isFinite(bounds.w)) return null;
          const width = Math.round(bounds.w);
          if (width < 24) return null;
          if (sectionWidth && width >= sectionWidth - 4) return null;
          return width;
        })
        .filter((value) => Number.isFinite(value));

      if (!rectangleWidths.length) {
        return { match: false, warning: null };
      }

      const minItems = columns >= 3 ? columns + 1 : Math.max(columns, 4);
      if (rectangleWidths.length < minItems) {
        return { match: false, warning: null };
      }

      const columnWidth = Number.isFinite(grid.columnWidth) ? Math.round(grid.columnWidth) : null;
      const widthMedian = rectangleWidths.length ? Math.round(median(rectangleWidths)) : null;
      const baseWidth = columnWidth != null ? columnWidth : widthMedian;
      const tolerance = Math.max(4, baseWidth != null ? Math.round(Math.abs(baseWidth) * 0.08) : 6);

      const groups = [];
      rectangleWidths.forEach((width) => {
        let match = null;
        for (let i = 0; i < groups.length; i += 1) {
          const candidate = groups[i];
          if (Math.abs(candidate.avg - width) <= tolerance) {
            match = candidate;
            break;
          }
        }
        if (match) {
          match.sum += width;
          match.count += 1;
          match.avg = match.sum / match.count;
          match.min = Math.min(match.min, width);
          match.max = Math.max(match.max, width);
        } else {
          groups.push({ sum: width, count: 1, avg: width, min: width, max: width });
        }
      });

      if (!groups.length) {
        return {
          match: false,
          warning: "Секция похожа на галерею (grid), но повторяющиеся элементы не обнаружены — проверьте вручную.",
        };
      }

      const dominant = groups.reduce((best, group) => (group.count > (best ? best.count : 0) ? group : best), null);
      if (!dominant) {
        return {
          match: false,
          warning: "Секция похожа на галерею (grid), но анализ размеров не удался — проверьте вручную.",
        };
      }

      if (dominant.count < Math.max(3, columns)) {
        return {
          match: false,
          warning: "Сетка изображений найдена, но элементов недостаточно для уверенности — проверьте вручную.",
        };
      }

      const uniformRatio = dominant.count / rectangleWidths.length;
      if (uniformRatio < 0.7) {
        return {
          match: false,
          warning: "Изображения в сетке сильно отличаются по ширине — проверьте вручную.",
        };
      }

      if (columnWidth != null) {
        const diff = Math.abs(dominant.avg - columnWidth);
        const allowed = Math.max(tolerance * 2, Math.max(8, Math.abs(columnWidth) * 0.12));
        if (diff > allowed) {
          return {
            match: false,
            warning: "Ширина изображений не совпадает с колонками сетки — проверьте вручную.",
          };
        }
      }

      if (dominant.max - dominant.min > Math.max(tolerance, 12)) {
        return {
          match: false,
          warning: "Изображения в сетке различаются по размеру больше допустимого — проверьте вручную.",
        };
      }

      return { match: true, warning: null };
    };

    const determineDraftSectionType = (section, index, context = {}) => {
      const sectionNodes = Array.isArray(context.sectionNodes) ? context.sectionNodes : [];
      if (isHeroDraftCandidate(section, index)) {
        return { type: "hero" };
      }
      const galleryDetection = detectGalleryDraft(section, sectionNodes);
      if (galleryDetection.match) {
        return { type: "gallery" };
      }
      if (isFeaturesDraftCandidate(section)) {
        return { type: "features" };
      }
      if (galleryDetection.warning) {
        return { type: "custom", warning: galleryDetection.warning };
      }
      if (index === 0) {
        return {
          type: "custom",
          warning: "Первая секция не распознана автоматически. Проверьте вручную.",
        };
      }
      return { type: "custom" };
    };

    const clamp01 = (value) => {
      if (!Number.isFinite(value)) return 0;
      if (value < 0) return 0;
      if (value > 1) return 1;
      return value;
    };

    const determineSectionType = (section, index, total) => {
      const name = ensureString(section && section.name);
      const normalizedName = name ? name.toLowerCase() : "";
      const layoutMode = ensureString(section && section.layoutMode);
      const upperLayout = layoutMode ? layoutMode.toUpperCase() : null;
      const grid = section && isObject(section.grid) ? section.grid : null;
      const texts = collectTextSamples(section);
      const fontSizes = texts
        .map((sample) => (Number.isFinite(sample.fontSize) ? sample.fontSize : null))
        .filter((value) => value != null && value > 0);
      const maxFontSize = fontSizes.length ? Math.max(...fontSizes) : null;
      const minFontSize = fontSizes.length ? Math.min(...fontSizes) : null;
      const avgFontSize = fontSizes.length
        ? fontSizes.reduce((sum, value) => sum + value, 0) / fontSizes.length
        : null;
      const largeTextCount = fontSizes.filter((value) => value >= 36).length;
      const mediumTextCount = fontSizes.filter((value) => value >= 24).length;
      const shortTextCount = texts.filter(
        (sample) => sample.characters && sample.characters.length <= 24,
      ).length;
      const longTextCount = texts.filter(
        (sample) => sample.characters && sample.characters.length >= 60,
      ).length;
      const normalizedTexts = texts.map((sample) => sample.characters.toLowerCase());

      const backgroundHex = normalizeHexColor(section && section.fill && section.fill.hex);
      const backgroundColor = backgroundHex ? parseHexColor(backgroundHex) : null;
      const backgroundLuminance = backgroundColor
        ? computeRelativeLuminance(backgroundColor)
        : null;
      let maxContrast = null;
      if (backgroundLuminance != null) {
        normalizedTexts.forEach((_, idx) => {
          const sample = texts[idx];
          const textHex = normalizeHexColor(sample.fill);
          if (!textHex) return;
          const textColor = parseHexColor(textHex);
          if (!textColor) return;
          const luminance = computeRelativeLuminance(textColor);
          const ratio = computeContrastRatio(luminance, backgroundLuminance);
          if (!Number.isFinite(ratio)) return;
          if (maxContrast == null || ratio > maxContrast) {
            maxContrast = ratio;
          }
        });
      }
      const hasHighContrast = maxContrast != null && maxContrast >= 4.5;
      const hasMediumContrast = maxContrast != null && maxContrast >= 3;

      const actionWords = [
        "sign",
        "start",
        "join",
        "buy",
        "try",
        "book",
        "order",
        "contact",
        "talk",
        "get",
        "learn",
        "download",
        "subscribe",
        "регист",
        "купи",
        "закаж",
        "узна",
        "начни",
        "начать",
        "присоед",
        "подпиш",
        "связ",
        "оформ",
        "получ",
        "запиш",
      ];
      const hasActionWord = normalizedTexts.some((text) =>
        actionWords.some((word) => text.includes(word)),
      );

      const footerWords = [
        "privacy",
        "terms",
        "policy",
        "контакт",
        "связь",
        "адрес",
        "почта",
        "email",
        "тел",
        "copyright",
        "©",
        "faq",
      ];
      const hasFooterWord = normalizedTexts.some((text) =>
        footerWords.some((word) => text.includes(word)),
      );

      const byName = (keywords) => keywords.some((keyword) => normalizedName.includes(keyword));

      const heroNameMatch = byName(["hero", "header", "top", "intro", "главная"]);
      const featuresNameMatch = byName([
        "feature",
        "benefit",
        "service",
        "услуг",
        "преимущ",
        "advantages",
      ]);
      const ctaNameMatch = byName([
        "cta",
        "call to action",
        "call-to-action",
        "signup",
        "button",
        "призыв",
      ]);
      const footerNameMatch = byName([
        "footer",
        "подвал",
        "contacts",
        "contact",
        "support",
      ]);

      const heroLayout = upperLayout === "HORIZONTAL" ? "row" : "stack";
      const candidates = [];

      if (grid && Number.isFinite(grid.columns) && grid.columns >= 2) {
        const columns = Math.max(2, Math.round(grid.columns));
        let featuresConfidence = 0.65 + Math.min(0.25, (columns - 2) * 0.05);
        if (upperLayout === "HORIZONTAL") {
          featuresConfidence += 0.05;
        }
        if (avgFontSize != null && avgFontSize <= 24) {
          featuresConfidence += 0.03;
        }
        if (featuresNameMatch) {
          featuresConfidence = Math.max(featuresConfidence, 0.75);
        }
        candidates.push({
          type: "features",
          layout: `grid-${columns}`,
          confidence: clamp01(featuresConfidence),
        });
      } else if (featuresNameMatch) {
        candidates.push({
          type: "features",
          layout: "stack",
          confidence: 0.55,
        });
      }

      let heroConfidence = 0;
      if (index === 0 || heroNameMatch) {
        heroConfidence = index === 0 ? 0.4 : 0.25;
        if (maxFontSize != null && maxFontSize >= 44) {
          heroConfidence += 0.25;
        } else if (maxFontSize != null && maxFontSize >= 34) {
          heroConfidence += 0.18;
        }
        if (mediumTextCount >= 2 || longTextCount > 0) {
          heroConfidence += 0.1;
        }
        if (hasActionWord) {
          heroConfidence += 0.1;
        }
        if (upperLayout === "HORIZONTAL") {
          heroConfidence += 0.05;
        }
        if (heroNameMatch) {
          heroConfidence = Math.max(heroConfidence, 0.7);
        }
        heroConfidence = clamp01(heroConfidence);
        candidates.push({ type: "hero", layout: heroLayout, confidence: heroConfidence });
      }

      let ctaConfidence = 0;
      if (hasActionWord || ctaNameMatch) {
        ctaConfidence = hasActionWord ? 0.45 : 0.35;
        if (maxFontSize != null && maxFontSize >= 26) {
          ctaConfidence += 0.12;
        }
        if (mediumTextCount <= 2) {
          ctaConfidence += 0.05;
        }
        if (texts.length <= 3) {
          ctaConfidence += 0.05;
        }
        if (hasHighContrast) {
          ctaConfidence += 0.15;
        } else if (hasMediumContrast) {
          ctaConfidence += 0.05;
        }
        if (ctaNameMatch) {
          ctaConfidence = Math.max(ctaConfidence, 0.65);
        }
        ctaConfidence = clamp01(ctaConfidence);
        candidates.push({ type: "cta", layout: "stack", confidence: ctaConfidence });
      }

      let footerConfidence = 0;
      if ((total > 1 && index === total - 1) || footerNameMatch || hasFooterWord) {
        footerConfidence = total > 1 && index === total - 1 ? 0.45 : 0.3;
        if (maxFontSize != null && maxFontSize <= 16) {
          footerConfidence += 0.18;
        }
        if (minFontSize != null && minFontSize <= 13) {
          footerConfidence += 0.05;
        }
        if (shortTextCount >= 2) {
          footerConfidence += 0.05;
        }
        if (hasFooterWord) {
          footerConfidence += 0.15;
        }
        if (footerNameMatch) {
          footerConfidence = Math.max(footerConfidence, 0.7);
        }
        footerConfidence = clamp01(footerConfidence);
        candidates.push({ type: "footer", layout: "stack", confidence: footerConfidence });
      }

      if (!candidates.length) {
        return {
          type: "custom",
          layout: "stack",
          confidence: 0.35,
          warnings: ["Тип секции не распознан автоматически — проверьте вручную."],
        };
      }

      candidates.sort((a, b) => b.confidence - a.confidence);
      const best = candidates[0];
      const warnings = [];
      if (best.type === "features" && (!grid || !Number.isFinite(grid.columns))) {
        warnings.push("Секция отмечена как features по названию. Убедитесь, что layout корректен.");
      }

      if (best.confidence < 0.6 && best.type !== "custom") {
        warnings.push(
          `Секция распознана как ${best.type}, но уверенность низкая — проверьте вручную.`,
        );
        return {
          type: "custom",
          layout: best.layout || "stack",
          confidence: clamp01(best.confidence),
          warnings,
        };
      }

      return {
        type: best.type,
        layout: best.layout || "stack",
        confidence: clamp01(best.confidence),
        warnings,
      };
    };

    const proposeTaskSpecFromExport = (exportSpec, options = {}) => {
      const { specVersion = "0.1", fallbackFileId = "REPLACE_WITH_FILE_ID" } = options;
      const warningSet = new Set();
      const pushWarning = (message) => {
        const normalized = ensureString(message);
        if (!normalized) return;
        if (warningSet.has(normalized)) return;
        warningSet.add(normalized);
      };

      if (!isObject(exportSpec)) {
        pushWarning("ExportSpec отсутствует. Сначала выполните Import.");
        return { taskSpec: null, warnings: Array.from(warningSet.values()) };
      }

      const meta = isObject(exportSpec.meta) ? exportSpec.meta : {};
      const target = isObject(exportSpec.target) ? exportSpec.target : {};
      const sectionsRaw = Array.isArray(exportSpec.sections)
        ? exportSpec.sections.filter((item) => isObject(item))
        : [];
      const sectionNodesMap = collectSectionDocumentNodes(exportSpec);

      const pageName = ensureString(target.pageName) || ensureString(meta.pageName) || null;
      const frameName = ensureString(target.frameName) || ensureString(meta.frameName) || null;
      const pageId = ensureString(target.pageId) || null;
      const frameId = ensureString(target.frameId) || ensureString(meta.frameId) || null;
      const fileId = ensureString(target.fileId) || fallbackFileId;

      if (!pageName) {
        pushWarning("target.pageName не найден в ExportSpec. Заполните вручную.");
      }
      if (!frameName) {
        pushWarning("target.frameName не найден в ExportSpec. Заполните вручную.");
      }
      if (!ensureString(target.fileId)) {
        pushWarning("target.fileId не найден. Заполните вручную.");
      }

      const frameSizeRaw = isObject(meta.frameSize) ? meta.frameSize : target.frameSize;
      const frameSize = normalizeFrameSize(frameSizeRaw);
      let finalFrameSize = frameSize;
      if (!frameSize) {
        finalFrameSize = { w: 1440, h: 900 };
        pushWarning("Размер фрейма не найден. Используются значения по умолчанию 1440×900.");
      }

      const idBase = [pageName, frameName].filter(Boolean).join("-") || "selection";
      const specId = slugify(idBase);

      const spacingCandidates = sectionsRaw
        .map((section) => toInt(section.itemSpacing))
        .filter((value) => Number.isFinite(value) && value >= 0);
      const draftGap = spacingCandidates.length ? median(spacingCandidates) : 24;
      const normalizedGap = Number.isFinite(draftGap) ? Math.max(0, Math.round(draftGap)) : 24;
      const normalizedContainer = finalFrameSize && Number.isFinite(finalFrameSize.w)
        ? Math.max(320, Math.round(finalFrameSize.w))
        : 1200;

      const taskSpec = {
        meta: {
          specVersion,
          id: specId ? `${specId}-draft` : "selection-draft",
          proposed: true,
          source: "propose-task-spec",
          frameId: frameId || undefined,
          pageId: pageId || undefined,
        },
        target: {
          fileId,
          pageName: pageName || "REPLACE_PAGE_NAME",
          frameName: frameName || "REPLACE_FRAME_NAME",
          frameSize: finalFrameSize,
        },
        grid: {
          container: normalizedContainer,
          columns: 12,
          gap: normalizedGap,
          margins: 24,
        },
        sections: [],
      };

      sectionsRaw.forEach((section, index) => {
        const rawName = ensureString(section.name);
        const name = rawName || `Section ${index + 1}`;
        const layoutMode = ensureString(section.layoutMode);
        const layout = layoutMode && layoutMode.toUpperCase() === "HORIZONTAL" ? "row" : "stack";
        const padding = normalizePadding(section.padding);
        const spacing = toInt(section.itemSpacing);
        const sectionKey = normalizeSectionKey(rawName);
        const sectionNodes = sectionKey ? sectionNodesMap.get(sectionKey) || [] : [];
        const detection = determineDraftSectionType(section, index, { sectionNodes });
        if (detection.warning) {
          pushWarning(detection.warning);
        }
        const textSamples = collectTextSamples(section)
          .map((sample) => ensureString(sample.characters))
          .filter(Boolean)
          .slice(0, 6);

        const specSection = {
          type: detection.type,
          name,
          layout,
        };
        if (spacing != null && Number.isFinite(spacing)) {
          specSection.spacing = spacing;
        }
        if (padding) {
          specSection.padding = padding;
        }
        if (textSamples.length) {
          specSection.textSamples = textSamples;
        }
        const sectionMeta = { proposed: true };
        const sourceId = ensureString(section.id);
        if (sourceId) {
          sectionMeta.sourceId = sourceId;
        }
        if (layoutMode) {
          sectionMeta.layoutMode = layoutMode;
        }
        if (Object.keys(sectionMeta).length) {
          specSection.meta = sectionMeta;
        }
        taskSpec.sections.push(specSection);
      });

      if (!taskSpec.sections.length) {
        pushWarning("Секции не распознаны автоматически. Добавьте их вручную.");
      }

      return { taskSpec, warnings: Array.from(warningSet.values()) };
    };

    const inferTaskSpecFromExportSpec = (exportSpec, options = {}) => {
      const {
        specVersion = "0.1",
        fallbackFileId = "REPLACE_WITH_FILE_ID",
        defaultColumns = 12,
        defaultGap = 24,
      } = options;

      const warnings = [];
      const warningSet = new Set();
      const pushWarning = (message) => {
        const normalized = ensureString(message);
        if (!normalized) return;
        if (warningSet.has(normalized)) return;
        warningSet.add(normalized);
        warnings.push(normalized);
      };

      if (!isObject(exportSpec)) {
        pushWarning("ExportSpec отсутствует или имеет неверный формат.");
        return { taskSpec: null, warnings };
      }

      const meta = isObject(exportSpec.meta) ? exportSpec.meta : {};
      const target = isObject(exportSpec.target) ? exportSpec.target : {};
      const sectionsRaw = Array.isArray(exportSpec.sections)
        ? exportSpec.sections.filter((item) => isObject(item))
        : [];

      const summaryWarnings = [];
      const directWarnings = Array.isArray(exportSpec.warnings) ? exportSpec.warnings : [];
      const summary = isObject(exportSpec.summary) ? exportSpec.summary : {};
      if (Array.isArray(summary.warnings)) {
        summaryWarnings.push(...summary.warnings);
      }
      summaryWarnings.push(...directWarnings);
      summaryWarnings.forEach((warning) => {
        pushWarning(warning);
      });

      const frameSize =
        normalizeFrameSize(meta.frameSize) || normalizeFrameSize(target.frameSize) || null;
      const fallbackFrameSize = { w: 1200, h: 800 };
      const finalFrameSize = frameSize || fallbackFrameSize;
      if (!frameSize) {
        pushWarning("Размер фрейма не найден в ExportSpec. Используется значение 1200×800 по умолчанию.");
      }

      const containerWidth = finalFrameSize.w;

      const spacingValues = sectionsRaw
        .map((section) => toInt(section.itemSpacing))
        .filter((value) => value != null && value >= 0);
      let gap = spacingValues.length ? median(spacingValues) : null;
      if (gap == null) {
        gap = defaultGap;
        pushWarning(`Не удалось определить gap сетки. Используется значение ${defaultGap}.`);
      }
      gap = Math.max(0, Math.round(gap));

      const columnCandidates = [];
      const columnWidthCandidates = [];
      sectionsRaw.forEach((section) => {
        const grid = section && isObject(section.grid) ? section.grid : null;
        if (!grid) return;
        if (Number.isFinite(grid.columns) && grid.columns >= 1) {
          const columns = Math.max(1, Math.round(grid.columns));
          columnCandidates.push(columns);
          if (Number.isFinite(grid.columnWidth) && grid.columnWidth > 0) {
            columnWidthCandidates.push({ columns, columnWidth: Math.round(grid.columnWidth) });
          }
        }
      });

      let columns = null;
      if (columnCandidates.length) {
        const counts = new Map();
        columnCandidates.forEach((value) => {
          const current = counts.get(value) || 0;
          counts.set(value, current + 1);
        });
        const sorted = Array.from(counts.entries()).sort((a, b) => {
          if (b[1] !== a[1]) return b[1] - a[1];
          return b[0] - a[0];
        });
        columns = sorted.length ? sorted[0][0] : null;
      }
      if (!Number.isInteger(columns) || columns < 1) {
        columns = defaultColumns;
        pushWarning(`Количество колонок сетки не распознано. Используется значение ${defaultColumns}.`);
      }

      const marginCandidates = [];
      sectionsRaw.forEach((section) => {
        const padding = normalizePadding(section && section.padding);
        if (!padding) return;
        if (padding.left != null) marginCandidates.push(padding.left);
        if (padding.right != null) marginCandidates.push(padding.right);
      });
      let margins = marginCandidates.length ? median(marginCandidates) : null;
      if (margins == null && columnWidthCandidates.length) {
        const entry =
          columnWidthCandidates.find((candidate) => candidate.columns === columns) ||
          columnWidthCandidates[0];
        if (entry && entry.columnWidth > 0 && Number.isFinite(containerWidth)) {
          const totalContentWidth = entry.columnWidth * columns + (columns - 1) * gap;
          const computed = Math.round((containerWidth - totalContentWidth) / 2);
          if (Number.isFinite(computed) && computed >= 0) {
            margins = computed;
          }
        }
      }
      if (margins == null) {
        margins = Math.max(0, Math.round(gap));
        pushWarning("Отступы сетки не распознаны. Используется значение, равное gap.");
      }

      const colorStats = new Map();
      const trackColor = (hex, source) => {
        const normalized = normalizeHexColor(hex);
        if (!normalized) return;
        let entry = colorStats.get(normalized);
        if (!entry) {
          const parsed = parseHexColor(normalized);
          entry = {
            hex: normalized,
            count: 0,
            luminance: computeRelativeLuminance(parsed),
            sources: new Set(),
          };
          colorStats.set(normalized, entry);
        }
        entry.count += 1;
        if (source) entry.sources.add(source);
      };

      if (meta && meta.fill && meta.fill.hex) {
        trackColor(meta.fill.hex, "frame");
      }
      sectionsRaw.forEach((section) => {
        if (section && section.fill && section.fill.hex) {
          trackColor(section.fill.hex, "section");
        }
        const textSamples = collectTextSamples(section);
        textSamples.forEach((sample) => {
          trackColor(sample.fill, "text");
        });
      });

      const colorEntries = Array.from(colorStats.values());
      const byCountDescDarkestFirst = (entries) =>
        entries.slice().sort((a, b) => {
          if (b.count !== a.count) return b.count - a.count;
          if (a.luminance !== b.luminance) return a.luminance - b.luminance;
          return a.hex.localeCompare(b.hex);
        });
      const byLightnessDesc = (entries) =>
        entries.slice().sort((a, b) => {
          if (b.luminance !== a.luminance) return b.luminance - a.luminance;
          if (b.count !== a.count) return b.count - a.count;
          return a.hex.localeCompare(b.hex);
        });

      const selectTextColor = () => {
        if (!colorEntries.length) return null;
        const textSources = colorEntries.filter((entry) => entry.sources.has("text"));
        const pool = textSources.length ? textSources : colorEntries;
        const sortedByCount = byCountDescDarkestFirst(pool);
        const topCount = sortedByCount.length ? sortedByCount[0].count : null;
        if (topCount == null) return null;
        const topByCount = sortedByCount.filter((entry) => entry.count === topCount);
        const darkest = topByCount.sort((a, b) => {
          if (a.luminance !== b.luminance) return a.luminance - b.luminance;
          return a.hex.localeCompare(b.hex);
        });
        return darkest.length ? darkest[0] : null;
      };

      const textColor = selectTextColor();
      if (!textColor) {
        pushWarning("Не удалось определить цвет текста. Добавьте его вручную в tokens.colors.text.");
      }

      const selectPrimaryColor = () => {
        if (!colorEntries.length) return null;
        const pool = colorEntries.filter((entry) => !textColor || entry.hex !== textColor.hex);
        if (!pool.length) return null;
        const sorted = byCountDescDarkestFirst(pool);
        return sorted.length ? sorted[0] : null;
      };

      const primaryColor = selectPrimaryColor();
      if (!primaryColor) {
        pushWarning("Не удалось определить основной цвет. Добавьте tokens.colors.primary вручную.");
      }

      const selectNeutralColor = () => {
        if (!colorEntries.length) return null;
        const pool = colorEntries.filter((entry) => !textColor || entry.hex !== textColor.hex);
        if (!pool.length) return null;
        const sorted = byLightnessDesc(pool);
        if (!sorted.length) return null;
        const [first] = sorted;
        if (
          primaryColor &&
          primaryColor.hex === first.hex &&
          sorted.length > 1
        ) {
          const alternative = sorted.find((entry) => entry.hex !== primaryColor.hex);
          if (alternative) {
            return alternative;
          }
        }
        return first;
      };

      const neutralColor = selectNeutralColor();

      if (!neutralColor) {
        pushWarning("Не удалось определить нейтральный цвет. Проверьте tokens.colors.neutral.");
      }

      const fontFamilies = new Map();
      sectionsRaw.forEach((section) => {
        const samples = collectTextSamples(section);
        samples.forEach((sample) => {
          const family = ensureString(sample.fontFamily);
          if (!family) return;
          const current = fontFamilies.get(family) || 0;
          fontFamilies.set(family, current + 1);
        });
      });
      const sortedFamilies = Array.from(fontFamilies.entries()).sort((a, b) => b[1] - a[1]);
      const fontFamily = sortedFamilies.length ? sortedFamilies[0][0] : null;
      if (!fontFamily) {
        pushWarning("Не удалось определить основной шрифт. Заполните tokens.fontFamily вручную.");
      }

      const sections = [];
      sectionsRaw.forEach((section, index) => {
        const total = sectionsRaw.length;
        const detection = determineSectionType(section, index, total);
        const name = ensureString(section.name) || `Section ${index + 1}`;
        const sectionWarnings = [];
        if (Array.isArray(detection.warnings)) {
          detection.warnings.forEach((warning) => {
            const normalized = ensureString(warning);
            if (!normalized) return;
            sectionWarnings.push(normalized);
            pushWarning(normalized);
          });
        }
        const padding = normalizePadding(section.padding);
        const spacing = toInt(section.itemSpacing);
        const textSamples = collectTextSamples(section);
        const specSection = {
          type: detection.type,
          name,
          layout: detection.layout || "stack",
          spacing: spacing != null ? spacing : undefined,
          padding: padding || undefined,
          background: normalizeHexColor(section.fill && section.fill.hex ? section.fill.hex : null) || undefined,
          textSamples: textSamples.map((sample) => sample.characters).filter(Boolean),
          meta: {
            inferred: true,
            sourceId: ensureString(section.id),
            layoutMode: ensureString(section.layoutMode),
            typeConfidence: detection.confidence,
          },
        };
        if (specSection.textSamples && specSection.textSamples.length === 0) {
          delete specSection.textSamples;
        }
        if (specSection.spacing === undefined) {
          delete specSection.spacing;
        }
        if (!specSection.padding) {
          delete specSection.padding;
        }
        if (!specSection.background) {
          delete specSection.background;
        }
        if (sectionWarnings.length) {
          specSection.warnings = sectionWarnings;
        }
        sections.push(specSection);
      });

      if (!sections.length) {
        const fallbackName = ensureString(target.frameName) || "Main";
        pushWarning("ExportSpec не содержит секций. Добавлена заглушка custom.");
        sections.push({
          type: "custom",
          name: fallbackName,
          layout: "stack",
          meta: { inferred: true, typeConfidence: 0 },
          warnings: ["Секция создана автоматически. Замените её вручную."],
        });
      }

      const normalizedPageName = ensureString(target.pageName);
      const normalizedFrameName = ensureString(target.frameName) || ensureString(meta.frameName);
      const normalizedFileId = ensureString(target.fileId);

      if (!normalizedFileId) {
        pushWarning("target.fileId не найден. Замените значение REPLACE_WITH_FILE_ID вручную.");
      }
      if (!normalizedPageName) {
        pushWarning("Имя страницы не найдено в ExportSpec. Заполните target.pageName вручную.");
      }
      if (!normalizedFrameName) {
        pushWarning("Имя фрейма не найдено в ExportSpec. Заполните target.frameName вручную.");
      }

      const pageSlug = slugify(normalizedPageName || "page");
      const frameSlug = slugify(normalizedFrameName || "frame");
      const inferredId = `${pageSlug}-${frameSlug}-draft`;

      const colorTokens = {};
      if (textColor && textColor.hex) {
        colorTokens.text = textColor.hex;
        pushWarning("tokens.colors.text выбрано эвристикой: самый тёмный частотный цвет.");
      }
      if (primaryColor && primaryColor.hex) {
        colorTokens.primary = primaryColor.hex;
        pushWarning(
          "tokens.colors.primary выбрано эвристикой: наиболее частый цвет, отличный от текста.",
        );
      }
      if (neutralColor && neutralColor.hex) {
        colorTokens.neutral = neutralColor.hex;
        pushWarning("tokens.colors.neutral выбрано эвристикой: самый светлый доступный цвет.");
      }

      const tokens = {};
      if (fontFamily) tokens.fontFamily = fontFamily;
      if (Object.keys(colorTokens).length) tokens.colors = colorTokens;

      const taskSpec = {
        meta: {
          specVersion,
          id: inferredId,
          inferred: true,
          source: ensureString(meta.source) || "export-spec",
          frameId: ensureString(target.frameId) || ensureString(meta.frameId) || undefined,
          pageId: ensureString(target.pageId) || undefined,
        },
        target: {
          fileId: normalizedFileId || fallbackFileId,
          pageName: normalizedPageName || "REPLACE_PAGE_NAME",
          frameName: normalizedFrameName || "REPLACE_FRAME_NAME",
          frameSize: finalFrameSize,
        },
        grid: {
          container: containerWidth,
          columns,
          gap,
          margins,
        },
        sections,
        acceptance: {
          maxSpacingDeviation: Math.max(2, Math.round(gap * 0.1)),
          checkAutoLayout: true,
        },
      };

      if (Object.keys(tokens).length) {
        taskSpec.tokens = tokens;
      }

      const uniqueWarnings = Array.from(warningSet.values());
      if (uniqueWarnings.length) {
        taskSpec.meta.warnings = uniqueWarnings;
        taskSpec.warnings = uniqueWarnings;
      }

      return { taskSpec, warnings: uniqueWarnings };
    };

  return {
    parseServerError,
    createRaceGuard,
    createPersistentState,
    normalizeSchemaErrors,
    computeBasicDeviations,
    validateTaskSpecSchema,
    sanitizeFilename,
    stringifyJson,
    proposeTaskSpecFromExport,
    inferTaskSpecFromExportSpec,
  };
})();

if (typeof module === "object" && typeof module.exports === "object") {
  module.exports = PluginUtils;
  module.exports.default = PluginUtils;
}

if (typeof window !== "undefined") {
  window.PluginUtils = PluginUtils;
}

if (typeof globalThis !== "undefined") {
  globalThis.PluginUtils = PluginUtils;
}

if (typeof exports === "object" && exports) {
  exports.default = PluginUtils;
}

</script>
    <script>
      if (!window.PluginUtils || typeof window.PluginUtils !== "object") {
        const errorContainer = document.createElement("div");
        errorContainer.style.fontFamily =
          "-apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Helvetica, Arial, sans-serif";
        errorContainer.style.margin = "16px";
        errorContainer.style.padding = "12px";
        errorContainer.style.border = "1px solid #dc2626";
        errorContainer.style.borderRadius = "8px";
        errorContainer.style.background = "#fef2f2";
        errorContainer.style.color = "#991b1b";
        errorContainer.style.fontSize = "12px";
        errorContainer.innerHTML =
          "<strong>Plugin utils module is unavailable.</strong><br />" +
          "Check that <code>plugin/utils.js</code> is packaged with the plugin and loaded before UI scripts.";
        document.body.innerHTML = "";
        document.body.appendChild(errorContainer);
        throw new Error("Plugin utils module is unavailable");
      }

      const {
        sanitizeFilename,
        stringifyJson,
        parseServerError,
        createRaceGuard,
        createPersistentState,
        normalizeSchemaErrors,
        inferTaskSpecFromExportSpec,
        validateTaskSpecSchema,
      } = window.PluginUtils;

      Object.entries({
        sanitizeFilename,
        stringifyJson,
        parseServerError,
        createRaceGuard,
        createPersistentState,
        normalizeSchemaErrors,
        inferTaskSpecFromExportSpec,
        validateTaskSpecSchema,
      }).forEach(([name, fn]) => {
        if (typeof fn !== "function") {
          throw new Error(`Plugin utils is missing required export: ${name}`);
        }
      });

      const RUNNER_SETTINGS_STORAGE_KEY = "plugin:runner-settings";
      const DEFAULT_RELAY_URL = "http://localhost:3000";
      function loadRunnerHost() {
        try {
          const raw = window.__storage.getItem(RUNNER_SETTINGS_STORAGE_KEY);
          const obj = raw ? JSON.parse(raw) : {};
          if (typeof obj.host === "string") {
            const normalized = obj.host.trim().replace(/\/+$/, "");
            if (normalized) {
              return normalized;
            }
          }
          return DEFAULT_RELAY_URL;
        } catch (_) {
          return DEFAULT_RELAY_URL;
        }
      }
      let relayBaseUrl = loadRunnerHost();
      const API_KEY_STORAGE_KEY = "relay:api-key";
      const RUNNER_DEFAULT_INTERVAL_SEC = 5;
      const RUNNER_BACKOFF_SEQUENCE_MS = [1000, 5000, 15000];
      const RUNNER_LOG_LIMIT = 120;
      const RUNNER_RESULT_LOG_LIMIT = 200;
      let RELAY_API_KEY = "";
      const getRelayBaseUrl = () => {
        const candidate = typeof relayBaseUrl === "string" ? relayBaseUrl.trim() : "";
        return candidate || DEFAULT_RELAY_URL;
      };
      let lastTaskId = null;
      let statusSource = null;
      let currentWatchTaskId = null;
      let statusLogs = [];
      const STATUS_LOG_LIMIT = 200;
      let pullModeEnabled = false;
      const runnerState = {
        enabled: false,
        pluginId: "",
        autoShare: false,
        pollTimer: null,
        processing: false,
        waitingFor: null,
        currentTaskId: null,
        currentSpecString: null,
        logs: [],
        status: "idle",
        progressLabel: "",
        shareInfo: null,
        lastError: null,
        host: relayBaseUrl,
        pollIntervalSec: RUNNER_DEFAULT_INTERVAL_SEC,
        backoffStep: 0,
        summary: null,
        warnings: [],
        hintMessage: null,
        timings: { startedAt: null, finishedAt: null, durationMs: null },
      };

      const RUNNER_NETWORK_HINT =
        "Relay is not reachable. Start it: npm run dev:relay (root) or cd relay && npm run dev";
      const RUNNER_AUTH_HINT =
        "Unauthorized (401). Check Relay Base URL and API key in Runner settings.";
      const RUNNER_PAYLOAD_HINT =
        "Result rejected (413). Reduce ExportSpec size or simplify the task.";

      const isNetworkConnectivityError = (message) => {
        if (!message) return false;
        const value = String(message).toLowerCase();
        return (
          value.includes("failed to fetch") ||
          value.includes("networkerror") ||
          value.includes("network error") ||
          value.includes("err_connection") ||
          value.includes("connection refused")
        );
      };

      const validateRequestGuard = createRaceGuard();

      const MAX_BUILD_LOG_LINES = 40;
      const MAX_EXPORT_LOG_LINES = 40;

      const VALIDATE_STATUS_LABELS = {
        idle: "Ожидание",
        valid: "Валидно",
        invalid: "Невалидно",
        error: "Ошибка",
      };
      const BUILD_STATUS_LABELS = {
        idle: "Ожидание",
        running: "Выполняется…",
        done: "Готово",
        error: "Ошибка",
      };
      const EXPORT_STATUS_LABELS = {
        idle: "Ожидание",
        running: "Выполняется…",
        done: "Готово",
        error: "Ошибка",
      };
      const IMPORT_STATUS_LABELS = {
        idle: "Ожидание",
        running: "Выполняется…",
        done: "Готово",
        error: "Ошибка",
      };

      const VALIDATOR_AUTH_HINT =
        "Валидатор недоступен без ключа. Запусти relay с API_KEYS=dev123 npm run dev --prefix relay или включи free-режим (API_FREE_ENDPOINTS=/validate/*).";

      const flowState = {
        import: {
          state: "idle",
          message: "Выделите один фрейм для импорта.",
          hint: "Ожидание выделения…",
          warnings: [],
          specString: null,
          downloadUrl: null,
          downloadFilename: "ExportSpec.selection.json",
          exportSpec: null,
          sections: [],
        },
        validate: {
          state: "idle",
          message: "",
          hint: "",
          errors: [],
          lastSpecString: null,
        },
        build: {
          state: "idle",
          message: "",
          summary: null,
          warnings: [],
          logs: [],
          lastSpecString: null,
        },
        export: {
          state: "idle",
          message: "",
          errors: [],
          logs: [],
          lastSpecString: null,
          downloadFilename: "ExportSpec.json",
          downloadUrl: null,
        },
      };

      const inflightOperations = {
        import: false,
        validate: false,
        build: false,
        export: false,
      };

      const operationContext = {
        importSpec: null,
        validateSpec: null,
        buildSpec: null,
        exportSpec: null,
      };

      let validateInProgress = false;
      let pendingInference = null;

      const selectionState = {
        count: 0,
        isSingleFrame: false,
        frameName: null,
        pageName: null,
        reason: "Выделите один фрейм для импорта.",
      };

      const buildRelayUrl = (path, { includeApiKey = false } = {}) => {
        const baseUrl = getRelayBaseUrl();
        try {
          const url = new URL(path, baseUrl);
          if (includeApiKey && RELAY_API_KEY) {
            url.searchParams.set("apiKey", RELAY_API_KEY);
          }
          return url.toString();
        } catch (err) {
          console.warn("Failed to build relay URL", err);
          return `${baseUrl}${path}`;
        }
      };

      const applyApiKeyToInit = (init = {}) => {
        const finalInit = init ? { ...init } : {};
        const headers = new Headers(init && init.headers ? init.headers : undefined);
        if (RELAY_API_KEY) {
          if (!headers.has("Authorization")) {
            headers.set("Authorization", `Bearer ${RELAY_API_KEY}`);
          }
          if (!headers.has("X-API-Key")) {
            headers.set("X-API-Key", RELAY_API_KEY);
          }
        }
        finalInit.headers = headers;
        return finalInit;
      };

      const relayFetch = (input, init = {}) => {
        try {
          return fetch(input, applyApiKeyToInit(init));
        } catch (err) {
          return Promise.reject(err);
        }
      };

      const artifactsPanelEl = document.getElementById("panel-artifacts");
      const tabButtons = Array.from(document.querySelectorAll(".tab-button"));
      const tabPanels = new Map(
        Array.from(document.querySelectorAll(".tab-panel")).map((panel) => [panel.id, panel])
      );

      const artifactsElements = {
        table: document.getElementById("artifacts-table"),
        tableBody: document.getElementById("artifacts-tbody"),
        searchInput: document.getElementById("artifacts-search"),
        orderSelect: document.getElementById("artifacts-order"),
        limitInput: document.getElementById("artifacts-limit"),
        prevButton: document.getElementById("artifacts-prev"),
        nextButton: document.getElementById("artifacts-next"),
        paginationInfo: document.getElementById("artifacts-pagination-info"),
        bulkButton: document.getElementById("artifacts-bulk-download"),
        compareButton: document.getElementById("artifacts-compare"),
        errorBox: document.getElementById("artifacts-error"),
        refreshButton: document.getElementById("artifacts-refresh"),
        emptyRefreshButton: document.getElementById("artifacts-empty-refresh"),
        emptyState: document.getElementById("artifacts-empty-state"),
      };

      const runnerElements = {
        toggle: document.getElementById("runner-toggle"),
        hostInput: document.getElementById("runner-host"),
        pluginIdInput: document.getElementById("runner-plugin-id"),
        autoShare: document.getElementById("runner-auto-share"),
        panel: document.getElementById("runner-panel"),
        status: document.getElementById("runner-status-text"),
        hint: document.getElementById("runner-status-hint"),
        task: document.getElementById("runner-task-id"),
        progress: document.getElementById("runner-progress"),
        log: document.getElementById("runner-log"),
        meta: document.getElementById("runner-meta"),
        startedAt: document.getElementById("runner-started-at"),
        finishedAt: document.getElementById("runner-finished-at"),
        duration: document.getElementById("runner-duration"),
        report: document.getElementById("runner-report"),
        summaryCreated: document.getElementById("runner-summary-created"),
        summaryUpdated: document.getElementById("runner-summary-updated"),
        summaryRemoved: document.getElementById("runner-summary-removed"),
        warnings: document.getElementById("runner-warnings"),
        shareContainer: document.getElementById("runner-share"),
        shareToken: document.getElementById("runner-share-token"),
        shareCopy: document.getElementById("runner-copy-share"),
        shareLink: document.getElementById("runner-share-link"),
        intervalInput: document.getElementById("runner-poll-interval"),
      };

      const artifactDetailsElements = {
        container: document.getElementById("artifact-details"),
        overlay: document.getElementById("artifact-details-overlay"),
        closeButton: document.getElementById("artifact-details-close"),
        toast: document.getElementById("artifact-details-toast"),
        loading: document.getElementById("artifact-details-loading"),
        error: document.getElementById("artifact-details-error"),
        content: document.getElementById("artifact-details-content"),
        taskId: document.getElementById("artifact-details-task-id"),
        created: document.getElementById("artifact-details-created"),
        status: document.getElementById("artifact-details-status"),
        jsonLink: document.getElementById("artifact-details-json"),
        zipLink: document.getElementById("artifact-details-zip"),
        copyIdButton: document.getElementById("artifact-details-copy-id"),
        copyExportButton: document.getElementById("artifact-details-copy-export"),
        rerunButton: document.getElementById("artifact-details-rerun"),
        previewSection: document.getElementById("artifact-details-preview-section"),
        previewImage: document.getElementById("artifact-details-preview-image"),
        previewDownload: document.getElementById("artifact-details-preview-download"),
        shareJsonButton: document.getElementById("artifact-details-share-json"),
        shareZipButton: document.getElementById("artifact-details-share-zip"),
        shareCopyLinkButton: document.getElementById("artifact-details-share-copy-link"),
        shareFeedback: document.getElementById("artifact-details-share-feedback"),
        shareSummary: document.getElementById("artifact-details-share-summary"),
        shareLink: document.getElementById("artifact-details-share-url"),
        shareCopyButton: document.getElementById("artifact-details-share-copy"),
        shareTtl: document.getElementById("artifact-details-share-ttl"),
        shareError: document.getElementById("artifact-details-share-error"),
        notice: document.getElementById("artifact-details-notice"),
        logs: document.getElementById("artifact-details-logs"),
        toggleLogs: document.getElementById("artifact-details-toggle-logs"),
        exportViewer: document.getElementById("artifact-details-export-viewer"),
        exportSearch: document.getElementById("artifact-details-export-search"),
      };

      const artifactCompareElements = {
        container: document.getElementById("artifact-compare"),
        overlay: document.getElementById("artifact-compare-overlay"),
        closeButton: document.getElementById("artifact-compare-close"),
        loading: document.getElementById("artifact-compare-loading"),
        error: document.getElementById("artifact-compare-error"),
        content: document.getElementById("artifact-compare-content"),
        leftId: document.getElementById("artifact-compare-left-id"),
        rightId: document.getElementById("artifact-compare-right-id"),
        swapButton: document.getElementById("artifact-compare-swap"),
        tabSummary: document.getElementById("artifact-compare-tab-summary"),
        tabChanges: document.getElementById("artifact-compare-tab-changes"),
        downloadButton: document.getElementById("artifact-compare-download"),
        downloadZipButton: document.getElementById("artifact-compare-download-zip"),
        exportHtmlButton: document.getElementById("artifact-compare-export-html"),
        summaryAdded: document.getElementById("artifact-compare-summary-added"),
        summaryRemoved: document.getElementById("artifact-compare-summary-removed"),
        summaryChanged: document.getElementById("artifact-compare-summary-changed"),
        summaryUnchanged: document.getElementById("artifact-compare-summary-unchanged"),
        summarySection: null,
        changesSection: null,
        searchInput: document.getElementById("artifact-compare-search"),
        emptyState: document.getElementById("artifact-compare-empty"),
        diffList: document.getElementById("artifact-compare-list"),
        visualSection: document.getElementById("artifact-compare-visual"),
        visualModeSide: document.getElementById("artifact-compare-visual-mode-side"),
        visualModeOverlay: document.getElementById("artifact-compare-visual-mode-overlay"),
        visualSideContainer: document.getElementById("artifact-compare-visual-side"),
        visualOverlayContainer: document.getElementById("artifact-compare-visual-overlay"),
        visualLeftImage: document.getElementById("artifact-compare-visual-left-image"),
        visualRightImage: document.getElementById("artifact-compare-visual-right-image"),
        overlayBaseImage: document.getElementById("artifact-compare-overlay-base"),
        overlayTopImage: document.getElementById("artifact-compare-overlay-top"),
        overlayForeground: document.getElementById("artifact-compare-overlay-foreground"),
        overlaySlider: document.getElementById("artifact-compare-overlay-slider"),
      };
      if (artifactCompareElements.container) {
        artifactCompareElements.summarySection =
          artifactCompareElements.container.querySelector('[data-tab-panel="summary"]');
        artifactCompareElements.changesSection =
          artifactCompareElements.container.querySelector('[data-tab-panel="changes"]');
      }

      const toastContainerEl = document.getElementById("toast-container");
      const activeToasts = new Set();
      const showToast = ({ message, type = "info", duration = 2800 } = {}) => {
        const normalized = typeof message === "string" ? message.trim() : "";
        if (!toastContainerEl || !normalized) return;
        const toast = document.createElement("div");
        toast.className = `toast toast--${type}`;
        toast.textContent = normalized;
        toastContainerEl.appendChild(toast);
        activeToasts.add(toast);
        const remove = () => {
          if (!activeToasts.has(toast)) return;
          activeToasts.delete(toast);
          if (toast.parentNode) {
            toast.parentNode.removeChild(toast);
          }
        };
        setTimeout(remove, Math.max(1200, Number(duration) || 2800));
      };

      const renderRunnerLogs = () => {
        if (!runnerElements.log) return;
        runnerElements.log.textContent = runnerState.logs.join("\n");
        runnerElements.log.scrollTop = runnerElements.log.scrollHeight;
      };

      const renderRunnerState = () => {
        if (runnerElements.panel) {
          const state = runnerState.processing
            ? runnerState.status || "running"
            : runnerState.enabled
              ? runnerState.status || "idle"
              : "idle";
          runnerElements.panel.dataset.state = state;
        }
        if (runnerElements.status) {
          if (runnerState.enabled || runnerState.processing) {
            runnerElements.status.textContent = runnerState.status || "idle";
          } else {
            runnerElements.status.textContent = "disabled";
          }
        }
        if (runnerElements.hint) {
          let hint = "";
          if (runnerState.hintMessage) {
            hint = runnerState.hintMessage;
          } else if (isNetworkConnectivityError(runnerState.lastError)) {
            hint = RUNNER_NETWORK_HINT;
          }
          runnerElements.hint.textContent = hint;
          runnerElements.hint.dataset.visible = hint ? "true" : "false";
        }
        if (runnerElements.task) {
          runnerElements.task.textContent = runnerState.currentTaskId || "—";
        }
        if (runnerElements.progress) {
          runnerElements.progress.textContent = runnerState.progressLabel || "";
        }
        if (runnerElements.meta) {
          const timings = runnerState.timings || {};
          const started = Number.isFinite(timings.startedAt) ? timings.startedAt : null;
          const finished = Number.isFinite(timings.finishedAt) ? timings.finishedAt : null;
          const duration = Number.isFinite(timings.durationMs)
            ? timings.durationMs
            : started != null && finished != null
              ? Math.max(0, finished - started)
              : null;
          const hasTiming = started != null || finished != null || duration != null;
          runnerElements.meta.dataset.visible = hasTiming ? "true" : "false";
          if (runnerElements.startedAt) {
            runnerElements.startedAt.textContent = started != null ? formatDateTime(started) : "—";
          }
          if (runnerElements.finishedAt) {
            runnerElements.finishedAt.textContent = finished != null ? formatDateTime(finished) : "—";
          }
          if (runnerElements.duration) {
            runnerElements.duration.textContent = duration != null ? formatDuration(duration) : "—";
          }
        }
        if (runnerElements.report) {
          const summary = runnerState.summary || null;
          const warnings = Array.isArray(runnerState.warnings) ? runnerState.warnings : [];
          const hasSummary =
            summary &&
            (Number.isFinite(summary.created) ||
              Number.isFinite(summary.updated) ||
              Number.isFinite(summary.removed));
          const visible = hasSummary || warnings.length > 0;
          runnerElements.report.dataset.visible = visible ? "true" : "false";
          if (runnerElements.summaryCreated) {
            runnerElements.summaryCreated.textContent = hasSummary
              ? String(Number(summary.created) || 0)
              : "0";
          }
          if (runnerElements.summaryUpdated) {
            runnerElements.summaryUpdated.textContent = hasSummary
              ? String(Number(summary.updated) || 0)
              : "0";
          }
          if (runnerElements.summaryRemoved) {
            runnerElements.summaryRemoved.textContent = hasSummary
              ? String(Number(summary.removed) || 0)
              : "0";
          }
          if (runnerElements.warnings) {
            renderWarnings(runnerElements.warnings, warnings);
          }
        }
        if (runnerElements.shareContainer) {
          const share = runnerState.shareInfo;
          const shareValue = share && (share.token || share.url);
          const hasShare = !!shareValue;
          runnerElements.shareContainer.dataset.visible = hasShare ? "true" : "false";
          if (runnerElements.shareToken) {
            runnerElements.shareToken.textContent = hasShare ? shareValue : "—";
          }
          if (runnerElements.shareLink) {
            if (hasShare && share && share.url) {
              runnerElements.shareLink.href = share.url;
              runnerElements.shareLink.setAttribute("aria-disabled", "false");
            } else {
              runnerElements.shareLink.href = "#";
              runnerElements.shareLink.setAttribute("aria-disabled", "true");
            }
          }
        }
        updateActionButtons();
      };

      const appendRunnerLog = (message) => {
        const normalized =
          typeof message === "string"
            ? message.trim()
            : message != null
              ? String(message)
              : "";
        if (!normalized) return;
        const timestamp = new Date().toISOString();
        runnerState.logs.push(`[${timestamp}] ${normalized}`);
        if (runnerState.logs.length > RUNNER_LOG_LIMIT) {
          runnerState.logs = runnerState.logs.slice(-RUNNER_LOG_LIMIT);
        }
        if (isNetworkConnectivityError(normalized)) {
          runnerState.lastError = normalized;
          runnerState.hintMessage = RUNNER_NETWORK_HINT;
          renderRunnerState();
        }
        renderRunnerLogs();
      };

      const clearRunnerLogs = () => {
        runnerState.logs = [];
        renderRunnerLogs();
      };

      const setRunnerStatus = (status, progressLabel) => {
        runnerState.status = status || "idle";
        if (typeof progressLabel === "string") {
          runnerState.progressLabel = progressLabel;
        }
        renderRunnerState();
      };

      const apiKeyInput = document.getElementById("api-key-input");
      const apiKeyClearButton = document.getElementById("api-key-clear");
      const storage = window.__storage || null;

      const artifactsPreferences = createPersistentState("plugin:artifacts-preferences", {
        storage,
      });

      const runnerPreferences = createPersistentState(RUNNER_SETTINGS_STORAGE_KEY, {
        storage,
        fallback: {
          pluginId: "",
          autoShare: false,
          enabled: false,
          host: DEFAULT_RELAY_URL,
          pollIntervalSec: RUNNER_DEFAULT_INTERVAL_SEC,
        },
      });

      const persistRunnerSettings = () => {
        const normalizedHost = getRelayBaseUrl();
        const intervalSeconds = Number(runnerState.pollIntervalSec);
        const safeInterval = Number.isFinite(intervalSeconds) && intervalSeconds >= 1
          ? Math.floor(intervalSeconds)
          : RUNNER_DEFAULT_INTERVAL_SEC;
        runnerPreferences.write({
          pluginId: runnerState.pluginId,
          autoShare: !!runnerState.autoShare,
          enabled: !!runnerState.enabled,
          host: normalizedHost,
          pollIntervalSec: safeInterval,
        });
      };

      const getRunnerPluginId = () => (runnerState.pluginId || "").trim();

      const clearRunnerTimer = () => {
        if (runnerState.pollTimer) {
          clearTimeout(runnerState.pollTimer);
          runnerState.pollTimer = null;
        }
      };

      const getRunnerPollIntervalMs = () => {
        const seconds = Number(runnerState.pollIntervalSec);
        if (!Number.isFinite(seconds) || seconds < 1) {
          return RUNNER_DEFAULT_INTERVAL_SEC * 1000;
        }
        return Math.floor(seconds) * 1000;
      };

      const scheduleRunnerPoll = (delay = null, options = {}) => {
        if (!runnerState.enabled) return;
        const { useBackoff = false } = options;
        clearRunnerTimer();
        let nextDelay;
        if (useBackoff) {
          const nextStep = Math.min(runnerState.backoffStep + 1, RUNNER_BACKOFF_SEQUENCE_MS.length - 1);
          runnerState.backoffStep = nextStep;
          nextDelay = RUNNER_BACKOFF_SEQUENCE_MS[nextStep];
        } else {
          runnerState.backoffStep = 0;
          if (typeof delay === "number" && delay >= 0) {
            nextDelay = delay;
          } else {
            nextDelay = getRunnerPollIntervalMs();
          }
        }
        runnerState.pollTimer = setTimeout(() => {
          runnerState.pollTimer = null;
          runRunnerPoll().catch((err) => {
            const message = err && err.message ? err.message : String(err);
            runnerState.lastError = message;
            runnerState.hintMessage = null;
            renderRunnerState();
            appendRunnerLog(`Poll error: ${message}`);
            setRunnerStatus("error", "poll failed");
            if (runnerState.enabled && !runnerState.processing) {
              scheduleRunnerPoll(null, { useBackoff: true });
            }
          });
        }, Math.max(0, nextDelay));
      };

      const ensureRunnerSpecString = (taskSpec) => {
        if (typeof taskSpec === "string") {
          return taskSpec;
        }
        if (taskSpec == null) return null;
        try {
          return JSON.stringify(taskSpec, null, 2);
        } catch (err) {
          console.warn("Failed to stringify taskSpec", err);
          return null;
        }
      };

      const buildRunnerResultLogs = (buildLogs, exportLogs) => {
        const normalized = [];
        const append = (entries, prefix) => {
          if (!Array.isArray(entries)) return;
          entries.forEach((entry) => {
            if (entry == null) return;
            let message = "";
            if (typeof entry === "string") {
              message = entry;
            } else {
              try {
                message = JSON.stringify(entry);
              } catch (_) {
                message = String(entry);
              }
            }
            const trimmed = message.trim();
            if (!trimmed) return;
            normalized.push(prefix ? `[${prefix}] ${trimmed}` : trimmed);
          });
        };
        append(buildLogs, "build");
        append(exportLogs, "export");
        if (normalized.length > RUNNER_RESULT_LOG_LIMIT) {
          return normalized.slice(-RUNNER_RESULT_LOG_LIMIT);
        }
        return normalized;
      };

      const refreshRunnerTaskInfo = async (taskId) => {
        if (!taskId) return;
        try {
          const res = await relayFetch(buildRelayUrl(`/tasks/${taskId}`));
          if (!res.ok) return;
          const data = await res.json();
          if (!data) return;
          if (Number.isFinite(data.startedAt)) {
            runnerState.timings.startedAt = data.startedAt;
          }
          if (Number.isFinite(data.finishedAt)) {
            runnerState.timings.finishedAt = data.finishedAt;
            if (Number.isFinite(runnerState.timings.startedAt)) {
              runnerState.timings.durationMs = Math.max(0, data.finishedAt - runnerState.timings.startedAt);
            }
          }
          const summarySource =
            data.result && typeof data.result === "object" && data.result.summary && typeof data.result.summary === "object"
              ? data.result.summary
              : data.summary && typeof data.summary === "object"
                ? data.summary
                : null;
          if (summarySource) {
            runnerState.summary = {
              created: Number(summarySource.created) || 0,
              updated: Number(summarySource.updated) || 0,
              removed: Number(summarySource.removed) || 0,
            };
          }
          if (
            data.result &&
            typeof data.result === "object" &&
            Array.isArray(data.result.warnings)
          ) {
            runnerState.warnings = data.result.warnings;
          }
        } catch (err) {
          console.warn("Runner task info refresh failed", err);
        } finally {
          renderRunnerState();
        }
      };

      const runnerPostLog = async (taskId, message) => {
        if (!taskId || !message) return false;
        try {
          const response = await relayFetch(buildRelayUrl(`/tasks/${taskId}/log`), {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify({ message }),
          });
          if (!response.ok) {
            const text = await response.text();
            appendRunnerLog(
              `Log append failed (HTTP ${response.status}${text ? `: ${text.trim()}` : ""})`,
            );
            return false;
          }
          return true;
        } catch (err) {
          appendRunnerLog(
            `Log append error: ${err && err.message ? err.message : String(err)}`,
          );
          return false;
        }
      };

      const runnerShareTask = async (taskId) => {
        if (!taskId) return null;
        try {
          const res = await relayFetch(buildRelayUrl(`/tasks/${taskId}/share`), {
            method: "POST",
            headers: { "Content-Type": "application/json" },
          });
          if (!res.ok) {
            const text = await res.text();
            appendRunnerLog(
              `Share failed (HTTP ${res.status}${text ? `: ${text.trim()}` : ""})`,
            );
            return null;
          }
          const data = await res.json();
          appendRunnerLog("Share token generated");
          return data;
        } catch (err) {
          appendRunnerLog(
            `Share error: ${err && err.message ? err.message : String(err)}`,
          );
          return null;
        }
      };

      const finalizeRunnerSuccess = async () => {
        const taskId = runnerState.currentTaskId;
        await runnerPostLog(taskId, "Runner: done");
        if (runnerState.autoShare) {
          const share = await runnerShareTask(taskId);
          if (share) {
            runnerState.shareInfo = share;
          }
        }
        runnerState.processing = false;
        runnerState.waitingFor = null;
        runnerState.lastError = null;
        runnerState.hintMessage = null;
        const finishedAt = Date.now();
        if (!Number.isFinite(runnerState.timings.startedAt)) {
          runnerState.timings.startedAt = finishedAt;
        }
        runnerState.timings.finishedAt = finishedAt;
        if (Number.isFinite(runnerState.timings.startedAt)) {
          runnerState.timings.durationMs = Math.max(0, finishedAt - runnerState.timings.startedAt);
        }
        setRunnerStatus("success", "done");
        renderRunnerState();
        await refreshRunnerTaskInfo(taskId);
        if (runnerState.enabled) {
          scheduleRunnerPoll(1500);
        }
      };

      const finalizeRunnerFailure = async (reason) => {
        const taskId = runnerState.currentTaskId;
        if (taskId) {
          await runnerPostLog(taskId, `Runner: error — ${reason || "unknown"}`);
        }
        runnerState.processing = false;
        runnerState.waitingFor = null;
        runnerState.lastError = reason || "Runner error";
        const finishedAt = Date.now();
        if (!Number.isFinite(runnerState.timings.startedAt)) {
          runnerState.timings.startedAt = finishedAt;
        }
        runnerState.timings.finishedAt = finishedAt;
        if (Number.isFinite(runnerState.timings.startedAt)) {
          runnerState.timings.durationMs = Math.max(0, finishedAt - runnerState.timings.startedAt);
        }
        setRunnerStatus("error", runnerState.lastError);
        renderRunnerState();
        await refreshRunnerTaskInfo(taskId);
        if (runnerState.enabled) {
          scheduleRunnerPoll(null, { useBackoff: true });
        }
      };

      const beginRunnerTask = async (taskId, taskSpec) => {
        runnerState.processing = true;
        runnerState.currentTaskId = taskId;
        runnerState.currentSpecString = ensureRunnerSpecString(taskSpec);
        runnerState.waitingFor = "build";
        runnerState.shareInfo = null;
        runnerState.lastError = null;
        runnerState.hintMessage = null;
        runnerState.summary = null;
        runnerState.warnings = [];
        runnerState.timings = { startedAt: Date.now(), finishedAt: null, durationMs: null };
        clearRunnerLogs();
        appendRunnerLog(`Pulled task ${taskId}`);
        if (!runnerState.currentSpecString) {
          appendRunnerLog("Invalid TaskSpec payload");
          await finalizeRunnerFailure("Invalid TaskSpec");
          return;
        }
        lastTaskId = taskId;
        updateArtifactLinks();
        setTaskSpecTextarea(runnerState.currentSpecString);
        setRunnerStatus("running", "build");
        await runnerPostLog(taskId, "Runner: start");
        appendRunnerLog("Running build…");
        triggerBuild(runnerState.currentSpecString, {
          source: "runner",
          skipValidationCheck: true,
        });
      };

      async function runRunnerPoll() {
        if (!runnerState.enabled || runnerState.processing) return;
        const pluginId = getRunnerPluginId();
        if (!pluginId) {
          showToast({ message: "Runner plugin ID is required", type: "error" });
          appendRunnerLog("Runner disabled — missing plugin ID");
          if (runnerElements.toggle) {
            runnerElements.toggle.checked = false;
          }
          runnerState.enabled = false;
          persistRunnerSettings();
          clearRunnerTimer();
          renderRunnerState();
          return;
        }
        setRunnerStatus("polling", "pulling…");
        try {
          const url = new URL(buildRelayUrl(`/tasks/pull`));
          url.searchParams.set("pluginId", pluginId);
          url.searchParams.set("limit", "1");
          const res = await relayFetch(url.toString());
          if (res.status === 204) {
            runnerState.lastError = null;
            runnerState.hintMessage = null;
            setRunnerStatus("polling", "no tasks");
            return;
          }
          if (!res.ok) {
            const text = await res.text();
            appendRunnerLog(
              `Pull failed (HTTP ${res.status}${text ? `: ${text.trim()}` : ""})`,
            );
            runnerState.lastError = `HTTP ${res.status}`;
            if (res.status === 401) {
              runnerState.hintMessage = RUNNER_AUTH_HINT;
            } else {
              runnerState.hintMessage = null;
            }
            renderRunnerState();
            setRunnerStatus("error", "pull failed");
            return;
          }
          const data = await res.json();
          runnerState.lastError = null;
          runnerState.hintMessage = null;
          renderRunnerState();
          const items = data && Array.isArray(data.items) ? data.items : [];
          const firstItem = items.length > 0 ? items[0] : data;
          const taskId = firstItem && (firstItem.taskId || firstItem.id);
          const taskSpec = firstItem ? firstItem.taskSpec ?? firstItem.spec ?? null : null;
          const pulledCount = Number.isFinite(data && data.pulled) ? data.pulled : null;
          const remainingCount = Number.isFinite(data && data.remaining) ? data.remaining : null;
          if (pulledCount != null) {
            const remainingLabel = remainingCount != null ? `, remaining ${remainingCount}` : "";
            appendRunnerLog(`Pull stats: pulled ${pulledCount}${remainingLabel}`);
          }
          if (!taskId || taskSpec == null) {
            setRunnerStatus("polling", "no tasks");
            return;
          }
          await beginRunnerTask(taskId, taskSpec);
        } catch (err) {
          const message = err && err.message ? err.message : String(err);
          runnerState.lastError = message;
          runnerState.hintMessage = null;
          renderRunnerState();
          appendRunnerLog(`Pull error: ${message}`);
          setRunnerStatus("error", "pull failed");
        } finally {
          if (runnerState.enabled && !runnerState.processing) {
            scheduleRunnerPoll();
          }
        }
      }

      const setRunnerEnabled = (enabled) => {
        if (enabled === runnerState.enabled) return;
        if (enabled) {
          if (!RELAY_API_KEY) {
            showToast({ message: "API key is required for runner", type: "error" });
            if (runnerElements.toggle) runnerElements.toggle.checked = false;
            return;
          }
          if (!getRunnerPluginId()) {
            showToast({ message: "Plugin ID is required", type: "error" });
            if (runnerElements.toggle) runnerElements.toggle.checked = false;
            return;
          }
          runnerState.enabled = true;
          runnerState.lastError = null;
          runnerState.hintMessage = null;
          persistRunnerSettings();
          appendRunnerLog("Runner enabled");
          if (!runnerState.processing) {
            setRunnerStatus("polling", "waiting…");
            scheduleRunnerPoll(0);
          }
        } else {
          runnerState.enabled = false;
          persistRunnerSettings();
          clearRunnerTimer();
          runnerState.hintMessage = null;
          if (!runnerState.processing) {
            setRunnerStatus("idle", "");
          } else {
            appendRunnerLog("Runner disabled — finishing current task");
          }
        }
        renderRunnerState();
      };

      const persistApiKey = (value) => {
        if (!storage) return;
        if (value) {
          storage.setItem(API_KEY_STORAGE_KEY, value);
        } else {
          storage.removeItem(API_KEY_STORAGE_KEY);
        }
      };

      const loadStoredApiKey = () => {
        if (!storage) return "";
        try {
          return storage.getItem(API_KEY_STORAGE_KEY) || "";
        } catch (err) {
          console.warn("Failed to read API key from storage", err);
          return "";
        }
      };

      const applyApiKeyChange = (value) => {
        const normalized = typeof value === "string" ? value.trim() : "";
        if (normalized === RELAY_API_KEY) {
          return;
        }
        RELAY_API_KEY = normalized;
        persistApiKey(normalized);
        updateArtifactLinks();
        renderArtifactDetails();
        renderArtifactCompare();
        if (currentWatchTaskId) {
          if (normalized) {
            openTaskWatch(currentWatchTaskId);
          } else {
            closeStatusSource();
          }
        }
      };

      const applyRunnerHostChange = (value) => {
        const inputValue = typeof value === "string" ? value.trim() : "";
        const sanitized = inputValue.replace(/\/+$/, "");
        const nextHost = sanitized || DEFAULT_RELAY_URL;
        if (runnerState.host === nextHost && relayBaseUrl === nextHost) {
          if (runnerElements.hostInput && runnerElements.hostInput.value !== nextHost) {
            runnerElements.hostInput.value = nextHost;
          }
          return;
        }
        relayBaseUrl = nextHost;
        runnerState.host = nextHost;
        runnerState.lastError = null;
        runnerState.hintMessage = null;
        persistRunnerSettings();
        if (runnerElements.hostInput && runnerElements.hostInput.value !== nextHost) {
          runnerElements.hostInput.value = nextHost;
        }
        updateArtifactLinks();
        renderArtifactDetails();
        renderArtifactCompare();
        if (statusSource) {
          closeStatusSource();
          if (currentWatchTaskId) {
            openTaskWatch(currentWatchTaskId);
          }
        }
        if (runnerState.enabled && !runnerState.processing) {
          scheduleRunnerPoll(0);
        }
        renderRunnerState();
      };

      const applyRunnerIntervalChange = (value) => {
        const num = Number(value);
        const next = Number.isFinite(num) && num >= 1 ? Math.floor(num) : RUNNER_DEFAULT_INTERVAL_SEC;
        if (runnerState.pollIntervalSec === next) {
          if (runnerElements.intervalInput && runnerElements.intervalInput.value !== String(next)) {
            runnerElements.intervalInput.value = String(next);
          }
          return;
        }
        runnerState.pollIntervalSec = next;
        if (runnerElements.intervalInput && runnerElements.intervalInput.value !== String(next)) {
          runnerElements.intervalInput.value = String(next);
        }
        persistRunnerSettings();
        if (runnerState.enabled && !runnerState.processing) {
          scheduleRunnerPoll();
        }
      };

      const storedKey = loadStoredApiKey();
      if (storedKey) {
        RELAY_API_KEY = storedKey;
      }
      if (apiKeyInput) {
        apiKeyInput.value = RELAY_API_KEY;
        apiKeyInput.addEventListener("input", (event) => {
          applyApiKeyChange(event.target.value || "");
        });
      }
      if (apiKeyClearButton) {
        apiKeyClearButton.addEventListener("click", () => {
          if (apiKeyInput) {
            apiKeyInput.value = "";
          }
          applyApiKeyChange("");
        });
      }

      const storedRunnerSettings =
        runnerPreferences.read({
          pluginId: "",
          autoShare: false,
          enabled: false,
          host: DEFAULT_RELAY_URL,
          pollIntervalSec: RUNNER_DEFAULT_INTERVAL_SEC,
        }) || {};
      if (typeof storedRunnerSettings.pluginId === "string") {
        runnerState.pluginId = storedRunnerSettings.pluginId;
      }
      runnerState.autoShare = !!storedRunnerSettings.autoShare;
      if (typeof storedRunnerSettings.host === "string") {
        const normalizedHost = storedRunnerSettings.host.trim().replace(/\/+$/, "");
        if (normalizedHost) {
          runnerState.host = normalizedHost;
        }
      }
      if (Number.isFinite(storedRunnerSettings.pollIntervalSec)) {
        const sanitized = Math.max(1, Math.floor(storedRunnerSettings.pollIntervalSec));
        runnerState.pollIntervalSec = sanitized;
      }
      relayBaseUrl = runnerState.host || DEFAULT_RELAY_URL;
      runnerState.host = relayBaseUrl;
      const runnerAutoEnable = !!storedRunnerSettings.enabled;
      renderRunnerLogs();
      renderRunnerState();
      if (runnerElements.hostInput) {
        runnerElements.hostInput.value = runnerState.host;
        const handleHostChange = (event) => {
          applyRunnerHostChange(event.target.value || "");
        };
        runnerElements.hostInput.addEventListener("change", handleHostChange);
        runnerElements.hostInput.addEventListener("blur", handleHostChange);
      }
      if (runnerElements.pluginIdInput) {
        runnerElements.pluginIdInput.value = runnerState.pluginId;
        runnerElements.pluginIdInput.addEventListener("input", (event) => {
          runnerState.pluginId = (event.target.value || "").trim();
          persistRunnerSettings();
        });
      }
      if (runnerElements.autoShare) {
        runnerElements.autoShare.checked = runnerState.autoShare;
        runnerElements.autoShare.addEventListener("change", (event) => {
          runnerState.autoShare = !!event.target.checked;
          persistRunnerSettings();
        });
      }
      if (runnerElements.intervalInput) {
        runnerElements.intervalInput.value = String(runnerState.pollIntervalSec);
        runnerElements.intervalInput.addEventListener("change", (event) => {
          applyRunnerIntervalChange(event.target.value || "");
        });
        runnerElements.intervalInput.addEventListener("blur", (event) => {
          applyRunnerIntervalChange(event.target.value || "");
        });
      }
      if (runnerElements.shareCopy) {
        runnerElements.shareCopy.addEventListener("click", async () => {
          const share = runnerState.shareInfo;
          if (!share) return;
          const value = share.token || share.url;
          if (!value) return;
          const ok = await copyTextToClipboard(value);
          showToast({
            message: ok ? (share.token ? "Share token copied" : "Share link copied") : "Copy failed",
            type: ok ? "success" : "error",
          });
        });
      }
      if (runnerElements.toggle) {
        runnerElements.toggle.checked = runnerAutoEnable;
        runnerElements.toggle.addEventListener("change", (event) => {
          setRunnerEnabled(!!event.target.checked);
        });
      }
      if (runnerAutoEnable && getRunnerPluginId() && RELAY_API_KEY) {
        setRunnerEnabled(true);
        if (runnerElements.toggle) {
          runnerElements.toggle.checked = runnerState.enabled;
        }
      } else if (!runnerAutoEnable && runnerElements.toggle) {
        runnerElements.toggle.checked = false;
      }

      const artifactDetailsState = {
        open: false,
        loading: false,
        taskId: null,
        task: null,
        result: null,
        logs: [],
        logsPaused: false,
        pendingLogCount: 0,
        exportSpec: null,
        exportSearch: "",
        notice: null,
        toast: "",
        rerunPending: false,
        error: "",
        share: { info: null, pendingType: null, error: "" },
        hasPreview: false,
        previewUrl: null,
        previewUpdatedAt: null,
        progress: null,
        requestId: 0,
      };

      const artifactCompareState = {
        open: false,
        loading: false,
        leftId: null,
        rightId: null,
        summary: { added: 0, removed: 0, changed: 0, unchanged: 0 },
        diff: [],
        response: null,
        searchTerm: "",
        activeTab: "summary",
        mode: "full",
        leftPreview: { hasPreview: false, previewUpdatedAt: null },
        rightPreview: { hasPreview: false, previewUpdatedAt: null },
        visualMode: "side-by-side",
        overlayPosition: 50,
        error: "",
      };

      let artifactDetailsToastTimer = null;
      let artifactDetailsRenderedLogs = "";

      const artifactsState = {
        order: "desc",
        limit: 10,
        offset: 0,
        total: 0,
        items: [],
        searchTerm: "",
        searchValue: "",
        selection: new Set(),
        loading: false,
        initialized: false,
        lastUserRefresh: 0,
      };

      const storedArtifactPreferences =
        artifactsPreferences.read({ order: "desc", limit: 10, search: "" }) || {};
      artifactsState.order = storedArtifactPreferences.order === "asc" ? "asc" : "desc";
      const storedLimit = Number(storedArtifactPreferences.limit);
      if (Number.isFinite(storedLimit) && storedLimit >= 1 && storedLimit <= 50) {
        artifactsState.limit = Math.floor(storedLimit);
      }
      const storedSearchRaw =
        typeof storedArtifactPreferences.search === "string"
          ? storedArtifactPreferences.search
          : "";
      artifactsState.searchValue = storedSearchRaw;
      artifactsState.searchTerm = storedSearchRaw.toLowerCase();

      const persistArtifactsPreferences = () => {
        artifactsPreferences.write({
          order: artifactsState.order,
          limit: artifactsState.limit,
          search: artifactsState.searchValue || "",
        });
      };

      const artifactsFetchGuard = createRaceGuard();
      const artifactDetailsGuard = createRaceGuard();
      const compareFetchGuard = createRaceGuard();

      const setArtifactsError = (message) => {
        if (!artifactsElements.errorBox) return;
        if (message) {
          artifactsElements.errorBox.textContent = message;
          artifactsElements.errorBox.style.display = "block";
        } else {
          artifactsElements.errorBox.textContent = "";
          artifactsElements.errorBox.style.display = "none";
        }
      };

      const formatBytes = (bytes) => {
        const value = Number(bytes);
        if (!Number.isFinite(value) || value < 0) return "—";
        if (value === 0) return "0 B";
        const units = ["B", "KB", "MB", "GB", "TB"];
        const exponent = Math.min(Math.floor(Math.log(value) / Math.log(1024)), units.length - 1);
        const normalized = value / Math.pow(1024, exponent);
        const formatted = exponent === 0 ? normalized.toFixed(0) : normalized.toFixed(1);
        return `${formatted} ${units[exponent]}`;
      };

      const formatDateTime = (value) => {
        if (!Number.isFinite(value)) return "—";
        const date = new Date(value);
        if (Number.isNaN(date.getTime())) return "—";
        return date.toLocaleString();
      };

      const formatDuration = (ms) => {
        const value = Number(ms);
        if (!Number.isFinite(value) || value < 0) return "—";
        if (value < 1000) {
          return `${value} ms`;
        }
        const seconds = Math.floor(value / 1000);
        const mins = Math.floor(seconds / 60);
        const hrs = Math.floor(mins / 60);
        const remainingSeconds = seconds % 60;
        const remainingMins = mins % 60;
        const parts = [];
        if (hrs > 0) parts.push(`${hrs}h`);
        if (hrs > 0 || remainingMins > 0) parts.push(`${remainingMins}m`);
        parts.push(`${remainingSeconds}s`);
        return parts.join(" ");
      };

      const formatShareSummary = (type) => {
        return type === "json" ? "Public JSON link" : "Public ZIP link";
      };

      const formatShareTtl = (expiresAt) => {
        if (!Number.isFinite(expiresAt)) return "";
        const now = Date.now();
        const diffMs = expiresAt - now;
        if (diffMs <= 0) return "Expired";
        const minutes = Math.floor(diffMs / 60000);
        const seconds = Math.floor((diffMs % 60000) / 1000);
        let remaining = "";
        if (minutes >= 1) {
          const minuteLabel = `${minutes} min${minutes === 1 ? "" : "s"}`;
          if (minutes < 5 && seconds > 0) {
            remaining = `${minuteLabel} ${seconds} sec`;
          } else {
            remaining = minuteLabel;
          }
        } else {
          remaining = `${Math.max(seconds, 1)} sec`;
        }
        return `${remaining} left (until ${formatDateTime(expiresAt)})`;
      };

      const getArtifactPreviewInfo = (id) => {
        if (typeof id !== "string" || !id) {
          return { hasPreview: false, previewUpdatedAt: null };
        }
        const item = artifactsState.items.find((entry) => entry && entry.id === id);
        if (!item) {
          return { hasPreview: false, previewUpdatedAt: null };
        }
        return {
          hasPreview: !!item.hasPreview,
          previewUpdatedAt: Number.isFinite(item.previewUpdatedAt)
            ? Number(item.previewUpdatedAt)
            : null,
        };
      };

      const buildComparePreviewUrl = (taskId, updatedAt) => {
        if (!taskId) return null;
        let url = buildRelayUrl(`/tasks/${encodeURIComponent(taskId)}/preview.png`, {
          includeApiKey: !!RELAY_API_KEY,
        });
        if (Number.isFinite(updatedAt)) {
          const version = Math.floor(updatedAt);
          url += url.includes("?") ? `&v=${version}` : `?v=${version}`;
        }
        return url;
      };

      const copyTextToClipboard = async (text) => {
        if (typeof text !== "string") return false;
        try {
          if (navigator.clipboard && navigator.clipboard.writeText) {
            await navigator.clipboard.writeText(text);
            return true;
          }
        } catch (_) {}
        try {
          const textarea = document.createElement("textarea");
          textarea.value = text;
          textarea.setAttribute("readonly", "true");
          textarea.style.position = "fixed";
          textarea.style.opacity = "0";
          textarea.style.pointerEvents = "none";
          document.body.appendChild(textarea);
          textarea.select();
          const ok = document.execCommand("copy");
          document.body.removeChild(textarea);
          return ok;
        } catch (_) {
          return false;
        }
      };

      const scheduleDomUpdate = (callback) => {
        if (typeof callback !== "function") return;
        if (typeof requestAnimationFrame === "function") {
          requestAnimationFrame(callback);
        } else {
          callback();
        }
      };

      const lazyPreviewObserver =
        typeof IntersectionObserver === "function"
          ? new IntersectionObserver(
              (entries, observer) => {
                for (const entry of entries) {
                  if (!entry.isIntersecting) continue;
                  const target = entry.target;
                  const src = target && target.dataset ? target.dataset.src : null;
                  if (target && src) {
                    target.src = src;
                    delete target.dataset.src;
                  }
                  if (observer && target) {
                    observer.unobserve(target);
                  }
                }
              },
              { rootMargin: "120px 0px" },
            )
          : null;

      const registerLazyPreview = (img, url) => {
        if (!img) return;
        if (!url) {
          img.removeAttribute("data-src");
          return;
        }
        if (lazyPreviewObserver) {
          img.dataset.src = url;
          img.removeAttribute("src");
          lazyPreviewObserver.observe(img);
        } else {
          img.src = url;
        }
      };

      const formatJsonPrimitive = (value) => {
        if (value === null) return "null";
        if (value === undefined) return "undefined";
        if (typeof value === "string") {
          return JSON.stringify(value);
        }
        if (typeof value === "number" || typeof value === "bigint") {
          return String(value);
        }
        if (typeof value === "boolean") {
          return value ? "true" : "false";
        }
        try {
          return JSON.stringify(value);
        } catch (_) {
          return String(value);
        }
      };

      const createSummaryLabel = (key, value) => {
        const isArray = Array.isArray(value);
        const size = isArray
          ? value.length
          : value && typeof value === "object"
          ? Object.keys(value).length
          : 0;
        const baseLabel = isArray
          ? `Array (${size} ${size === 1 ? "item" : "items"})`
          : `Object (${size} ${size === 1 ? "key" : "keys"})`;
        if (key == null) {
          return baseLabel;
        }
        return `${key}: ${baseLabel}`;
      };

      const createHighlightedFragment = (text, search) => {
        const fragment = document.createDocumentFragment();
        const value = String(text ?? "");
        if (!search || !search.normalized) {
          fragment.appendChild(document.createTextNode(value));
          return fragment;
        }
        const lower = value.toLowerCase();
        const needle = search.normalized;
        let index = lower.indexOf(needle);
        if (index === -1) {
          fragment.appendChild(document.createTextNode(value));
          return fragment;
        }
        const length = search.raw.length;
        let start = 0;
        while (index !== -1) {
          if (index > start) {
            fragment.appendChild(document.createTextNode(value.slice(start, index)));
          }
          const mark = document.createElement("mark");
          mark.textContent = value.slice(index, index + length);
          fragment.appendChild(mark);
          start = index + length;
          index = lower.indexOf(needle, start);
        }
        if (start < value.length) {
          fragment.appendChild(document.createTextNode(value.slice(start)));
        }
        return fragment;
      };

      const buildJsonViewerNode = (key, value, search, depth = 0) => {
        const container = document.createElement("div");
        container.className = "json-node";
        const searchActive = !!(search && search.normalized);
        container.dataset.searchActive = searchActive ? "true" : "false";

        if (value instanceof Date) {
          return buildJsonViewerNode(key, value.toISOString(), search, depth + 1);
        }

        if (Array.isArray(value)) {
          const details = document.createElement("details");
          const summary = document.createElement("summary");
          const label = createSummaryLabel(key, value);
          summary.appendChild(createHighlightedFragment(label, search));
          details.appendChild(summary);

          const childrenWrapper = document.createElement("div");
          childrenWrapper.className = "json-children";
          let hasMatch = searchActive && label.toLowerCase().includes(search.normalized);
          if (value.length === 0) {
            const empty = document.createElement("div");
            empty.className = "artifact-details__empty";
            empty.textContent = "[]";
            childrenWrapper.appendChild(empty);
          } else {
            value.forEach((item, index) => {
              const childKey = `[${index}]`;
              const { element, hasMatch: childMatch } = buildJsonViewerNode(
                childKey,
                item,
                search,
                depth + 1,
              );
              if (childMatch) hasMatch = true;
              childrenWrapper.appendChild(element);
            });
          }
          details.appendChild(childrenWrapper);
          details.open = !searchActive && depth <= 0 ? true : hasMatch;
          container.dataset.hasMatch = hasMatch ? "true" : "false";
          container.appendChild(details);
          return { element: container, hasMatch };
        }

        if (value && typeof value === "object") {
          const details = document.createElement("details");
          const summary = document.createElement("summary");
          const label = createSummaryLabel(key, value);
          summary.appendChild(createHighlightedFragment(label, search));
          details.appendChild(summary);

          const childrenWrapper = document.createElement("div");
          childrenWrapper.className = "json-children";
          let hasMatch = searchActive && label.toLowerCase().includes(search.normalized);
          const entries = Object.entries(value);
          if (entries.length === 0) {
            const empty = document.createElement("div");
            empty.className = "artifact-details__empty";
            empty.textContent = "{}";
            childrenWrapper.appendChild(empty);
          } else {
            for (const [childKey, childValue] of entries) {
              const { element, hasMatch: childMatch } = buildJsonViewerNode(
                childKey,
                childValue,
                search,
                depth + 1,
              );
              if (childMatch) hasMatch = true;
              childrenWrapper.appendChild(element);
            }
          }
          details.appendChild(childrenWrapper);
          details.open = !searchActive && depth <= 0 ? true : hasMatch;
          container.dataset.hasMatch = hasMatch ? "true" : "false";
          container.appendChild(details);
          return { element: container, hasMatch };
        }

        const leaf = document.createElement("div");
        leaf.className = "json-leaf";
        let hasMatch = false;
        if (key != null) {
          const keyLabel = String(key);
          const keySpan = document.createElement("span");
          keySpan.className = "json-key";
          keySpan.appendChild(createHighlightedFragment(keyLabel, search));
          leaf.appendChild(keySpan);
          leaf.appendChild(document.createTextNode(": "));
          if (searchActive && keyLabel.toLowerCase().includes(search.normalized)) {
            hasMatch = true;
          }
        }
        const valueText = formatJsonPrimitive(value);
        const valueType = value === null ? "null" : value === undefined ? "undefined" : typeof value;
        const valueSpan = document.createElement("span");
        valueSpan.className = `json-value json-value-${valueType}`;
        valueSpan.appendChild(createHighlightedFragment(valueText, search));
        if (searchActive && valueText.toLowerCase().includes(search.normalized)) {
          hasMatch = true;
        }
        leaf.appendChild(valueSpan);
        container.dataset.hasMatch = hasMatch ? "true" : "false";
        container.appendChild(leaf);
        return { element: container, hasMatch };
      };

      const renderArtifactDetailsLogs = () => {
        const target = artifactDetailsElements.logs;
        if (!target) return;
        if (artifactDetailsState.loading) {
          target.dataset.empty = "true";
          target.textContent = "Loading logs…";
          return;
        }
        if (artifactDetailsState.error) {
          target.dataset.empty = "true";
          target.textContent = "—";
          return;
        }
        const logs = Array.isArray(artifactDetailsState.logs)
          ? artifactDetailsState.logs.map((line) => String(line))
          : [];
        if (artifactDetailsState.logsPaused) {
          const snapshot = artifactDetailsRenderedLogs || logs.join("\n");
          if (snapshot) {
            target.dataset.empty = "false";
            const suffix =
              artifactDetailsState.pendingLogCount > 0
                ? `\n\n[Logs paused – ${artifactDetailsState.pendingLogCount} new entries]`
                : "\n\n[Logs paused]";
            target.textContent = `${snapshot}${suffix}`;
          } else {
            target.dataset.empty = "true";
            target.textContent =
              artifactDetailsState.pendingLogCount > 0
                ? `Logs paused – ${artifactDetailsState.pendingLogCount} new entries`
                : "Logs paused";
          }
          return;
        }
        if (logs.length === 0) {
          target.dataset.empty = "true";
          target.textContent = "No logs yet";
          artifactDetailsRenderedLogs = "";
        } else {
          target.dataset.empty = "false";
          artifactDetailsRenderedLogs = logs.join("\n");
          target.textContent = artifactDetailsRenderedLogs;
        }
      };

      const renderExportSpecViewer = () => {
        const viewer = artifactDetailsElements.exportViewer;
        if (!viewer) return;
        const spec = artifactDetailsState.exportSpec;
        const rawSearch = artifactDetailsState.exportSearch || "";
        const trimmed = rawSearch.trim();
        const search = trimmed
          ? {
              raw: trimmed,
              normalized: trimmed.toLowerCase(),
            }
          : null;
        if (artifactDetailsState.loading) {
          viewer.dataset.empty = "true";
          viewer.innerHTML = "Loading ExportSpec…";
          return;
        }
        if (artifactDetailsState.error) {
          viewer.dataset.empty = "true";
          viewer.innerHTML = "—";
          return;
        }
        viewer.innerHTML = "";
        if (!spec || typeof spec !== "object") {
          viewer.dataset.empty = "true";
          viewer.textContent = "No ExportSpec available";
          return;
        }
        const { element, hasMatch } = buildJsonViewerNode(null, spec, search, 0);
        viewer.dataset.empty = "false";
        viewer.appendChild(element);
        if (search && !hasMatch) {
          const empty = document.createElement("div");
          empty.className = "artifact-details__empty";
          empty.textContent = `No matches for "${search.raw}"`;
          viewer.appendChild(empty);
        }
      };

      const renderArtifactDetails = () => {
        const container = artifactDetailsElements.container;
        if (!container) return;
        container.dataset.open = artifactDetailsState.open ? "true" : "false";
        container.setAttribute("aria-hidden", artifactDetailsState.open ? "false" : "true");

        if (!artifactDetailsState.open) {
          if (artifactDetailsElements.toast) {
            artifactDetailsElements.toast.dataset.visible = "false";
            artifactDetailsElements.toast.textContent = "";
          }
          return;
        }

        if (artifactDetailsElements.loading) {
          artifactDetailsElements.loading.hidden = !artifactDetailsState.loading;
        }
        if (artifactDetailsElements.error) {
          const hasError = Boolean(artifactDetailsState.error);
          artifactDetailsElements.error.hidden = !hasError;
          artifactDetailsElements.error.textContent = hasError ? artifactDetailsState.error : "";
        }
        const hasData = !artifactDetailsState.loading && !artifactDetailsState.error;
        if (artifactDetailsElements.content) {
          artifactDetailsElements.content.hidden = !hasData;
        }

        if (artifactDetailsElements.toast) {
          const toastVisible = Boolean(artifactDetailsState.toast);
          artifactDetailsElements.toast.dataset.visible = toastVisible ? "true" : "false";
          artifactDetailsElements.toast.textContent = toastVisible ? artifactDetailsState.toast : "";
        }

        if (artifactDetailsElements.toggleLogs) {
          const paused = !!artifactDetailsState.logsPaused;
          artifactDetailsElements.toggleLogs.setAttribute("aria-pressed", paused ? "true" : "false");
          if (paused) {
            const count = Number(artifactDetailsState.pendingLogCount) || 0;
            artifactDetailsElements.toggleLogs.textContent =
              count > 0 ? `Resume logs (${count})` : "Resume logs";
          } else {
            artifactDetailsElements.toggleLogs.textContent = "Pause logs";
          }
        }

        if (artifactDetailsElements.jsonLink) {
          artifactDetailsElements.jsonLink.href = "#";
          artifactDetailsElements.jsonLink.setAttribute("aria-disabled", "true");
          artifactDetailsElements.jsonLink.tabIndex = -1;
        }
        if (artifactDetailsElements.zipLink) {
          artifactDetailsElements.zipLink.href = "#";
          artifactDetailsElements.zipLink.setAttribute("aria-disabled", "true");
          artifactDetailsElements.zipLink.tabIndex = -1;
        }
        if (artifactDetailsElements.copyIdButton) {
          artifactDetailsElements.copyIdButton.disabled = true;
        }
        if (artifactDetailsElements.copyExportButton) {
          artifactDetailsElements.copyExportButton.disabled = true;
        }
        if (artifactDetailsElements.rerunButton) {
          artifactDetailsElements.rerunButton.disabled = true;
          artifactDetailsElements.rerunButton.textContent = artifactDetailsState.rerunPending
            ? "Re-running…"
            : "Re-run task";
        }
        if (artifactDetailsElements.notice) {
          artifactDetailsElements.notice.dataset.visible = "false";
          artifactDetailsElements.notice.innerHTML = "";
        }
        if (artifactDetailsElements.exportSearch) {
          artifactDetailsElements.exportSearch.value = artifactDetailsState.exportSearch;
        }
        const shareState =
          artifactDetailsState.share || { info: null, pendingType: null, error: "" };
        if (artifactDetailsElements.shareJsonButton) {
          artifactDetailsElements.shareJsonButton.disabled = true;
          artifactDetailsElements.shareJsonButton.textContent =
            shareState.pendingType === "json" ? "Sharing…" : "Share JSON";
        }
        if (artifactDetailsElements.shareZipButton) {
          artifactDetailsElements.shareZipButton.disabled = true;
          artifactDetailsElements.shareZipButton.textContent =
            shareState.pendingType === "zip" ? "Sharing…" : "Share ZIP";
        }
        if (artifactDetailsElements.shareFeedback) {
          artifactDetailsElements.shareFeedback.dataset.visible = "false";
        }
        if (artifactDetailsElements.shareSummary) {
          artifactDetailsElements.shareSummary.textContent = "";
        }
        if (artifactDetailsElements.shareLink) {
          artifactDetailsElements.shareLink.textContent = "";
          artifactDetailsElements.shareLink.href = "#";
        }
        if (artifactDetailsElements.shareTtl) {
          artifactDetailsElements.shareTtl.textContent = "";
        }
        if (artifactDetailsElements.shareCopyButton) {
          artifactDetailsElements.shareCopyButton.disabled = true;
        }
        if (artifactDetailsElements.shareError) {
          artifactDetailsElements.shareError.dataset.visible = "false";
          artifactDetailsElements.shareError.textContent = "";
        }
        if (artifactDetailsElements.shareCopyLinkButton) {
          artifactDetailsElements.shareCopyLinkButton.disabled = true;
        }

        if (!hasData) {
          if (artifactDetailsElements.previewSection) {
            artifactDetailsElements.previewSection.dataset.visible = "false";
          }
          if (artifactDetailsElements.previewImage) {
            artifactDetailsElements.previewImage.removeAttribute("src");
            artifactDetailsElements.previewImage.alt = "No preview available";
          }
          if (artifactDetailsElements.previewDownload) {
            artifactDetailsElements.previewDownload.href = "#";
            artifactDetailsElements.previewDownload.setAttribute("aria-disabled", "true");
            artifactDetailsElements.previewDownload.removeAttribute("download");
          }
          renderArtifactDetailsLogs();
          renderExportSpecViewer();
          return;
        }

        const taskId = artifactDetailsState.taskId;
        if (artifactDetailsElements.taskId) {
          artifactDetailsElements.taskId.textContent = taskId || "—";
        }
        if (artifactDetailsElements.shareCopyLinkButton) {
          artifactDetailsElements.shareCopyLinkButton.disabled = !taskId;
        }
        if (artifactDetailsElements.created) {
          const createdAt =
            artifactDetailsState.task && Number.isFinite(artifactDetailsState.task.createdAt)
              ? artifactDetailsState.task.createdAt
              : null;
          artifactDetailsElements.created.textContent = createdAt != null ? formatDateTime(createdAt) : "—";
        }
        if (artifactDetailsElements.status) {
          let statusText =
            (artifactDetailsState.result && artifactDetailsState.result.status) ||
            (artifactDetailsState.task && artifactDetailsState.task.status) ||
            "unknown";
          const rawProgress = artifactDetailsState.progress;
          if (typeof rawProgress === "number" && Number.isFinite(rawProgress)) {
            let percent = rawProgress;
            if (percent <= 1 && percent >= 0) {
              percent = percent * 100;
            }
            const clamped = Math.max(0, Math.min(100, Math.round(percent)));
            statusText = `${statusText} (${clamped}%)`;
          }
          artifactDetailsElements.status.textContent = statusText;
        }
        if (artifactDetailsElements.jsonLink && taskId) {
          artifactDetailsElements.jsonLink.href = buildRelayUrl(
            `/tasks/${encodeURIComponent(taskId)}/artifact`,
            { includeApiKey: !!RELAY_API_KEY },
          );
          artifactDetailsElements.jsonLink.setAttribute("aria-disabled", "false");
          artifactDetailsElements.jsonLink.tabIndex = 0;
        }
        if (artifactDetailsElements.zipLink && taskId) {
          artifactDetailsElements.zipLink.href = buildRelayUrl(
            `/tasks/${encodeURIComponent(taskId)}/package.zip`,
            { includeApiKey: !!RELAY_API_KEY },
          );
          artifactDetailsElements.zipLink.setAttribute("aria-disabled", "false");
          artifactDetailsElements.zipLink.tabIndex = 0;
        }
        if (artifactDetailsElements.previewSection) {
          const hasPreview = Boolean(
            artifactDetailsState.hasPreview && artifactDetailsState.previewUrl,
          );
          artifactDetailsElements.previewSection.dataset.visible = hasPreview ? "true" : "false";
          if (artifactDetailsElements.previewImage) {
            if (hasPreview) {
              let previewUrl = buildRelayUrl(artifactDetailsState.previewUrl, {
                includeApiKey: !!RELAY_API_KEY,
              });
              if (Number.isFinite(artifactDetailsState.previewUpdatedAt)) {
                const version = Math.floor(artifactDetailsState.previewUpdatedAt);
                previewUrl += previewUrl.includes("?") ? `&v=${version}` : `?v=${version}`;
              }
              artifactDetailsElements.previewImage.src = previewUrl;
              artifactDetailsElements.previewImage.alt = taskId
                ? `Preview of ${taskId}`
                : "Artifact preview";
            } else {
              artifactDetailsElements.previewImage.removeAttribute("src");
              artifactDetailsElements.previewImage.alt = "No preview available";
            }
          }
          if (artifactDetailsElements.previewDownload) {
            if (hasPreview) {
              let downloadUrl = buildRelayUrl(artifactDetailsState.previewUrl, {
                includeApiKey: !!RELAY_API_KEY,
              });
              if (Number.isFinite(artifactDetailsState.previewUpdatedAt)) {
                const version = Math.floor(artifactDetailsState.previewUpdatedAt);
                downloadUrl += downloadUrl.includes("?") ? `&v=${version}` : `?v=${version}`;
              }
              artifactDetailsElements.previewDownload.href = downloadUrl;
              artifactDetailsElements.previewDownload.setAttribute("aria-disabled", "false");
              artifactDetailsElements.previewDownload.download = `${taskId || 'preview'}.png`;
            } else {
              artifactDetailsElements.previewDownload.href = "#";
              artifactDetailsElements.previewDownload.setAttribute("aria-disabled", "true");
              artifactDetailsElements.previewDownload.removeAttribute("download");
            }
          }
        }
        if (artifactDetailsElements.copyIdButton) {
          artifactDetailsElements.copyIdButton.disabled = !taskId;
        }
        if (artifactDetailsElements.copyExportButton) {
          artifactDetailsElements.copyExportButton.disabled = !artifactDetailsState.exportSpec;
        }
        if (artifactDetailsElements.rerunButton) {
          const hasSpec = artifactDetailsState.task && artifactDetailsState.task.taskSpec;
          artifactDetailsElements.rerunButton.disabled = !hasSpec || artifactDetailsState.rerunPending;
          artifactDetailsElements.rerunButton.textContent = artifactDetailsState.rerunPending
            ? "Re-running…"
            : "Re-run task";
        }
        if (artifactDetailsElements.shareJsonButton) {
          const isPending = shareState.pendingType === "json";
          artifactDetailsElements.shareJsonButton.disabled = !taskId || Boolean(shareState.pendingType);
          artifactDetailsElements.shareJsonButton.textContent = isPending ? "Sharing…" : "Share JSON";
        }
        if (artifactDetailsElements.shareZipButton) {
          const isPending = shareState.pendingType === "zip";
          artifactDetailsElements.shareZipButton.disabled = !taskId || Boolean(shareState.pendingType);
          artifactDetailsElements.shareZipButton.textContent = isPending ? "Sharing…" : "Share ZIP";
        }
        if (artifactDetailsElements.shareCopyLinkButton) {
          artifactDetailsElements.shareCopyLinkButton.disabled =
            !taskId || Boolean(shareState.pendingType);
        }
        if (artifactDetailsElements.shareCopyButton) {
          artifactDetailsElements.shareCopyButton.disabled =
            !shareState.info || !shareState.info.url;
        }
        if (shareState.info && shareState.info.url) {
          if (artifactDetailsElements.shareFeedback) {
            artifactDetailsElements.shareFeedback.dataset.visible = "true";
          }
          if (artifactDetailsElements.shareSummary) {
            artifactDetailsElements.shareSummary.textContent = formatShareSummary(shareState.info.type);
          }
          if (artifactDetailsElements.shareLink) {
            artifactDetailsElements.shareLink.textContent = shareState.info.url;
            artifactDetailsElements.shareLink.href = shareState.info.url;
          }
          if (artifactDetailsElements.shareTtl) {
            artifactDetailsElements.shareTtl.textContent = formatShareTtl(shareState.info.expiresAt);
          }
        }
        if (artifactDetailsElements.shareError) {
          const shareError = shareState.error ? String(shareState.error) : "";
          artifactDetailsElements.shareError.dataset.visible = shareError ? "true" : "false";
          artifactDetailsElements.shareError.textContent = shareError;
        }

        renderArtifactDetailsLogs();
        renderExportSpecViewer();

        if (artifactDetailsElements.notice) {
          const notice = artifactDetailsState.notice;
          if (notice && notice.message) {
            artifactDetailsElements.notice.dataset.visible = "true";
            artifactDetailsElements.notice.innerHTML = "";
            const messageSpan = document.createElement("span");
            messageSpan.textContent = notice.message;
            artifactDetailsElements.notice.appendChild(messageSpan);
            if (Array.isArray(notice.actions) && notice.actions.length > 0) {
              const actionsContainer = document.createElement("div");
              actionsContainer.className = "artifact-details__notice-actions";
              for (const action of notice.actions) {
                if (!action || typeof action.onClick !== "function" || !action.label) continue;
                const button = document.createElement("button");
                button.type = "button";
                button.textContent = action.label;
                button.addEventListener("click", () => action.onClick());
                actionsContainer.appendChild(button);
              }
              if (actionsContainer.childNodes.length > 0) {
                artifactDetailsElements.notice.appendChild(actionsContainer);
              }
            }
          } else {
            artifactDetailsElements.notice.dataset.visible = "false";
            artifactDetailsElements.notice.innerHTML = "";
          }
        }
      };

      const setArtifactDetailsToast = (message, duration = 2200) => {
        artifactDetailsState.toast = message ? String(message) : "";
        renderArtifactDetails();
        clearTimeout(artifactDetailsToastTimer);
        if (artifactDetailsState.toast) {
          artifactDetailsToastTimer = setTimeout(() => {
            artifactDetailsState.toast = "";
            renderArtifactDetails();
          }, duration);
        }
      };

      const setArtifactDetailsNotice = (notice) => {
        if (!notice) {
          artifactDetailsState.notice = null;
        } else if (typeof notice === "string") {
          artifactDetailsState.notice = { message: notice, actions: [] };
        } else {
          artifactDetailsState.notice = {
            message: notice.message || "",
            actions: Array.isArray(notice.actions) ? notice.actions : [],
          };
        }
        renderArtifactDetails();
      };

      const stringifyCompareValue = (value) => {
        if (
          value === null ||
          value === undefined ||
          typeof value === "string" ||
          typeof value === "number" ||
          typeof value === "boolean" ||
          typeof value === "bigint"
        ) {
          return formatJsonPrimitive(value);
        }
        if (Array.isArray(value) || (value && typeof value === "object")) {
          try {
            return JSON.stringify(value, null, 2);
          } catch (_) {
            return String(value);
          }
        }
        return String(value);
      };

      const renderArtifactCompare = () => {
        const container = artifactCompareElements.container;
        if (!container) return;
        container.dataset.open = artifactCompareState.open ? "true" : "false";
        container.setAttribute("aria-hidden", artifactCompareState.open ? "false" : "true");

        if (!artifactCompareState.open) {
          if (artifactCompareElements.loading) {
            artifactCompareElements.loading.hidden = true;
          }
          if (artifactCompareElements.error) {
            artifactCompareElements.error.hidden = true;
            artifactCompareElements.error.textContent = "";
          }
          if (artifactCompareElements.content) {
            artifactCompareElements.content.hidden = true;
          }
          return;
        }

        if (artifactCompareElements.loading) {
          artifactCompareElements.loading.hidden = !artifactCompareState.loading;
        }
        if (artifactCompareElements.error) {
          const hasError = Boolean(artifactCompareState.error);
          artifactCompareElements.error.hidden = !hasError;
          artifactCompareElements.error.textContent = hasError ? artifactCompareState.error : "";
        }

        const showContent = !artifactCompareState.loading && !artifactCompareState.error;
        if (artifactCompareElements.content) {
          artifactCompareElements.content.hidden = !showContent;
        }

        if (artifactCompareElements.leftId) {
          artifactCompareElements.leftId.textContent = artifactCompareState.leftId || "—";
        }
        if (artifactCompareElements.rightId) {
          artifactCompareElements.rightId.textContent = artifactCompareState.rightId || "—";
        }
        if (artifactCompareElements.swapButton) {
          artifactCompareElements.swapButton.disabled =
            artifactCompareState.loading ||
            !artifactCompareState.leftId ||
            !artifactCompareState.rightId;
        }

        const activeTab = artifactCompareState.activeTab === "changes" ? "changes" : "summary";
        if (artifactCompareElements.tabSummary) {
          artifactCompareElements.tabSummary.classList.toggle("is-active", activeTab === "summary");
        }
        if (artifactCompareElements.tabChanges) {
          artifactCompareElements.tabChanges.classList.toggle("is-active", activeTab === "changes");
        }
        if (artifactCompareElements.summarySection) {
          artifactCompareElements.summarySection.dataset.active = activeTab === "summary" ? "true" : "false";
        }
        if (artifactCompareElements.changesSection) {
          artifactCompareElements.changesSection.dataset.active = activeTab === "changes" ? "true" : "false";
        }

        if (artifactCompareElements.summaryAdded) {
          artifactCompareElements.summaryAdded.textContent = String(
            Number(artifactCompareState.summary.added) || 0,
          );
        }
        if (artifactCompareElements.summaryRemoved) {
          artifactCompareElements.summaryRemoved.textContent = String(
            Number(artifactCompareState.summary.removed) || 0,
          );
        }
        if (artifactCompareElements.summaryChanged) {
          artifactCompareElements.summaryChanged.textContent = String(
            Number(artifactCompareState.summary.changed) || 0,
          );
        }
        if (artifactCompareElements.summaryUnchanged) {
          artifactCompareElements.summaryUnchanged.textContent = String(
            Number(artifactCompareState.summary.unchanged) || 0,
          );
        }

        if (artifactCompareElements.searchInput) {
          if (artifactCompareElements.searchInput.value !== artifactCompareState.searchTerm) {
            artifactCompareElements.searchInput.value = artifactCompareState.searchTerm;
          }
          artifactCompareElements.searchInput.disabled = artifactCompareState.loading;
        }

        const hasResponse = Boolean(artifactCompareState.response);
        if (artifactCompareElements.downloadButton) {
          artifactCompareElements.downloadButton.setAttribute(
            "aria-disabled",
            hasResponse ? "false" : "true",
          );
          artifactCompareElements.downloadButton.disabled = !hasResponse;
        }

        if (artifactCompareElements.downloadZipButton) {
          artifactCompareElements.downloadZipButton.setAttribute(
            "aria-disabled",
            hasResponse ? "false" : "true",
          );
          artifactCompareElements.downloadZipButton.disabled = !hasResponse;
        }

        if (artifactCompareElements.exportHtmlButton) {
          const canExportHtml =
            Boolean(artifactCompareState.leftId && artifactCompareState.rightId) &&
            !artifactCompareState.loading;
          artifactCompareElements.exportHtmlButton.setAttribute(
            "aria-disabled",
            canExportHtml ? "false" : "true",
          );
          artifactCompareElements.exportHtmlButton.disabled = !canExportHtml;
        }

        const rawEntries = Array.isArray(artifactCompareState.diff)
          ? artifactCompareState.diff.filter((entry) => entry && typeof entry === "object")
          : [];
        const normalizedSearch = (artifactCompareState.searchTerm || "").trim().toLowerCase();
        const filteredEntries = rawEntries.filter((entry) => {
          const type = typeof entry.type === "string" ? entry.type.toLowerCase() : "changed";
          if (type === "unchanged") {
            return false;
          }
          if (!normalizedSearch) {
            return true;
          }
          const pathText = typeof entry.path === "string" ? entry.path.toLowerCase() : "";
          return pathText.includes(normalizedSearch);
        });

        if (artifactCompareElements.diffList) {
          artifactCompareElements.diffList.innerHTML = "";
          if (showContent && filteredEntries.length > 0) {
            for (const entry of filteredEntries) {
              const type = typeof entry.type === "string" ? entry.type.toLowerCase() : "changed";
              const badgeType = type === "added" || type === "removed" || type === "unchanged" ? type : "changed";
              const item = document.createElement("li");
              item.className = "artifact-compare__diff-item";

              const header = document.createElement("div");
              header.className = "artifact-compare__diff-header";
              const badge = document.createElement("span");
              badge.className = `artifact-compare__badge artifact-compare__badge--${badgeType}`;
              badge.textContent = badgeType.toUpperCase();
              header.appendChild(badge);
              const pathSpan = document.createElement("span");
              const pathText = typeof entry.path === "string" && entry.path ? entry.path : "(root)";
              pathSpan.textContent = pathText;
              header.appendChild(pathSpan);
              item.appendChild(header);

              const body = document.createElement("div");
              body.className = "artifact-compare__diff-body";

              const leftColumn = document.createElement("div");
              leftColumn.className = "artifact-compare__diff-column";
              const leftLabel = document.createElement("strong");
              leftLabel.textContent = "Left";
              const leftValue = document.createElement("pre");
              leftValue.className = "artifact-compare__diff-value";
              leftValue.textContent = stringifyCompareValue(entry.left);
              leftColumn.appendChild(leftLabel);
              leftColumn.appendChild(leftValue);

              const rightColumn = document.createElement("div");
              rightColumn.className = "artifact-compare__diff-column";
              const rightLabel = document.createElement("strong");
              rightLabel.textContent = "Right";
              const rightValue = document.createElement("pre");
              rightValue.className = "artifact-compare__diff-value";
              rightValue.textContent = stringifyCompareValue(entry.right);
              rightColumn.appendChild(rightLabel);
              rightColumn.appendChild(rightValue);

              body.appendChild(leftColumn);
              body.appendChild(rightColumn);
              item.appendChild(body);
              artifactCompareElements.diffList.appendChild(item);
            }
          }
        }

        if (artifactCompareElements.emptyState) {
          const showEmpty = showContent && filteredEntries.length === 0;
          artifactCompareElements.emptyState.hidden = !showEmpty;
          if (showEmpty) {
            artifactCompareElements.emptyState.textContent = normalizedSearch
              ? "No differences for current filter"
              : "No differences";
          }
        }

        const hasVisual =
          artifactCompareState.leftPreview.hasPreview && artifactCompareState.rightPreview.hasPreview;
        if (artifactCompareElements.visualSection) {
          artifactCompareElements.visualSection.dataset.visible = hasVisual ? "true" : "false";
        }
        if (hasVisual) {
          const visualMode = artifactCompareState.visualMode === "overlay" ? "overlay" : "side-by-side";
          const overlayValue = Number.isFinite(artifactCompareState.overlayPosition)
            ? Math.min(100, Math.max(0, artifactCompareState.overlayPosition))
            : 50;

          if (artifactCompareElements.visualModeSide) {
            artifactCompareElements.visualModeSide.classList.toggle("is-active", visualMode === "side-by-side");
          }
          if (artifactCompareElements.visualModeOverlay) {
            artifactCompareElements.visualModeOverlay.classList.toggle("is-active", visualMode === "overlay");
          }
          if (artifactCompareElements.visualSideContainer) {
            artifactCompareElements.visualSideContainer.dataset.active = visualMode === "side-by-side" ? "true" : "false";
          }
          if (artifactCompareElements.visualOverlayContainer) {
            artifactCompareElements.visualOverlayContainer.dataset.active = visualMode === "overlay" ? "true" : "false";
          }

          const leftUrl = artifactCompareState.leftPreview.hasPreview
            ? buildComparePreviewUrl(
                artifactCompareState.leftId,
                artifactCompareState.leftPreview.previewUpdatedAt,
              )
            : null;
          const rightUrl = artifactCompareState.rightPreview.hasPreview
            ? buildComparePreviewUrl(
                artifactCompareState.rightId,
                artifactCompareState.rightPreview.previewUpdatedAt,
              )
            : null;

          if (artifactCompareElements.visualLeftImage) {
            if (leftUrl) {
              artifactCompareElements.visualLeftImage.src = leftUrl;
            } else {
              artifactCompareElements.visualLeftImage.removeAttribute("src");
            }
          }
          if (artifactCompareElements.visualRightImage) {
            if (rightUrl) {
              artifactCompareElements.visualRightImage.src = rightUrl;
            } else {
              artifactCompareElements.visualRightImage.removeAttribute("src");
            }
          }
          if (artifactCompareElements.overlayBaseImage) {
            if (leftUrl) {
              artifactCompareElements.overlayBaseImage.src = leftUrl;
            } else {
              artifactCompareElements.overlayBaseImage.removeAttribute("src");
            }
          }
          if (artifactCompareElements.overlayTopImage) {
            if (rightUrl) {
              artifactCompareElements.overlayTopImage.src = rightUrl;
            } else {
              artifactCompareElements.overlayTopImage.removeAttribute("src");
            }
          }
          if (artifactCompareElements.overlaySlider) {
            artifactCompareElements.overlaySlider.value = String(overlayValue);
          }
          if (artifactCompareElements.overlayForeground) {
            artifactCompareElements.overlayForeground.style.width = `${overlayValue}%`;
          }
        } else {
          if (artifactCompareElements.visualModeSide) {
            artifactCompareElements.visualModeSide.classList.remove("is-active");
          }
          if (artifactCompareElements.visualModeOverlay) {
            artifactCompareElements.visualModeOverlay.classList.remove("is-active");
          }
          if (artifactCompareElements.visualSideContainer) {
            artifactCompareElements.visualSideContainer.dataset.active = "false";
          }
          if (artifactCompareElements.visualOverlayContainer) {
            artifactCompareElements.visualOverlayContainer.dataset.active = "false";
          }
          if (artifactCompareElements.visualLeftImage) {
            artifactCompareElements.visualLeftImage.removeAttribute("src");
          }
          if (artifactCompareElements.visualRightImage) {
            artifactCompareElements.visualRightImage.removeAttribute("src");
          }
          if (artifactCompareElements.overlayBaseImage) {
            artifactCompareElements.overlayBaseImage.removeAttribute("src");
          }
          if (artifactCompareElements.overlayTopImage) {
            artifactCompareElements.overlayTopImage.removeAttribute("src");
          }
          if (artifactCompareElements.overlaySlider) {
            artifactCompareElements.overlaySlider.value = "50";
          }
          if (artifactCompareElements.overlayForeground) {
            artifactCompareElements.overlayForeground.style.width = "50%";
          }
        }
      };

      const refreshArtifactComparePreviews = () => {
        if (!artifactCompareState.open) return;
        const left = getArtifactPreviewInfo(artifactCompareState.leftId);
        const right = getArtifactPreviewInfo(artifactCompareState.rightId);
        const changed =
          left.hasPreview !== artifactCompareState.leftPreview.hasPreview ||
          left.previewUpdatedAt !== artifactCompareState.leftPreview.previewUpdatedAt ||
          right.hasPreview !== artifactCompareState.rightPreview.hasPreview ||
          right.previewUpdatedAt !== artifactCompareState.rightPreview.previewUpdatedAt;
        artifactCompareState.leftPreview = left;
        artifactCompareState.rightPreview = right;
        if (changed) {
          renderArtifactCompare();
        }
      };

      const fetchArtifactCompareDiff = async () => {
        if (!artifactCompareState.leftId || !artifactCompareState.rightId) {
          artifactCompareState.loading = false;
          renderArtifactCompare();
          return;
        }
        const { token, signal } = compareFetchGuard.start();
        try {
          const mode = artifactCompareState.mode === "summary" ? "summary" : "full";
          const res = await relayFetch(buildRelayUrl(`/artifacts/compare`), {
            method: "POST",
            headers: {
              "Content-Type": "application/json",
            },
            body: JSON.stringify({
              leftId: artifactCompareState.leftId,
              rightId: artifactCompareState.rightId,
              mode,
            }),
            signal,
          });
          if (!compareFetchGuard.isActive(token)) {
            return;
          }
          let payload = null;
          try {
            payload = await res.json();
          } catch (_) {}
          if (!res.ok) {
            const message = parseServerError(payload, `HTTP ${res.status}`);
            throw new Error(message);
          }
          const data = payload && typeof payload === "object" ? payload : {};
          const summary = data.summary && typeof data.summary === "object" ? data.summary : {};
          artifactCompareState.summary = {
            added: Number(summary.added) || 0,
            removed: Number(summary.removed) || 0,
            changed: Number(summary.changed) || 0,
            unchanged: Number(summary.unchanged) || 0,
          };
          artifactCompareState.diff = Array.isArray(data.diff)
            ? data.diff
                .filter((entry) => entry && typeof entry === "object")
                .map((entry) => ({
                  path: typeof entry.path === "string" ? entry.path : "",
                  type: typeof entry.type === "string" ? entry.type.toLowerCase() : "changed",
                  left: Object.prototype.hasOwnProperty.call(entry, "left") ? entry.left : null,
                  right: Object.prototype.hasOwnProperty.call(entry, "right") ? entry.right : null,
                }))
            : [];
          artifactCompareState.response = {
            leftId: typeof data.leftId === "string" ? data.leftId : artifactCompareState.leftId,
            rightId: typeof data.rightId === "string" ? data.rightId : artifactCompareState.rightId,
            summary: artifactCompareState.summary,
            diff: Array.isArray(data.diff) ? data.diff : [],
            mode,
          };
          artifactCompareState.error = "";
          if (artifactCompareState.open) {
            showToast({ type: "success", message: "Comparison ready" });
          }
        } catch (err) {
          if (err && err.name === "AbortError") {
            return;
          }
          if (!compareFetchGuard.isActive(token)) {
            return;
          }
          const message = parseServerError(err, "Failed to compare artifacts");
          artifactCompareState.error = `Failed to compare artifacts: ${message}`;
          artifactCompareState.diff = [];
          artifactCompareState.response = null;
          showToast({ type: "error", message });
        } finally {
          if (compareFetchGuard.isActive(token)) {
            artifactCompareState.loading = false;
            renderArtifactCompare();
          }
          compareFetchGuard.finish(token);
        }
      };

      const openArtifactCompare = (leftId, rightId) => {
        const normalizedLeft = typeof leftId === "string" ? leftId : String(leftId ?? "");
        const normalizedRight = typeof rightId === "string" ? rightId : String(rightId ?? "");
        artifactCompareState.open = true;
        artifactCompareState.leftId = normalizedLeft;
        artifactCompareState.rightId = normalizedRight;
        artifactCompareState.activeTab = "summary";
        artifactCompareState.searchTerm = "";
        artifactCompareState.summary = { added: 0, removed: 0, changed: 0, unchanged: 0 };
        artifactCompareState.diff = [];
        artifactCompareState.response = null;
        artifactCompareState.mode = "full";
        artifactCompareState.visualMode = "side-by-side";
        artifactCompareState.overlayPosition = 50;
        artifactCompareState.leftPreview = getArtifactPreviewInfo(normalizedLeft);
        artifactCompareState.rightPreview = getArtifactPreviewInfo(normalizedRight);
        artifactCompareState.error = "";
        artifactCompareState.loading = true;
        renderArtifactCompare();
        fetchArtifactCompareDiff();
      };

      const closeArtifactCompare = () => {
        if (!artifactCompareState.open) return;
        artifactCompareState.open = false;
        artifactCompareState.loading = false;
        artifactCompareState.leftId = null;
        artifactCompareState.rightId = null;
        artifactCompareState.summary = { added: 0, removed: 0, changed: 0, unchanged: 0 };
        artifactCompareState.diff = [];
        artifactCompareState.response = null;
        artifactCompareState.searchTerm = "";
        artifactCompareState.activeTab = "summary";
        artifactCompareState.mode = "full";
        artifactCompareState.leftPreview = { hasPreview: false, previewUpdatedAt: null };
        artifactCompareState.rightPreview = { hasPreview: false, previewUpdatedAt: null };
        artifactCompareState.visualMode = "side-by-side";
        artifactCompareState.overlayPosition = 50;
        artifactCompareState.error = "";
        renderArtifactCompare();
      };

      const setArtifactCompareVisualMode = (mode) => {
        const normalized = mode === "overlay" ? "overlay" : "side-by-side";
        if (artifactCompareState.visualMode === normalized) return;
        artifactCompareState.visualMode = normalized;
        renderArtifactCompare();
      };

      const setArtifactCompareOverlayPosition = (value) => {
        const numeric = Number(value);
        if (!Number.isFinite(numeric)) return;
        const clamped = Math.min(100, Math.max(0, Math.round(numeric)));
        if (artifactCompareState.overlayPosition === clamped) return;
        artifactCompareState.overlayPosition = clamped;
        renderArtifactCompare();
      };

      const setArtifactCompareTab = (tab) => {
        const normalized = tab === "changes" ? "changes" : "summary";
        if (artifactCompareState.activeTab === normalized) return;
        artifactCompareState.activeTab = normalized;
        renderArtifactCompare();
      };

      const swapArtifactCompareSides = () => {
        if (
          !artifactCompareState.open ||
          artifactCompareState.loading ||
          !artifactCompareState.leftId ||
          !artifactCompareState.rightId
        ) {
          return;
        }
        const nextLeft = artifactCompareState.rightId;
        const nextRight = artifactCompareState.leftId;
        artifactCompareState.leftId = nextLeft;
        artifactCompareState.rightId = nextRight;
        const nextLeftPreview = artifactCompareState.rightPreview;
        const nextRightPreview = artifactCompareState.leftPreview;
        artifactCompareState.leftPreview = nextLeftPreview;
        artifactCompareState.rightPreview = nextRightPreview;
        artifactCompareState.loading = true;
        artifactCompareState.summary = { added: 0, removed: 0, changed: 0, unchanged: 0 };
        artifactCompareState.diff = [];
        artifactCompareState.response = null;
        artifactCompareState.visualMode = "side-by-side";
        artifactCompareState.overlayPosition = 50;
        artifactCompareState.error = "";
        renderArtifactCompare();
        fetchArtifactCompareDiff();
      };

      const cloneTaskSpec = (taskSpec) => {
        if (!taskSpec || typeof taskSpec !== "object") return null;
        if (typeof structuredClone === "function") {
          try {
            return structuredClone(taskSpec);
          } catch (_) {}
        }
        try {
          return JSON.parse(JSON.stringify(taskSpec));
        } catch (_) {
          return null;
        }
      };

      const loadArtifactDetails = async (taskId) => {
        if (!taskId) return;
        const requestId = ++artifactDetailsState.requestId;
        const isStaleRequest = () => requestId !== artifactDetailsState.requestId;
        const applyState = (fn) => {
          if (isStaleRequest()) {
            return false;
          }
          fn();
          return true;
        };
        const { token, signal } = artifactDetailsGuard.start();
        applyState(() => {
          artifactDetailsState.loading = true;
          artifactDetailsState.error = "";
          artifactDetailsState.task = null;
          artifactDetailsState.result = null;
          artifactDetailsState.logs = [];
          artifactDetailsState.logsPaused = false;
          artifactDetailsState.pendingLogCount = 0;
          artifactDetailsState.exportSpec = null;
          artifactDetailsState.progress = null;
          artifactDetailsState.hasPreview = false;
          artifactDetailsState.previewUrl = null;
          artifactDetailsState.previewUpdatedAt = null;
          artifactDetailsRenderedLogs = "";
          renderArtifactDetails();
        });

        try {
          const taskRes = await relayFetch(
            buildRelayUrl(`/tasks/${encodeURIComponent(taskId)}`),
            { signal },
          );
          if (!artifactDetailsGuard.isActive(token) || isStaleRequest()) {
            return;
          }
          if (!taskRes.ok) {
            let payload = null;
            try {
              payload = await taskRes.json();
            } catch (_) {}
            const message = parseServerError(payload, `HTTP ${taskRes.status}`);
            throw new Error(`Task request failed: ${message}`);
          }
          const taskData = await taskRes.json();
          if (!artifactDetailsGuard.isActive(token) || isStaleRequest()) {
            return;
          }
          applyState(() => {
            artifactDetailsState.task = taskData;
            artifactDetailsState.logs = Array.isArray(taskData.logs)
              ? taskData.logs.map((line) => String(line))
              : [];
            artifactDetailsRenderedLogs = artifactDetailsState.logs.join("\n");
            artifactDetailsState.hasPreview = !!(taskData && taskData.hasPreview);
            artifactDetailsState.previewUrl =
              taskData && typeof taskData.previewUrl === "string" ? taskData.previewUrl : null;
            artifactDetailsState.previewUpdatedAt =
              taskData && Number.isFinite(taskData.previewUpdatedAt)
                ? Number(taskData.previewUpdatedAt)
                : null;
            artifactDetailsState.progress =
              taskData && Number.isFinite(taskData.progress) ? Number(taskData.progress) : null;
            renderArtifactDetails();
          });

          let resultPayload = null;
          try {
            const resultRes = await relayFetch(
              buildRelayUrl(`/tasks/${encodeURIComponent(taskId)}/result`),
              { signal },
            );
            if (!artifactDetailsGuard.isActive(token) || isStaleRequest()) {
              return;
            }
            if (resultRes.status === 404) {
              resultPayload = null;
            } else if (!resultRes.ok) {
              let payload = null;
              try {
                payload = await resultRes.json();
              } catch (_) {}
              const message = parseServerError(payload, `HTTP ${resultRes.status}`);
              throw new Error(message);
            } else {
              resultPayload = await resultRes.json();
            }
          } catch (error) {
            if (error && error.name === "AbortError") {
              return;
            }
            if (!artifactDetailsGuard.isActive(token) || isStaleRequest()) {
              return;
            }
            applyState(() => {
              artifactDetailsState.error = `Failed to load details: ${parseServerError(
                error,
                error?.message || "Result fetch failed",
              )}`;
              renderArtifactDetails();
            });
            return;
          }

          if (!artifactDetailsGuard.isActive(token) || isStaleRequest()) {
            return;
          }
          applyState(() => {
            artifactDetailsState.result = resultPayload;
            artifactDetailsState.exportSpec =
              resultPayload && typeof resultPayload.exportSpec === "object"
                ? resultPayload.exportSpec
                : null;
            if (resultPayload && typeof resultPayload.hasPreview === "boolean") {
              artifactDetailsState.hasPreview = resultPayload.hasPreview;
            }
            if (resultPayload && typeof resultPayload.previewUrl === "string") {
              artifactDetailsState.previewUrl = resultPayload.previewUrl;
            }
            if (resultPayload && Number.isFinite(resultPayload.previewUpdatedAt)) {
              artifactDetailsState.previewUpdatedAt = Number(resultPayload.previewUpdatedAt);
            }
            renderArtifactDetails();
          });
        } catch (err) {
          if (err && err.name === "AbortError") {
            return;
          }
          if (!artifactDetailsGuard.isActive(token) || isStaleRequest()) {
            return;
          }
          applyState(() => {
            artifactDetailsState.error = `Failed to load details: ${parseServerError(
              err,
              err?.message || "Unknown error",
            )}`;
            renderArtifactDetails();
          });
        } finally {
          if (artifactDetailsGuard.isActive(token)) {
            applyState(() => {
              artifactDetailsState.loading = false;
              renderArtifactDetails();
            });
          }
          artifactDetailsGuard.finish(token);
        }
      };

      const shareArtifactLink = async (type) => {
        const taskId = artifactDetailsState.taskId;
        if (!taskId) return;
        if (!artifactDetailsState.share) {
          artifactDetailsState.share = { info: null, pendingType: null, error: "" };
        }
        artifactDetailsState.share.pendingType = type;
        artifactDetailsState.share.error = "";
        renderArtifactDetails();

        try {
          const response = await relayFetch(
            buildRelayUrl(`/tasks/${encodeURIComponent(taskId)}/share`),
            {
              method: "POST",
              headers: { "Content-Type": "application/json" },
              body: JSON.stringify({ type }),
            },
          );
          if (!response.ok) {
            let payload = null;
            try {
              payload = await response.json();
            } catch (_) {
              try {
                const text = await response.text();
                if (text && text.trim()) {
                  payload = { error: { message: text.trim() } };
                }
              } catch (_) {}
            }
            const message = parseServerError(payload, `HTTP ${response.status}`);
            throw new Error(message);
          }

          const payload = await response.json();
          const url = typeof payload.url === "string" ? payload.url : "";
          const expiresAtRaw = Number(payload.expiresAt);
          if (!url) {
            throw new Error("Invalid share response");
          }
          artifactDetailsState.share.info = {
            type,
            url,
            expiresAt: Number.isFinite(expiresAtRaw) ? expiresAtRaw : null,
          };
          artifactDetailsState.share.error = "";
          showToast({
            type: "success",
            message: type === "json" ? "Public JSON link ready" : "Public ZIP link ready",
          });
        } catch (err) {
          const message = parseServerError(err, "Share failed");
          artifactDetailsState.share.error = `Share failed: ${message}`;
          showToast({ type: "error", message });
        } finally {
          artifactDetailsState.share.pendingType = null;
          renderArtifactDetails();
        }
      };

      const openArtifactDetails = (taskId) => {
        if (!taskId) return;
        artifactDetailsState.open = true;
        artifactDetailsState.taskId = taskId; // фиксируем выбранный
        artifactDetailsState.notice = null;
        artifactDetailsState.toast = "";
        artifactDetailsState.exportSearch = "";
        artifactDetailsState.rerunPending = false;
        artifactDetailsState.error = "";
        artifactDetailsState.logs = [];
        artifactDetailsState.logsPaused = false;
        artifactDetailsState.pendingLogCount = 0;
        artifactDetailsState.exportSpec = null;
        artifactDetailsState.task = null;
        artifactDetailsState.result = null;
        artifactDetailsState.hasPreview = false;
        artifactDetailsState.previewUrl = null;
        artifactDetailsState.previewUpdatedAt = null;
        artifactDetailsState.progress = null;
        artifactDetailsState.share = { info: null, pendingType: null, error: "" };
        if (artifactDetailsElements.exportSearch) {
          artifactDetailsElements.exportSearch.value = "";
        }
        clearTimeout(artifactDetailsToastTimer);
        artifactDetailsToastTimer = null;
        artifactDetailsRenderedLogs = "";
        renderArtifactDetails();
        loadArtifactDetails(taskId);
        renderArtifactsTable();
        openTaskWatch(taskId);
      };

      const closeArtifactDetails = () => {
        if (!artifactDetailsState.open) return;
        artifactDetailsState.open = false;
        artifactDetailsState.taskId = null;
        artifactDetailsState.task = null;
        artifactDetailsState.result = null;
        artifactDetailsState.logs = [];
        artifactDetailsState.logsPaused = false;
        artifactDetailsState.pendingLogCount = 0;
        artifactDetailsState.exportSpec = null;
        artifactDetailsState.exportSearch = "";
        artifactDetailsState.notice = null;
        artifactDetailsState.toast = "";
        artifactDetailsState.error = "";
        artifactDetailsState.loading = false;
        artifactDetailsState.rerunPending = false;
        artifactDetailsState.share = { info: null, pendingType: null, error: "" };
        artifactDetailsState.hasPreview = false;
        artifactDetailsState.previewUrl = null;
        artifactDetailsState.previewUpdatedAt = null;
        artifactDetailsState.progress = null;
        if (artifactDetailsElements.exportSearch) {
          artifactDetailsElements.exportSearch.value = "";
        }
        clearTimeout(artifactDetailsToastTimer);
        artifactDetailsToastTimer = null;
        renderArtifactDetails();
        renderArtifactsTable();
        artifactDetailsRenderedLogs = "";
      };

      const handleArtifactDetailsKeydown = (event) => {
        const active = event.target;
        const isFormTarget =
          active &&
          (active.closest && active.closest("input, textarea, select, button, [contenteditable='true']"));
        const key = typeof event.key === "string" ? event.key.toLowerCase() : "";

        if (key === "escape") {
          if (artifactCompareState.open) {
            event.preventDefault();
            closeArtifactCompare();
            return;
          }
          if (artifactDetailsState.open) {
            event.preventDefault();
            closeArtifactDetails();
          }
          return;
        }

        if (isFormTarget) {
          return;
        }

        if (key === "f") {
          event.preventDefault();
          triggerArtifactsRefresh();
          return;
        }
        if (key === "c") {
          if (artifactsState.loading) return;
          const ids = Array.from(artifactsState.selection);
          if (ids.length !== 2) return;
          event.preventDefault();
          if (artifactDetailsState.open) {
            closeArtifactDetails();
          }
          openArtifactCompare(ids[0], ids[1]);
          return;
        }
        if (key === "d") {
          const ids = Array.from(artifactsState.selection);
          if (ids.length !== 1) return;
          event.preventDefault();
          downloadSingleArtifactJson(ids[0]);
        }
      };

      const rerunArtifactTask = async () => {
        if (artifactDetailsState.rerunPending) return;
        const task = artifactDetailsState.task;
        if (!task || !task.taskSpec) {
          setArtifactDetailsToast("TaskSpec is not available");
          return;
        }
        const clonedSpec = cloneTaskSpec(task.taskSpec);
        if (!clonedSpec) {
          setArtifactDetailsToast("Failed to prepare TaskSpec");
          return;
        }
        const originalMeta =
          clonedSpec.meta && typeof clonedSpec.meta === "object" ? { ...clonedSpec.meta } : {};
        const originalId = artifactDetailsState.taskId;
        if (typeof originalMeta.id === "string" && originalMeta.id.trim()) {
          const suffix = Math.floor(Date.now() / 1000).toString(36);
          originalMeta.id = `${originalMeta.id}-rerun-${suffix}`;
        }
        if (originalId) {
          originalMeta.rerunOf = originalId;
        }
        clonedSpec.meta = originalMeta;
        artifactDetailsState.rerunPending = true;
        setArtifactDetailsNotice(null);
        renderArtifactDetails();
        try {
          const res = await relayFetch(buildRelayUrl(`/tasks`), {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify({ taskSpec: clonedSpec }),
          });
          if (!res.ok) {
            throw new Error(`HTTP ${res.status}`);
          }
          const data = await res.json();
          const newTaskId = data && typeof data.taskId === "string" ? data.taskId : null;
          if (!newTaskId) {
            throw new Error("Unexpected response");
          }
          artifactDetailsState.rerunPending = false;
          setArtifactDetailsNotice({
            message: `Task re-queued: ${newTaskId}`,
            actions: [
              {
                label: "Watch status",
                onClick: () => openTaskWatch(newTaskId),
              },
              {
                label: "Load in Builder",
                onClick: () =>
                  assignFetchedTask(
                    newTaskId,
                    clonedSpec,
                    "Re-run",
                    "Plugin: re-run queued from details",
                  ),
              },
            ],
          });
          setArtifactDetailsToast("Task re-run created");
        } catch (err) {
          artifactDetailsState.rerunPending = false;
          const message = err && err.message ? err.message : err;
          setArtifactDetailsNotice({ message: `Re-run failed: ${message}` });
        } finally {
          renderArtifactDetails();
        }
      };

      const updateCompareButtonState = () => {
        const button = artifactsElements.compareButton;
        if (!button) return;
        const count = artifactsState.selection.size;
        if (artifactsState.loading || count !== 2) {
          button.setAttribute("disabled", "true");
          button.setAttribute("aria-disabled", "true");
        } else {
          button.removeAttribute("disabled");
          button.setAttribute("aria-disabled", "false");
        }
      };

      const updateBulkButtonState = () => {
        const button = artifactsElements.bulkButton;
        if (!button) return;
        const count = artifactsState.selection.size;
        button.textContent =
          count > 0
            ? `Download selected as ZIP (${count})`
            : "Download selected as ZIP";
        if (artifactsState.loading || count === 0) {
          button.setAttribute("disabled", "true");
          button.setAttribute("aria-disabled", "true");
        } else {
          button.removeAttribute("disabled");
          button.setAttribute("aria-disabled", "false");
        }
        updateCompareButtonState();
      };

      const updatePaginationControls = () => {
        const { prevButton, nextButton } = artifactsElements;
        if (prevButton) {
          if (artifactsState.loading || artifactsState.offset <= 0) {
            prevButton.setAttribute("disabled", "true");
            prevButton.setAttribute("aria-disabled", "true");
          } else {
            prevButton.removeAttribute("disabled");
            prevButton.setAttribute("aria-disabled", "false");
          }
        }
        if (nextButton) {
          const hasMore =
            artifactsState.total > 0 &&
            artifactsState.offset + artifactsState.limit < artifactsState.total;
          if (artifactsState.loading || !hasMore) {
            nextButton.setAttribute("disabled", "true");
            nextButton.setAttribute("aria-disabled", "true");
          } else {
            nextButton.removeAttribute("disabled");
            nextButton.setAttribute("aria-disabled", "false");
          }
        }
      };

      const renderArtifactsTable = () => {
        const tbody = artifactsElements.tableBody;
        if (!tbody) return;
        const table = artifactsElements.table;
        const emptyState = artifactsElements.emptyState;
        const infoEl = artifactsElements.paginationInfo;

        if (table) {
          table.dataset.state = artifactsState.loading ? "loading" : "idle";
        }

        const applyRows = (fragment) => {
          scheduleDomUpdate(() => {
            tbody.innerHTML = "";
            if (fragment) {
              tbody.appendChild(fragment);
            }
          });
        };

        const searchTerm = artifactsState.searchTerm;
        const filtered = artifactsState.items.filter((item) => {
          if (!searchTerm) return true;
          const id = typeof item.id === "string" ? item.id : String(item.id ?? "");
          return id.toLowerCase().includes(searchTerm);
        });

        const showEmpty = !artifactsState.loading && artifactsState.items.length === 0;
        if (emptyState) {
          emptyState.dataset.visible = showEmpty ? "true" : "false";
        }
        if (table) {
          table.hidden = showEmpty;
        }
        if (showEmpty) {
          applyRows(null);
          if (infoEl) {
            infoEl.textContent = "No artifacts";
          }
          updateBulkButtonState();
          updatePaginationControls();
          return;
        }

        if (artifactsState.loading && artifactsState.items.length === 0) {
          const fragment = document.createDocumentFragment();
          const skeletonRows = Math.max(3, Math.min(artifactsState.limit || 5, 8));
          for (let i = 0; i < skeletonRows; i += 1) {
            const row = document.createElement("tr");
            for (let col = 0; col < 7; col += 1) {
              const cell = document.createElement("td");
              const shimmer = document.createElement("span");
              shimmer.className = "artifacts-table__skeleton";
              cell.appendChild(shimmer);
              row.appendChild(cell);
            }
            fragment.appendChild(row);
          }
          applyRows(fragment);
          if (infoEl) {
            infoEl.textContent = "Loading artifacts…";
          }
          updateBulkButtonState();
          updatePaginationControls();
          return;
        }

        const fragment = document.createDocumentFragment();
        if (filtered.length === 0) {
          const emptyRow = document.createElement("tr");
          const cell = document.createElement("td");
          cell.colSpan = 7;
          cell.className = "muted";
          cell.textContent = "No matches";
          emptyRow.appendChild(cell);
          fragment.appendChild(emptyRow);
        } else {
          for (const item of filtered) {
            const safeId = typeof item.id === "string" ? item.id : String(item.id ?? "");
            const row = document.createElement("tr");
            row.dataset.clickable = "true";
            row.tabIndex = 0;
            row.dataset.selected =
              artifactDetailsState.open && artifactDetailsState.taskId === safeId ? "true" : "false";

            row.addEventListener("click", (event) => {
              if (event.target && event.target.closest("input, button, a")) {
                return;
              }
              openArtifactDetails(safeId);
            });
            row.addEventListener("keydown", (event) => {
              if (event.key === "Enter" || event.key === " ") {
                if (event.target && event.target.closest("input, button, a")) {
                  return;
                }
                event.preventDefault();
                openArtifactDetails(safeId);
              }
            });

            const selectCell = document.createElement("td");
            const checkbox = document.createElement("input");
            checkbox.type = "checkbox";
            checkbox.checked = artifactsState.selection.has(safeId);
            checkbox.addEventListener("click", (event) => {
              event.stopPropagation();
            });
            checkbox.addEventListener("keydown", (event) => {
              if (event.key === " " || event.key === "Enter") {
                event.stopPropagation();
              }
            });
            checkbox.addEventListener("change", (event) => {
              if (event.target.checked) {
                artifactsState.selection.add(safeId);
              } else {
                artifactsState.selection.delete(safeId);
              }
              updateBulkButtonState();
            });
            selectCell.appendChild(checkbox);
            row.appendChild(selectCell);

            const idCell = document.createElement("td");
            idCell.textContent = safeId;
            row.appendChild(idCell);

            const previewCell = document.createElement("td");
            previewCell.className = "preview-col";
            if (item.hasPreview) {
              const img = document.createElement("img");
              img.className = "artifact-preview-thumb";
              img.alt = `Preview for ${safeId}`;
              img.loading = "lazy";
              let previewUrl = buildRelayUrl(
                `/tasks/${encodeURIComponent(safeId)}/preview.png`,
                { includeApiKey: !!RELAY_API_KEY },
              );
              if (Number.isFinite(item.previewUpdatedAt)) {
                const version = Math.floor(item.previewUpdatedAt);
                previewUrl += previewUrl.includes("?") ? `&v=${version}` : `?v=${version}`;
              }
              registerLazyPreview(img, previewUrl);
              previewCell.appendChild(img);
            } else {
              previewCell.textContent = "—";
            }
            row.appendChild(previewCell);

            const createdCell = document.createElement("td");
            createdCell.textContent = formatDateTime(item.createdAt);
            row.appendChild(createdCell);

            const sizeCell = document.createElement("td");
            sizeCell.textContent = formatBytes(item.size);
            row.appendChild(sizeCell);

            const jsonCell = document.createElement("td");
            jsonCell.className = "actions";
            const jsonLink = document.createElement("a");
            jsonLink.href = buildRelayUrl(
              `/tasks/${encodeURIComponent(safeId)}/artifact`,
              { includeApiKey: !!RELAY_API_KEY },
            );
            jsonLink.textContent = "Download JSON";
            jsonLink.target = "_blank";
            jsonLink.rel = "noopener noreferrer";
            jsonLink.download = `${safeId}.json`;
            jsonLink.addEventListener("click", (event) => {
              event.stopPropagation();
            });
            jsonCell.appendChild(jsonLink);
            row.appendChild(jsonCell);

            const zipCell = document.createElement("td");
            zipCell.className = "actions";
            const zipLink = document.createElement("a");
            zipLink.href = buildRelayUrl(
              `/tasks/${encodeURIComponent(safeId)}/package.zip`,
              { includeApiKey: !!RELAY_API_KEY },
            );
            zipLink.textContent = "Download ZIP";
            zipLink.target = "_blank";
            zipLink.rel = "noopener noreferrer";
            zipLink.download = `${safeId}.zip`;
            zipLink.addEventListener("click", (event) => {
              event.stopPropagation();
            });
            zipCell.appendChild(zipLink);
            row.appendChild(zipCell);

            fragment.appendChild(row);
          }
        }

        applyRows(fragment);

        if (infoEl) {
          if (artifactsState.total === 0) {
            infoEl.textContent = "No artifacts";
          } else {
            const currentPage = Math.floor(artifactsState.offset / artifactsState.limit) + 1;
            const totalPages = Math.max(1, Math.ceil(artifactsState.total / artifactsState.limit));
            const visibleLabel =
              filtered.length === artifactsState.items.length
                ? `showing ${filtered.length} of ${artifactsState.items.length}`
                : `filtered ${filtered.length} of ${artifactsState.items.length}`;
            infoEl.textContent = `Page ${currentPage}/${totalPages}, ${visibleLabel} (total ${artifactsState.total})`;
          }
        }
        updateBulkButtonState();
        updatePaginationControls();
      };

      const setArtifactsLoading = (loading) => {
        artifactsState.loading = loading;
        if (artifactsPanelEl) {
          artifactsPanelEl.dataset.loading = loading ? "true" : "false";
        }
        if (artifactsElements.refreshButton) {
          artifactsElements.refreshButton.disabled = loading;
          artifactsElements.refreshButton.dataset.loading = loading ? "true" : "false";
          artifactsElements.refreshButton.setAttribute("aria-disabled", loading ? "true" : "false");
        }
        if (artifactsElements.emptyRefreshButton) {
          artifactsElements.emptyRefreshButton.disabled = loading;
          artifactsElements.emptyRefreshButton.dataset.loading = loading ? "true" : "false";
          artifactsElements.emptyRefreshButton.setAttribute("aria-disabled", loading ? "true" : "false");
        }
        updateBulkButtonState();
        updatePaginationControls();
      };

      const fetchArtifacts = async ({ userInitiated = false, resetOffset = false } = {}) => {
        if (artifactsState.loading) return;
        if (resetOffset) {
          artifactsState.offset = 0;
        }
        setArtifactsError("");
        const { token, signal } = artifactsFetchGuard.start();
        setArtifactsLoading(true);
        try {
          const params = new URLSearchParams();
          params.set("offset", String(artifactsState.offset));
          params.set("limit", String(artifactsState.limit));
          params.set("order", artifactsState.order);
          const response = await relayFetch(buildRelayUrl(`/artifacts?${params.toString()}`), {
            signal,
          });
          if (!artifactsFetchGuard.isActive(token)) {
            return;
          }
          if (!response.ok) {
            let payload = null;
            try {
              payload = await response.json();
            } catch (_) {}
            const message = parseServerError(payload, `HTTP ${response.status}`);
            throw new Error(message);
          }
          const data = await response.json();
          if (!artifactsFetchGuard.isActive(token)) {
            return;
          }
          artifactsState.items = Array.isArray(data.items)
            ? data.items.map((entry) => ({
                ...entry,
                hasPreview: !!(entry && entry.hasPreview),
                previewUpdatedAt:
                  entry && Number.isFinite(entry.previewUpdatedAt)
                    ? Number(entry.previewUpdatedAt)
                    : null,
              }))
            : [];
          const totalValue = Number(data.total);
          const offsetValue = Number(data.offset);
          const limitValue = Number(data.limit);
          artifactsState.total = Number.isFinite(totalValue)
            ? totalValue
            : artifactsState.items.length;
          artifactsState.offset = Number.isFinite(offsetValue) ? offsetValue : artifactsState.offset;
          artifactsState.limit = Number.isFinite(limitValue) ? limitValue : artifactsState.limit;
          if (artifactsElements.limitInput) {
            artifactsElements.limitInput.value = String(artifactsState.limit);
          }
          if (artifactsElements.orderSelect) {
            artifactsElements.orderSelect.value = artifactsState.order;
          }
          const toRemove = [];
          artifactsState.selection.forEach((id) => {
            if (!artifactsState.items.some((item) => item && item.id === id)) {
              toRemove.push(id);
            }
          });
          for (const id of toRemove) {
            artifactsState.selection.delete(id);
          }
          if (userInitiated) {
            artifactsState.lastUserRefresh = Date.now();
            showToast({
              type: "success",
              message: `Artifacts refreshed (${artifactsState.items.length})`,
            });
          }
        } catch (err) {
          if (err && err.name === "AbortError") {
            return;
          }
          if (!artifactsFetchGuard.isActive(token)) {
            return;
          }
          const message = parseServerError(err, "Failed to load artifacts");
          console.error("Failed to load artifacts", err);
          setArtifactsError(`Failed to load artifacts: ${message}`);
          showToast({ type: "error", message });
          artifactsState.items = [];
          artifactsState.total = 0;
        } finally {
          if (artifactsFetchGuard.isActive(token)) {
            setArtifactsLoading(false);
            refreshArtifactComparePreviews();
            renderArtifactsTable();
          }
          artifactsFetchGuard.finish(token);
        }
      };

      const downloadSelectedArtifacts = async () => {
        const button = artifactsElements.bulkButton;
        if (!button || artifactsState.selection.size === 0) return;
        if (artifactsState.loading) return;
        setArtifactsError("");
        button.setAttribute("disabled", "true");
        button.setAttribute("aria-disabled", "true");
        button.dataset.loading = "true";
        try {
          const ids = Array.from(artifactsState.selection);
          const res = await relayFetch(buildRelayUrl(`/artifacts/bulk.zip`), {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify({ ids }),
          });
          if (!res.ok) {
            let payload = null;
            try {
              payload = await res.json();
            } catch (_) {
              try {
                const text = await res.text();
                if (text && !payload) {
                  payload = { error: text };
                }
              } catch (_) {}
            }
            const message = parseServerError(payload, `HTTP ${res.status}`);
            throw new Error(message);
          }
          const blob = await res.blob();
          const url = URL.createObjectURL(blob);
          const link = document.createElement("a");
          const stamp = new Date().toISOString().replace(/[:.]/g, "-");
          link.href = url;
          link.download = `artifacts-${stamp}.zip`;
          document.body.appendChild(link);
          link.click();
          document.body.removeChild(link);
          setTimeout(() => {
            URL.revokeObjectURL(url);
          }, 1500);
          showToast({
            type: "success",
            message: `Preparing ZIP for ${ids.length} artifact${ids.length === 1 ? "" : "s"}`,
          });
        } catch (err) {
          const message = parseServerError(err, "Bulk download error");
          setArtifactsError(`Bulk download error: ${message}`);
          showToast({ type: "error", message });
        } finally {
          button.dataset.loading = "false";
          button.setAttribute("aria-disabled", "false");
          updateBulkButtonState();
        }
      };

      const downloadSingleArtifactJson = (id) => {
        if (!id) return;
        const url = buildRelayUrl(`/tasks/${encodeURIComponent(id)}/artifact`, {
          includeApiKey: !!RELAY_API_KEY,
        });
        const link = document.createElement("a");
        link.href = url;
        link.download = `${id}.json`;
        link.rel = "noopener noreferrer";
        document.body.appendChild(link);
        link.click();
        document.body.removeChild(link);
        showToast({ type: "success", message: `Downloading ${id}.json` });
      };

      const setActiveTab = (targetId) => {
        for (const btn of tabButtons) {
          const isActive = btn.dataset.target === targetId;
          btn.classList.toggle("is-active", isActive);
        }
        for (const [id, panel] of tabPanels.entries()) {
          panel.classList.toggle("is-active", id === targetId);
        }
        if (targetId === "panel-artifacts" && !artifactsState.initialized) {
          artifactsState.initialized = true;
          fetchArtifacts();
        }
      };

      tabButtons.forEach((btn) => {
        btn.addEventListener("click", () => {
          const target = btn.dataset.target;
          if (target) {
            setActiveTab(target);
          }
        });
      });

      if (artifactsElements.searchInput) {
        artifactsElements.searchInput.value = artifactsState.searchValue || "";
        artifactsElements.searchInput.addEventListener("input", (event) => {
          const value = event.target.value || "";
          artifactsState.searchValue = value;
          artifactsState.searchTerm = value.toLowerCase();
          persistArtifactsPreferences();
          renderArtifactsTable();
        });
      }
      if (artifactsElements.orderSelect) {
        artifactsElements.orderSelect.value = artifactsState.order;
        artifactsElements.orderSelect.addEventListener("change", (event) => {
          const value = String(event.target.value || "desc").toLowerCase();
          artifactsState.order = value === "asc" ? "asc" : "desc";
          artifactsState.offset = 0;
          persistArtifactsPreferences();
          if (artifactsState.initialized) {
            fetchArtifacts();
          }
        });
      }
      if (artifactsElements.limitInput) {
        artifactsElements.limitInput.value = String(artifactsState.limit);
        artifactsElements.limitInput.addEventListener("change", (event) => {
          const value = Number(event.target.value);
          if (!Number.isFinite(value)) return;
          const clamped = Math.min(50, Math.max(1, Math.floor(value)));
          artifactsState.limit = clamped;
          artifactsState.offset = 0;
          artifactsElements.limitInput.value = String(clamped);
          persistArtifactsPreferences();
          if (artifactsState.initialized) {
            fetchArtifacts();
          }
        });
      }
      if (artifactsElements.prevButton) {
        artifactsElements.prevButton.addEventListener("click", () => {
          if (artifactsState.loading) return;
          const nextOffset = Math.max(0, artifactsState.offset - artifactsState.limit);
          if (nextOffset === artifactsState.offset) return;
          artifactsState.offset = nextOffset;
          fetchArtifacts();
        });
      }
      if (artifactsElements.nextButton) {
        artifactsElements.nextButton.addEventListener("click", () => {
          if (artifactsState.loading) return;
          const nextOffset = artifactsState.offset + artifactsState.limit;
          if (artifactsState.total > 0 && nextOffset >= artifactsState.total) return;
          artifactsState.offset = nextOffset;
          fetchArtifacts();
        });
      }
      const triggerArtifactsRefresh = () => {
        if (artifactsState.loading) return;
        fetchArtifacts({ userInitiated: true });
      };
      if (artifactsElements.refreshButton) {
        artifactsElements.refreshButton.addEventListener("click", triggerArtifactsRefresh);
      }
      if (artifactsElements.emptyRefreshButton) {
        artifactsElements.emptyRefreshButton.addEventListener("click", triggerArtifactsRefresh);
      }
      if (artifactsElements.compareButton) {
        artifactsElements.compareButton.addEventListener("click", () => {
          if (artifactsState.loading) return;
          const ids = Array.from(artifactsState.selection);
          if (ids.length !== 2) return;
          if (typeof closeArtifactDetails === "function") {
            closeArtifactDetails();
          }
          openArtifactCompare(ids[0], ids[1]);
        });
      }
      if (artifactsElements.bulkButton) {
        artifactsElements.bulkButton.addEventListener("click", () => {
          downloadSelectedArtifacts();
        });
      }

      if (artifactDetailsElements.overlay) {
        artifactDetailsElements.overlay.addEventListener("click", () => {
          closeArtifactDetails();
        });
      }
      if (artifactDetailsElements.closeButton) {
        artifactDetailsElements.closeButton.addEventListener("click", () => {
          closeArtifactDetails();
        });
      }
      if (artifactCompareElements.overlay) {
        artifactCompareElements.overlay.addEventListener("click", () => {
          closeArtifactCompare();
        });
      }
      if (artifactCompareElements.closeButton) {
        artifactCompareElements.closeButton.addEventListener("click", () => {
          closeArtifactCompare();
        });
      }
      if (artifactCompareElements.swapButton) {
        artifactCompareElements.swapButton.addEventListener("click", () => {
          swapArtifactCompareSides();
        });
      }
      if (artifactCompareElements.tabSummary) {
        artifactCompareElements.tabSummary.addEventListener("click", () => {
          setArtifactCompareTab("summary");
        });
      }
      if (artifactCompareElements.tabChanges) {
        artifactCompareElements.tabChanges.addEventListener("click", () => {
          setArtifactCompareTab("changes");
        });
      }
      if (artifactCompareElements.searchInput) {
        artifactCompareElements.searchInput.addEventListener("input", (event) => {
          const value = typeof event.target.value === "string" ? event.target.value : "";
          artifactCompareState.searchTerm = value;
          renderArtifactCompare();
        });
      }
      if (artifactCompareElements.downloadButton) {
        artifactCompareElements.downloadButton.addEventListener("click", () => {
          if (
            artifactCompareElements.downloadButton.getAttribute("aria-disabled") === "true" ||
            !artifactCompareState.response
          ) {
            return;
          }
          try {
            const payload = artifactCompareState.response;
            const text = JSON.stringify(payload, null, 2);
            const blob = new Blob([text], { type: "application/json" });
            const url = URL.createObjectURL(blob);
            const link = document.createElement("a");
            const sanitize = (value) => (value || "").toString().replace(/[^A-Za-z0-9._-]+/g, "-");
            const leftSegment = sanitize(payload.leftId || artifactCompareState.leftId || "left");
            const rightSegment = sanitize(payload.rightId || artifactCompareState.rightId || "right");
            const filename = `diff-${leftSegment}-vs-${rightSegment}.json`;
            link.href = url;
            link.download = filename;
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
            setTimeout(() => URL.revokeObjectURL(url), 0);
          } catch (err) {
            console.error("Failed to download diff", err);
          }
        });
      }
      if (artifactCompareElements.downloadZipButton) {
        artifactCompareElements.downloadZipButton.addEventListener("click", () => {
          if (
            artifactCompareElements.downloadZipButton.getAttribute("aria-disabled") === "true" ||
            !artifactCompareState.leftId ||
            !artifactCompareState.rightId
          ) {
            return;
          }
          try {
            const url = new URL(buildRelayUrl(`/artifacts/compare.zip`));
            url.searchParams.set("leftId", artifactCompareState.leftId);
            url.searchParams.set("rightId", artifactCompareState.rightId);
            url.searchParams.set("mode", artifactCompareState.mode === "summary" ? "summary" : "full");
            window.open(url.toString(), "_blank", "noopener,noreferrer");
          } catch (err) {
            console.error("Failed to download diff ZIP", err);
          }
        });
      }
      if (artifactCompareElements.exportHtmlButton) {
        artifactCompareElements.exportHtmlButton.addEventListener("click", () => {
          if (
            artifactCompareElements.exportHtmlButton.getAttribute("aria-disabled") === "true" ||
            !artifactCompareState.leftId ||
            !artifactCompareState.rightId
          ) {
            return;
          }
          try {
            const url = new URL(buildRelayUrl(`/artifacts/compare.html`));
            url.searchParams.set("leftId", artifactCompareState.leftId);
            url.searchParams.set("rightId", artifactCompareState.rightId);
            url.searchParams.set("mode", artifactCompareState.mode === "summary" ? "summary" : "full");
            window.open(url.toString(), "_blank", "noopener,noreferrer");
          } catch (err) {
            console.error("Failed to export HTML diff", err);
          }
        });
      }
      if (artifactCompareElements.visualModeSide) {
        artifactCompareElements.visualModeSide.addEventListener("click", () => {
          setArtifactCompareVisualMode("side-by-side");
        });
      }
      if (artifactCompareElements.visualModeOverlay) {
        artifactCompareElements.visualModeOverlay.addEventListener("click", () => {
          setArtifactCompareVisualMode("overlay");
        });
      }
      if (artifactCompareElements.overlaySlider) {
        artifactCompareElements.overlaySlider.addEventListener("input", (event) => {
          setArtifactCompareOverlayPosition(event.target.value);
        });
      }
      if (artifactDetailsElements.exportSearch) {
        artifactDetailsElements.exportSearch.addEventListener("input", (event) => {
          const value = typeof event.target.value === "string" ? event.target.value : "";
          artifactDetailsState.exportSearch = value;
          renderExportSpecViewer();
        });
      }
      if (artifactDetailsElements.copyIdButton) {
        artifactDetailsElements.copyIdButton.addEventListener("click", async () => {
          if (!artifactDetailsState.taskId) return;
          const ok = await copyTextToClipboard(artifactDetailsState.taskId);
          setArtifactDetailsToast(ok ? "Task ID copied" : "Copy failed");
        });
      }
      if (artifactDetailsElements.copyExportButton) {
        artifactDetailsElements.copyExportButton.addEventListener("click", async () => {
          if (!artifactDetailsState.exportSpec) return;
          try {
            const text = JSON.stringify(artifactDetailsState.exportSpec, null, 2);
            const ok = await copyTextToClipboard(text);
            setArtifactDetailsToast(ok ? "ExportSpec copied" : "Copy failed");
          } catch (err) {
            setArtifactDetailsToast(
              `Copy failed: ${err && err.message ? err.message : "Unexpected error"}`,
            );
          }
        });
      }
      if (artifactDetailsElements.shareJsonButton) {
        artifactDetailsElements.shareJsonButton.addEventListener("click", () => {
          shareArtifactLink("json");
        });
      }
      if (artifactDetailsElements.shareZipButton) {
        artifactDetailsElements.shareZipButton.addEventListener("click", () => {
          shareArtifactLink("zip");
        });
      }
      if (artifactDetailsElements.shareCopyLinkButton) {
        artifactDetailsElements.shareCopyLinkButton.addEventListener("click", async () => {
          const taskId = artifactDetailsState.taskId;
          if (!taskId) return;
          const directUrl = buildRelayUrl(
            `/tasks/${encodeURIComponent(taskId)}/artifact`,
            { includeApiKey: !!RELAY_API_KEY },
          );
          const ok = await copyTextToClipboard(directUrl);
          setArtifactDetailsToast(ok ? "Link copied" : "Copy failed");
        });
      }
      if (artifactDetailsElements.shareCopyButton) {
        artifactDetailsElements.shareCopyButton.addEventListener("click", async () => {
          const info = artifactDetailsState.share && artifactDetailsState.share.info;
          if (!info || !info.url) return;
          const ok = await copyTextToClipboard(info.url);
          setArtifactDetailsToast(ok ? "Link copied" : "Copy failed");
        });
      }
      if (artifactDetailsElements.toggleLogs) {
        artifactDetailsElements.toggleLogs.addEventListener("click", () => {
          const nextState = !artifactDetailsState.logsPaused;
          artifactDetailsState.logsPaused = nextState;
          if (!nextState) {
            artifactDetailsState.pendingLogCount = 0;
            artifactDetailsRenderedLogs = artifactDetailsState.logs.join("\n");
          } else if (artifactDetailsElements.logs) {
            artifactDetailsRenderedLogs = artifactDetailsElements.logs.textContent || "";
          }
          renderArtifactDetails();
        });
      }
      if (artifactDetailsElements.rerunButton) {
        artifactDetailsElements.rerunButton.addEventListener("click", () => {
          rerunArtifactTask();
        });
      }

      renderArtifactDetails();
      renderArtifactCompare();
      updateCompareButtonState();
      document.addEventListener("keydown", handleArtifactDetailsKeydown);

      renderArtifactsTable();
      setActiveTab("panel-builder");

      const log = (m) => {
        const el = document.getElementById("log");

        el.textContent +=
          (typeof m === "string" ? m : JSON.stringify(m, null, 2)) + "\n";
        el.scrollTop = el.scrollHeight;
      };

      const rlog = (m) => {
        const el = document.getElementById("relay-log");
        if (!el) return;
        const text = typeof m === "string" ? m : JSON.stringify(m, null, 2);
        el.textContent += `${text}\n`;
        el.scrollTop = el.scrollHeight;
        if (isNetworkConnectivityError(text)) {
          runnerState.lastError = text;
          renderRunnerState();
        }
      };

      const getCurrentSpecString = () =>
        specTextareaEl && typeof specTextareaEl.value === "string" ? specTextareaEl.value : "";

      const setButtonDisabled = (button, disabled) => {
        if (!button) return;
        const isDisabled = !!disabled;
        button.disabled = isDisabled;
        button.setAttribute("aria-disabled", isDisabled ? "true" : "false");
      };

      const renderErrorList = (element, items) => {
        if (!element) return;
        element.innerHTML = "";
        if (!Array.isArray(items) || items.length === 0) {
          element.dataset.visible = "false";
          return;
        }
        element.dataset.visible = "true";
        items.forEach((entry) => {
          const li = document.createElement("li");
          const code = document.createElement("code");
          code.textContent = entry && entry.path ? entry.path : "/";
          li.appendChild(code);
          const message = entry && entry.message ? ` — ${entry.message}` : "";
          if (message) {
            li.appendChild(document.createTextNode(message));
          }
          element.appendChild(li);
        });
      };

      function renderWarnings(element, warnings) {
        if (!element) return;
        element.innerHTML = "";
        if (!Array.isArray(warnings) || warnings.length === 0) {
          element.dataset.visible = "false";
          return;
        }
        element.dataset.visible = "true";
        const title = document.createElement("div");
        title.textContent = "Warnings:";
        element.appendChild(title);
        const list = document.createElement("ul");
        warnings.forEach((warning) => {
          const li = document.createElement("li");
          li.textContent = typeof warning === "string" ? warning : String(warning);
          list.appendChild(li);
        });
        element.appendChild(list);
      };

      const formatConfidenceValue = (value) => {
        if (!Number.isFinite(value)) return "—";
        const clamped = Math.max(0, Math.min(1, value));
        return clamped.toFixed(2);
      };

      const collectImportSectionSummaries = (spec) => {
        if (!spec || typeof spec !== "object") return [];
        const sections = Array.isArray(spec.sections) ? spec.sections : [];
        return sections
          .map((section, index) => {
            if (!section || typeof section !== "object") return null;
            const name =
              typeof section.name === "string" && section.name.trim()
                ? section.name.trim()
                : `Section ${index + 1}`;
            const type =
              typeof section.type === "string" && section.type.trim()
                ? section.type.trim()
                : "custom";
            const meta = section.meta && typeof section.meta === "object" ? section.meta : null;
            const rawConfidence =
              meta && typeof meta.typeConfidence === "number" ? meta.typeConfidence : null;
            const typeConfidence =
              rawConfidence != null && Number.isFinite(rawConfidence)
                ? Math.max(0, Math.min(1, rawConfidence))
                : null;
            const warnings = Array.isArray(section.warnings)
              ? section.warnings
                  .map((entry) => (typeof entry === "string" ? entry : String(entry)))
                  .filter((entry) => entry && entry.length)
              : [];
            return { name, type, typeConfidence, warnings };
          })
          .filter(Boolean);
      };

      const formatLogEntries = (entries, limit) => {
        if (!Array.isArray(entries) || entries.length === 0) return [];
        const sliceLimit = Number.isInteger(limit) && limit > 0 ? limit : entries.length;
        return entries
          .slice(-sliceLimit)
          .map((entry) => {
            if (typeof entry === "string") return entry;
            try {
              return JSON.stringify(entry);
            } catch (_) {
              return String(entry);
            }
          })
          .filter((entry) => entry && entry.length);
      };

      const uniqueStrings = (values) => {
        if (!Array.isArray(values) || values.length === 0) return [];
        const seen = new Set();
        const result = [];
        values.forEach((value) => {
          if (value == null) return;
          const normalized =
            typeof value === "string" && value.trim()
              ? value.trim()
              : value != null
              ? String(value)
              : "";
          if (!normalized) return;
          if (seen.has(normalized)) return;
          seen.add(normalized);
          result.push(normalized);
        });
        return result;
      };

      const requestSelectionImport = () => {
        inflightOperations.import = true;
        setImportState("running", { hint: flowState.import.hint });
        parent.postMessage({ pluginMessage: { type: "import:selection" } }, "*");
      };

      const runTaskSpecInference = (exportSpec, options = {}) => {
        const { source = "import" } = options;
        if (!exportSpec) {
          showToast({
            message: "ExportSpec отсутствует для генерации TaskSpec.",
            type: "error",
          });
          log("TaskSpec inference skipped: missing ExportSpec");
          return false;
        }
        let result;
        try {
          result = inferTaskSpecFromExportSpec(exportSpec, {
            specVersion: "0.1",
            fallbackFileId: "REPLACE_WITH_FILE_ID",
          });
        } catch (error) {
          const message = parseServerError(error, "Ошибка генерации TaskSpec");
          showToast({ message, type: "error" });
          log(`TaskSpec inference error: ${message}`);
          return false;
        }
        if (!result || !result.taskSpec) {
          const message = "Не удалось построить TaskSpec из ExportSpec.";
          showToast({ message, type: "error" });
          log("TaskSpec inference failed: empty result");
          return false;
        }
        const spec = result.taskSpec;
        if (!spec.meta || typeof spec.meta !== "object") {
          spec.meta = {};
        }
        if (spec.meta.inferred !== true) {
          spec.meta.inferred = true;
        }
        if (typeof spec.meta.specVersion !== "string") {
          spec.meta.specVersion = "0.1";
        }
        const warningList = Array.isArray(result.warnings) ? result.warnings : [];
        const mergedWarnings = uniqueStrings([
          ...(Array.isArray(spec.warnings) ? spec.warnings : []),
          ...warningList,
        ]);
        if (mergedWarnings.length) {
          spec.warnings = mergedWarnings;
        } else if (Array.isArray(spec.warnings)) {
          spec.warnings = uniqueStrings(spec.warnings);
        }

        const specString = stringifyJson(spec) || "";
        setTaskSpecTextarea(specString);

        let validationResult = null;
        try {
          validationResult = validateTaskSpecSchema(spec);
        } catch (validationError) {
          const message = parseServerError(
            validationError,
            "Ошибка локальной валидации TaskSpec",
          );
          setValidateState("error", {
            message,
            keepSpec: true,
          });
          showToast({ message, type: "error" });
          log(`TaskSpec inference validation error: ${message}`);
          updateActionButtons();
          return false;
        }

        const warningsSource = Array.isArray(spec.warnings)
          ? spec.warnings
          : spec.meta && Array.isArray(spec.meta.warnings)
          ? spec.meta.warnings
          : [];
        const finalWarnings = uniqueStrings(warningsSource);
        const hasWarnings = finalWarnings.length > 0;
        if (hasWarnings) {
          spec.warnings = finalWarnings;
          if (spec.meta && typeof spec.meta === "object") {
            spec.meta.warnings = finalWarnings;
          }
          finalWarnings.forEach((warning) => {
            log(`Inference warning: ${warning}`);
          });
        }

        if (validationResult && validationResult.valid) {
          const message = hasWarnings
            ? `TaskSpec сгенерирован и валиден (${finalWarnings.length} предупреждений)`
            : "TaskSpec сгенерирован и валиден";
          setValidateState("valid", {
            message,
            hint: hasWarnings ? "Проверьте предупреждения ниже." : "",
            specString,
          });
          showToast({ message, type: hasWarnings ? "warning" : "success" });
          log(`TaskSpec inference (${source}) OK (valid)`);
          updateActionButtons();
          return true;
        }

        if (validationResult && validationResult.valid === false) {
          const errors = Array.isArray(validationResult.errors)
            ? validationResult.errors
            : [];
          const errorMessage =
            errors.length === 1
              ? "TaskSpec сгенерирован, но содержит 1 ошибку схемы."
              : errors.length > 1
              ? `TaskSpec сгенерирован, но содержит ${errors.length} ошибки схемы.`
              : "TaskSpec сгенерирован, но не прошёл валидацию схемы.";
          setValidateState("invalid", {
            message: errorMessage,
            errors,
            hint: "Исправьте TaskSpec и повторите Validate.",
            keepSpec: true,
          });
          if (errors.length) {
            log("TaskSpec schema validation failed:");
            errors.forEach((entry) => {
              const path = entry && entry.path ? entry.path : "/";
              const text = entry && entry.message ? entry.message : "Invalid value";
              log(` - ${path}: ${text}`);
            });
          }
          showToast({ message: errorMessage, type: "error" });
          log(`TaskSpec inference (${source}) завершена с ошибками схемы`);
          updateActionButtons();
          return false;
        }

        const fallbackMessage = hasWarnings
          ? `TaskSpec сгенерирован (${finalWarnings.length} предупреждений). Проверьте вручную.`
          : "TaskSpec сгенерирован. Проверьте вручную.";
        setValidateState("idle", {
          message: fallbackMessage,
          keepSpec: true,
          skipReset: true,
        });
        showToast({ message: fallbackMessage, type: hasWarnings ? "warning" : "success" });
        log(`TaskSpec inference (${source}) OK`);
        updateActionButtons();
        return true;
      };

      const renderImportState = () => {
        const elements = flowElements.import;
        if (!elements) return;
        if (elements.panel) {
          elements.panel.dataset.state = flowState.import.state;
        }
        if (elements.status) {
          elements.status.textContent =
            IMPORT_STATUS_LABELS[flowState.import.state] || flowState.import.state;
        }
        if (elements.message) {
          elements.message.textContent = flowState.import.message || "";
          elements.message.style.display = flowState.import.message ? "block" : "none";
        }
        if (elements.hint) {
          elements.hint.textContent = flowState.import.hint || "";
          elements.hint.style.display = flowState.import.hint ? "block" : "none";
        }
        renderWarnings(elements.warnings, flowState.import.warnings);
        if (elements.sections) {
          const container = elements.sections;
          const sections = Array.isArray(flowState.import.sections)
            ? flowState.import.sections
            : [];
          while (container.firstChild) {
            container.firstChild.remove();
          }
          if (!sections.length) {
            container.dataset.visible = "false";
          } else {
            container.dataset.visible = "true";
            sections.forEach((section, index) => {
              const item = document.createElement("div");
              item.className = "flow-panel__section-item";
              const header = document.createElement("div");
              header.className = "flow-panel__section-header";
              const nameEl = document.createElement("span");
              nameEl.textContent = `${index + 1}. ${section.name}`;
              header.appendChild(nameEl);
              const typeEl = document.createElement("span");
              typeEl.textContent = `type: ${section.type}`;
              header.appendChild(typeEl);
              const confidenceEl = document.createElement("span");
              confidenceEl.textContent = `typeConfidence: ${formatConfidenceValue(
                section.typeConfidence,
              )}`;
              header.appendChild(confidenceEl);
              item.appendChild(header);
              if (Array.isArray(section.warnings) && section.warnings.length) {
                const warningBlock = document.createElement("div");
                warningBlock.className = "flow-panel__section-warning";
                const title = document.createElement("div");
                title.textContent = "Warnings:";
                warningBlock.appendChild(title);
                const list = document.createElement("ul");
                section.warnings.forEach((warning) => {
                  const li = document.createElement("li");
                  li.textContent = typeof warning === "string" ? warning : String(warning);
                  list.appendChild(li);
                });
                warningBlock.appendChild(list);
                item.appendChild(warningBlock);
              }
              container.appendChild(item);
            });
          }
        }
        if (elements.preview) {
          if (flowState.import.specString) {
            elements.preview.dataset.visible = "true";
            elements.preview.textContent = flowState.import.specString;
            elements.preview.scrollTop = elements.preview.scrollHeight;
          } else {
            elements.preview.dataset.visible = "false";
            elements.preview.textContent = "";
          }
        }
        if (elements.actions) {
          elements.actions.style.display =
            flowState.import.downloadUrl && flowState.import.state === "done" ? "flex" : "none";
        }
        if (elements.saveButton) {
          setButtonDisabled(elements.saveButton, !flowState.import.downloadUrl);
        }
      };

      const renderValidateState = () => {
        const elements = flowElements.validate;
        if (elements.panel) {
          elements.panel.dataset.state = flowState.validate.state;
        }
        if (elements.status) {
          elements.status.textContent =
            VALIDATE_STATUS_LABELS[flowState.validate.state] || flowState.validate.state;
        }
        if (elements.message) {
          elements.message.textContent = flowState.validate.message || "";
          elements.message.style.display = flowState.validate.message ? "block" : "none";
        }
        if (elements.hint) {
          elements.hint.textContent = flowState.validate.hint || "";
          elements.hint.style.display = flowState.validate.hint ? "block" : "none";
        }
        renderErrorList(elements.errors, flowState.validate.errors);
      };

      const renderBuildState = () => {
        const elements = flowElements.build;
        if (elements.panel) {
          elements.panel.dataset.state = flowState.build.state;
        }
        if (elements.status) {
          elements.status.textContent =
            BUILD_STATUS_LABELS[flowState.build.state] || flowState.build.state;
        }
        if (elements.message) {
          elements.message.textContent = flowState.build.message || "";
          elements.message.style.display = flowState.build.message ? "block" : "none";
        }
        if (elements.summary) {
          elements.summary.innerHTML = "";
          if (flowState.build.summary) {
            const { created = 0, updated = 0, removed = 0 } = flowState.build.summary;
            const parts = [
              { label: "Created", value: created },
              { label: "Updated", value: updated },
              { label: "Removed", value: removed },
            ];
            parts.forEach((part) => {
              const span = document.createElement("span");
              const label = document.createElement("span");
              label.textContent = `${part.label}:`;
              const value = document.createElement("strong");
              value.textContent = String(part.value);
              span.appendChild(label);
              span.appendChild(value);
              elements.summary.appendChild(span);
            });
          }
        }
        renderWarnings(elements.warnings, flowState.build.warnings);
        if (elements.logs) {
          if (flowState.build.logs.length) {
            elements.logs.dataset.visible = "true";
            elements.logs.textContent = flowState.build.logs.join("\n");
            elements.logs.scrollTop = elements.logs.scrollHeight;
          } else {
            elements.logs.dataset.visible = "false";
            elements.logs.textContent = "";
          }
        }
      };

      const renderExportState = () => {
        const elements = flowElements.export;
        if (elements.panel) {
          elements.panel.dataset.state = flowState.export.state;
        }
        if (elements.status) {
          elements.status.textContent =
            EXPORT_STATUS_LABELS[flowState.export.state] || flowState.export.state;
        }
        if (elements.message) {
          elements.message.textContent = flowState.export.message || "";
          elements.message.style.display = flowState.export.message ? "block" : "none";
        }
        renderErrorList(elements.errors, flowState.export.errors);
        if (elements.logs) {
          if (flowState.export.logs.length) {
            elements.logs.dataset.visible = "true";
            elements.logs.textContent = flowState.export.logs.join("\n");
            elements.logs.scrollTop = elements.logs.scrollHeight;
          } else {
            elements.logs.dataset.visible = "false";
            elements.logs.textContent = "";
          }
        }
        if (exportDownloadLink) {
          if (flowState.export.state === "done" && flowState.export.downloadUrl) {
            exportDownloadLink.style.display = "inline-block";
            exportDownloadLink.href = flowState.export.downloadUrl;
            exportDownloadLink.download = flowState.export.downloadFilename || "ExportSpec.json";
            exportDownloadLink.setAttribute("aria-disabled", "false");
          } else {
            exportDownloadLink.style.display = "none";
            exportDownloadLink.href = "#";
            exportDownloadLink.setAttribute("aria-disabled", "true");
          }
        }
      };

      const renderFlowPanels = () => {
        renderImportState();
        renderValidateState();
        renderBuildState();
        renderExportState();
      };

      const clearExportDownload = () => {
        if (flowState.export.downloadUrl) {
          try {
            URL.revokeObjectURL(flowState.export.downloadUrl);
          } catch (_) {}
        }
        flowState.export.downloadUrl = null;
        if (exportDownloadLink) {
          exportDownloadLink.style.display = "none";
          exportDownloadLink.href = "#";
          exportDownloadLink.setAttribute("aria-disabled", "true");
        }
      };

      const revokeImportDownloadUrl = () => {
        if (flowState.import.downloadUrl) {
          try {
            URL.revokeObjectURL(flowState.import.downloadUrl);
          } catch (_) {}
        }
        flowState.import.downloadUrl = null;
      };

      const isRunnerActive = () => runnerState.enabled || runnerState.processing;

      function setImportState(state, options = {}) {
        const {
          message = "",
          warnings = [],
          specString = null,
          downloadUrl = null,
          downloadFilename = "ExportSpec.selection.json",
          hint = flowState.import.hint || "",
          reset = false,
          keepResult = false,
          skipUpdateButtons = false,
          exportSpec = null,
        } = options;

        if (state === "idle" || reset) {
          flowState.import.state = "idle";
          if (message || reset) {
            flowState.import.message = message || "";
          }
          flowState.import.hint = hint || flowState.import.hint || "";
          if (!keepResult || reset) {
            flowState.import.warnings = [];
            flowState.import.specString = null;
            flowState.import.exportSpec = null;
            flowState.import.sections = [];
            revokeImportDownloadUrl();
            flowState.import.downloadFilename = "ExportSpec.selection.json";
          }
        } else if (state === "running") {
          flowState.import.state = "running";
          flowState.import.message = message || "Импорт выполняется…";
          flowState.import.hint = hint || "";
          flowState.import.warnings = [];
          flowState.import.specString = null;
          flowState.import.exportSpec = null;
          flowState.import.sections = [];
          revokeImportDownloadUrl();
          flowState.import.downloadFilename = "ExportSpec.selection.json";
        } else if (state === "done") {
          flowState.import.state = "done";
          flowState.import.message = message || "Импорт завершён";
          flowState.import.hint = hint || flowState.import.hint || "";
          flowState.import.warnings = Array.isArray(warnings) ? warnings : [];
          flowState.import.specString = typeof specString === "string" ? specString : null;
          flowState.import.exportSpec =
            exportSpec && typeof exportSpec === "object" ? exportSpec : null;
          flowState.import.sections = collectImportSectionSummaries(
            flowState.import.exportSpec,
          );
          revokeImportDownloadUrl();
          flowState.import.downloadUrl = downloadUrl || null;
          flowState.import.downloadFilename = downloadFilename || "ExportSpec.selection.json";
        } else if (state === "error") {
          flowState.import.state = "error";
          flowState.import.message = message || "Ошибка импорта";
          flowState.import.hint = hint || flowState.import.hint || "";
          flowState.import.warnings = Array.isArray(warnings) ? warnings : [];
          if (typeof specString === "string") {
            flowState.import.specString = specString;
          }
          if (!keepResult) {
            flowState.import.exportSpec = null;
            flowState.import.sections = [];
          }
          revokeImportDownloadUrl();
          flowState.import.downloadFilename = "ExportSpec.selection.json";
        } else {
          return;
        }

        renderImportState();
        if (!skipUpdateButtons) {
          updateActionButtons();
        }
      }

      const updateImportSelectionState = (info) => {
        if (info && typeof info === "object") {
          selectionState.count = Number(info.count) || 0;
          selectionState.isSingleFrame = !!info.isSingleFrame;
          selectionState.frameName =
            typeof info.frameName === "string" && info.frameName.trim()
              ? info.frameName.trim()
              : null;
          selectionState.pageName =
            typeof info.pageName === "string" && info.pageName.trim()
              ? info.pageName.trim()
              : null;
          if (typeof info.reason === "string") {
            selectionState.reason = info.reason.trim();
          }
        }

        const hintParts = [];
        if (selectionState.isSingleFrame) {
          const path = [];
          if (selectionState.pageName) path.push(selectionState.pageName);
          if (selectionState.frameName) path.push(selectionState.frameName);
          if (path.length) {
            hintParts.push(`Выделено: ${path.join(" → ")}`);
          }
        } else if (selectionState.reason) {
          hintParts.push(selectionState.reason);
        } else {
          hintParts.push("Выделите один фрейм для импорта.");
        }

        flowState.import.hint = hintParts.join(" ").trim();
        if (flowState.import.state === "idle") {
          flowState.import.message = selectionState.isSingleFrame
            ? "Импорт доступен. Нажмите Import."
            : "Импорт недоступен для текущего выделения.";
        }
      };

      const canBuild = () =>
        !isRunnerActive() &&
        flowState.validate.state === "valid" &&
        flowState.validate.lastSpecString === getCurrentSpecString() &&
        flowState.build.state !== "running";

      const canExport = () =>
        !isRunnerActive() &&
        flowState.build.state === "done" &&
        flowState.build.lastSpecString === getCurrentSpecString() &&
        flowState.export.state !== "running";

      const canImport = () =>
        !isRunnerActive() &&
        !inflightOperations.import &&
        selectionState.isSingleFrame &&
        flowState.import.state !== "running";

      const canInferTaskSpec = () =>
        !isRunnerActive() &&
        !inflightOperations.import &&
        (flowState.import.exportSpec != null || selectionState.isSingleFrame);

      const canProposeTaskSpec = () =>
        !isRunnerActive() &&
        !inflightOperations.import &&
        flowState.import.state === "done" &&
        flowState.import.exportSpec != null;

      function updateActionButtons() {
        setButtonDisabled(validateButton, validateInProgress);
        setButtonDisabled(buildButton, !canBuild());
        setButtonDisabled(importButton, !canImport());
        setButtonDisabled(exportButton, !canExport());
        setButtonDisabled(inferButton, !canInferTaskSpec());
        setButtonDisabled(proposeButton, !canProposeTaskSpec());
      };

      function setBuildState(state, options = {}) {
        const {
          message = "",
          summary = null,
          warnings = [],
          logs = [],
          specString = null,
          reset = false,
          skipUpdateButtons = false,
        } = options;

        flowState.build.state = state;
        flowState.build.message = message || "";

        if (state === "running") {
          flowState.build.summary = null;
          flowState.build.warnings = [];
          flowState.build.logs = [];
          flowState.build.lastSpecString = specString != null ? specString : null;
        } else if (state === "done") {
          flowState.build.summary = summary || null;
          flowState.build.warnings = Array.isArray(warnings) ? warnings : [];
          flowState.build.logs = formatLogEntries(logs, MAX_BUILD_LOG_LINES);
          flowState.build.lastSpecString = specString != null ? specString : flowState.build.lastSpecString;
        } else if (state === "error") {
          flowState.build.summary = null;
          flowState.build.warnings = Array.isArray(warnings) ? warnings : [];
          flowState.build.logs = formatLogEntries(logs, MAX_BUILD_LOG_LINES);
          if (specString != null) {
            flowState.build.lastSpecString = specString;
          }
        }

        if (state === "idle" || reset) {
          flowState.build.summary = null;
          flowState.build.warnings = [];
          flowState.build.logs = [];
          if (reset) {
            flowState.build.lastSpecString = null;
          }
        }

        renderBuildState();
        if (!skipUpdateButtons) {
          updateActionButtons();
        }
      }

      function setExportState(state, options = {}) {
        const {
          message = "",
          errors = [],
          logs = [],
          specString = null,
          downloadUrl = null,
          downloadFilename = "ExportSpec.json",
          reset = false,
          skipUpdateButtons = false,
        } = options;

        if (state === "idle" || reset) {
          flowState.export.state = "idle";
          flowState.export.message = message || "";
          flowState.export.errors = [];
          flowState.export.logs = [];
          if (reset || specString === null) {
            flowState.export.lastSpecString = null;
          }
          clearExportDownload();
          renderExportState();
          if (!skipUpdateButtons) {
            updateActionButtons();
          }
          return;
        }

        flowState.export.state = state;
        flowState.export.message = message || "";
        flowState.export.errors = Array.isArray(errors) ? errors : [];
        flowState.export.logs = formatLogEntries(logs, MAX_EXPORT_LOG_LINES);
        if (specString != null) {
          flowState.export.lastSpecString = specString;
        }

        if (state === "done") {
          clearExportDownload();
          flowState.export.downloadFilename = downloadFilename || "ExportSpec.json";
          flowState.export.downloadUrl = downloadUrl || null;
        }

        if (state === "error") {
          clearExportDownload();
        }

        renderExportState();
        if (!skipUpdateButtons) {
          updateActionButtons();
        }
      }

      function setValidateState(state, options = {}) {
        const {
          message = "",
          hint = "",
          errors = [],
          specString = null,
          keepSpec = false,
          skipReset = false,
          skipUpdateButtons = false,
        } = options;

        flowState.validate.state = state;
        flowState.validate.message = message || "";
        flowState.validate.hint = hint || "";
        flowState.validate.errors = Array.isArray(errors) ? errors : [];

        if (state === "valid") {
          flowState.validate.lastSpecString =
            specString != null ? specString : getCurrentSpecString();
        } else if (!keepSpec) {
          flowState.validate.lastSpecString = null;
        }

        renderValidateState();

        if (!skipReset && state !== "valid") {
          setBuildState("idle", { reset: true, skipUpdateButtons: true });
          setExportState("idle", { reset: true, skipUpdateButtons: true });
        }

        if (!skipUpdateButtons) {
          updateActionButtons();
        }
      }

      const handleSpecUpdated = (source = "user") => {
        const current = getCurrentSpecString();
        if (
          flowState.validate.state === "valid" &&
          flowState.validate.lastSpecString === current
        ) {
          updateActionButtons();
          return;
        }
        if (flowState.validate.state !== "idle" || flowState.validate.lastSpecString !== null) {
          const message =
            source === "user" ? "TaskSpec изменён. Нажмите Validate." : flowState.validate.message;
          setValidateState("idle", { message });
        } else {
          updateActionButtons();
        }
      };

      const tryRemoteTaskSpecValidation = async (spec, guardToken) => {
        const relayHost = getRelayBaseUrl();
        const normalizedHost = typeof relayHost === "string" ? relayHost.trim() : "";
        if (!normalizedHost || normalizedHost === "disabled") {
          return { attempted: false };
        }
        const init = {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify({ taskSpec: spec }),
        };
        if (guardToken && guardToken.signal) {
          init.signal = guardToken.signal;
        }
        try {
          const response = await relayFetch(
            buildRelayUrl(`/validate/taskSpec`, { includeApiKey: false }),
            init,
          );
          if (guardToken && !validateRequestGuard.isActive(guardToken.token)) {
            return { aborted: true };
          }
          if (response.ok) {
            const data = await response.json();
            return {
              attempted: true,
              ok: true,
              valid: !!(data && data.valid),
              errors: Array.isArray(data && data.errors) ? data.errors : [],
              raw: data,
            };
          }
          if (response.status === 401) {
            return { attempted: true, ok: false, status: 401, unauthorized: true };
          }
          let payload;
          try {
            payload = await response.json();
          } catch (_) {
            try {
              payload = await response.text();
            } catch (_) {
              payload = null;
            }
          }
          return {
            attempted: true,
            ok: false,
            status: response.status,
            message: parseServerError(payload, `HTTP ${response.status}`),
          };
        } catch (error) {
          if (guardToken && !validateRequestGuard.isActive(guardToken.token)) {
            return { aborted: true };
          }
          return {
            attempted: true,
            ok: false,
            error,
            networkError: true,
            message: parseServerError(error),
          };
        }
      };

      const triggerBuild = (specString, options = {}) => {
        const { source = "manual", skipValidationCheck = false } = options;
        const payload = specString != null ? specString : getCurrentSpecString();
        if (!payload) return false;
        if (!skipValidationCheck && !canBuild()) {
          return false;
        }
        setExportState("idle", { reset: true, skipUpdateButtons: true });
        operationContext.buildSpec = payload;
        inflightOperations.build = true;
        const message = source === "runner" ? "Runner: Build выполняется…" : "Build выполняется…";
        setBuildState("running", { message, specString: payload });
        post("build", payload);
        return true;
      };

      const triggerExport = (specString, options = {}) => {
        const { source = "manual", skipBuildCheck = false } = options;
        const payload = specString != null ? specString : getCurrentSpecString();
        if (!payload) return false;
        if (!skipBuildCheck && !canExport()) {
          return false;
        }
        operationContext.exportSpec = payload;
        inflightOperations.export = true;
        const message = source === "runner" ? "Runner: Export выполняется…" : "Export выполняется…";
        setExportState("running", { message, specString: payload });
        post("export", payload);
        return true;
      };
      const flowElements = {
        import: {
          panel: document.getElementById("import-panel"),
          status: document.getElementById("import-status"),
          message: document.getElementById("import-message"),
          hint: document.getElementById("import-hint"),
          warnings: document.getElementById("import-warnings"),
          sections: document.getElementById("import-sections"),
          preview: document.getElementById("import-preview"),
          actions: document.getElementById("import-actions"),
          saveButton: document.getElementById("btn-import-save"),
        },
        validate: {
          panel: document.getElementById("validate-panel"),
          status: document.getElementById("validate-status"),
          message: document.getElementById("validate-message"),
          hint: document.getElementById("validate-hint"),
          errors: document.getElementById("validate-errors"),
        },
        build: {
          panel: document.getElementById("build-panel"),
          status: document.getElementById("build-status"),
          message: document.getElementById("build-message"),
          summary: document.getElementById("build-summary"),
          warnings: document.getElementById("build-warnings"),
          logs: document.getElementById("build-logs"),
        },
        export: {
          panel: document.getElementById("export-panel"),
          status: document.getElementById("export-status"),
          message: document.getElementById("export-message"),
          errors: document.getElementById("export-errors"),
          logs: document.getElementById("export-logs"),
        },
      };
      specTextareaEl = document.getElementById("spec");
      validateButton = document.getElementById("btn-validate");
      buildButton = document.getElementById("btn-build");
      importButton = document.getElementById("btn-import");
      proposeButton = document.getElementById("btn-propose");
      inferButton = document.getElementById("btn-infer");
      const importSaveButton = document.getElementById("btn-import-save");
      exportButton = document.getElementById("btn-export");
      const exportDownloadLink = document.getElementById("download");

      const statusPanelEl = document.getElementById("status-panel");
      const statusTextEl = document.getElementById("status-text");
      const statusLogEl = document.getElementById("status-log");
      const statusConnectionEl = document.getElementById("status-connection");
      artifactLinkEl = document.getElementById("artifact-download");
      artifactZipLinkEl = document.getElementById("artifact-zip-download");
      const pullModeEl = document.getElementById("pull-mode");
      if (pullModeEl) {
        pullModeEnabled = !!pullModeEl.checked;
        pullModeEl.addEventListener("change", (event) => {
          pullModeEnabled = !!event.target.checked;
          rlog(`Pull mode ${pullModeEnabled ? "enabled" : "disabled"}`);
        });
      }

      function updateArtifactLinks() {
        if (artifactLinkEl) {
          if (lastTaskId) {
            artifactLinkEl.href = buildRelayUrl(
              `/tasks/${lastTaskId}/artifact`,
              { includeApiKey: !!RELAY_API_KEY },
            );
            artifactLinkEl.setAttribute("aria-disabled", "false");
          } else {
            artifactLinkEl.href = "#";
            artifactLinkEl.setAttribute("aria-disabled", "true");
          }
        }
        if (artifactZipLinkEl) {
          if (lastTaskId) {
            artifactZipLinkEl.href = buildRelayUrl(
              `/tasks/${lastTaskId}/package.zip`,
              { includeApiKey: !!RELAY_API_KEY },
            );
            artifactZipLinkEl.setAttribute("aria-disabled", "false");
          } else {
            artifactZipLinkEl.href = "#";
            artifactZipLinkEl.setAttribute("aria-disabled", "true");
          }
        }
      }

      const setTaskSpecTextarea = (taskSpec) => {
        if (!specTextareaEl || taskSpec == null) return;
        if (typeof taskSpec === "string") {
          specTextareaEl.value = taskSpec;
        } else {
          try {
            specTextareaEl.value = JSON.stringify(taskSpec, null, 2);
          } catch (err) {
            specTextareaEl.value = String(taskSpec);
          }
        }
        handleSpecUpdated("programmatic");
      };

      if (specTextareaEl) {
        specTextareaEl.addEventListener("input", () => {
          handleSpecUpdated("user");
        });
      }

      const assignFetchedTask = async (taskId, taskSpec, label, logMessage) => {
        if (!taskId) {
          rlog(`${label}: no tasks available`);
          lastTaskId = null;
          updateArtifactLinks();
          closeStatusSource();
          return;
        }
        lastTaskId = taskId;
        updateArtifactLinks();
        setTaskSpecTextarea(taskSpec);
        rlog(`${label} OK (id=${taskId})`);
        openTaskWatch(taskId);
        if (!logMessage) return;
        try {
          await relayFetch(buildRelayUrl(`/tasks/${taskId}/log`), {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify({ message: logMessage }),
          });
        } catch (logErr) {
          rlog(
            "Log append error: " +
              (logErr && logErr.message ? logErr.message : logErr)
          );
        }
      };

      const formatStatusLogEntry = (entry) => {
        if (!entry) return "";
        if (typeof entry === "string") return entry;
        const msg = entry.message || "";
        if (entry.ts) {
          return `[${entry.ts}] ${msg}`;
        }
        return msg;
      };

      const renderStatusLogs = () => {
        if (!statusLogEl) return;
        statusLogEl.textContent = statusLogs.join("\n");
        statusLogEl.scrollTop = statusLogEl.scrollHeight;
      };

      const setStatusState = (state) => {
        if (!statusPanelEl || !statusTextEl) return;
        const normalized = typeof state === "string" && state ? state : "unknown";
        statusPanelEl.dataset.state = normalized.toLowerCase();
        statusTextEl.textContent = normalized;
      };

      const setStatusLogs = (entries) => {
        statusLogs = [];
        if (Array.isArray(entries)) {
          for (const entry of entries) {
            const line = formatStatusLogEntry(entry);
            if (line) statusLogs.push(line);
          }
        }
        if (statusLogs.length > STATUS_LOG_LIMIT) {
          statusLogs = statusLogs.slice(-STATUS_LOG_LIMIT);
        }
        renderStatusLogs();
        if (artifactDetailsState.open && artifactDetailsState.taskId === currentWatchTaskId) {
          artifactDetailsState.logs = Array.isArray(entries)
            ? entries.map((entry) => formatStatusLogEntry(entry)).filter(Boolean)
            : [];
          if (artifactDetailsState.logs.length > STATUS_LOG_LIMIT) {
            artifactDetailsState.logs = artifactDetailsState.logs.slice(-STATUS_LOG_LIMIT);
          }
          if (artifactDetailsState.logsPaused) {
            artifactDetailsState.pendingLogCount = 0;
          } else {
            artifactDetailsRenderedLogs = artifactDetailsState.logs.join("\n");
          }
          renderArtifactDetailsLogs();
        }
      };

      const appendStatusLogEntry = (entry) => {
        const line = formatStatusLogEntry(entry);
        if (!line) return;
        statusLogs.push(line);
        if (statusLogs.length > STATUS_LOG_LIMIT) {
          statusLogs = statusLogs.slice(-STATUS_LOG_LIMIT);
        }
        renderStatusLogs();
        if (artifactDetailsState.open && artifactDetailsState.taskId === currentWatchTaskId) {
          artifactDetailsState.logs.push(line);
          if (artifactDetailsState.logs.length > STATUS_LOG_LIMIT) {
            artifactDetailsState.logs = artifactDetailsState.logs.slice(-STATUS_LOG_LIMIT);
          }
          if (artifactDetailsState.logsPaused) {
            artifactDetailsState.pendingLogCount += 1;
          } else {
            artifactDetailsRenderedLogs = artifactDetailsState.logs.join("\n");
          }
          renderArtifactDetailsLogs();
        }
      };

      const setConnectionState = (state, label) => {
        if (!statusConnectionEl) return;
        const value = state || "closed";
        statusConnectionEl.dataset.state = value;
        statusConnectionEl.textContent = label || value;
      };

      const closeStatusSource = () => {
        if (statusSource) {
          statusSource.close();
          statusSource = null;
        }
        currentWatchTaskId = null;
        setConnectionState("closed", "disconnected");
      };

      const openTaskWatch = (taskId) => {
        if (!taskId) return;
        if (taskId === currentWatchTaskId && statusSource) return;
        closeStatusSource();
        currentWatchTaskId = taskId;
        setStatusLogs([]);
        setStatusState("pending");
        setConnectionState("connecting", "connecting...");
        try {
          const watchUrl = buildRelayUrl(`/tasks/${taskId}/watch`, {
            includeApiKey: !!RELAY_API_KEY,
          });
          const source = new EventSource(watchUrl);
          statusSource = source;
          source.onopen = () => {
            setConnectionState("connected", "connected");
          };
          source.addEventListener("status", (event) => {
            try {
              const data = JSON.parse(event.data);
              setStatusState(data && data.status ? data.status : "pending");
              setStatusLogs(data && data.logs ? data.logs : []);
              if (artifactDetailsState.open && artifactDetailsState.taskId === taskId) {
                let needsRender = false;
                if (data && typeof data.status === "string") {
                  if (artifactDetailsState.task) {
                    if (artifactDetailsState.task.status !== data.status) {
                      artifactDetailsState.task.status = data.status;
                      needsRender = true;
                    }
                  } else {
                    artifactDetailsState.task = { status: data.status };
                    needsRender = true;
                  }
                }
                if (data && Number.isFinite(data.progress)) {
                  const numeric = Number(data.progress);
                  if (artifactDetailsState.progress !== numeric) {
                    artifactDetailsState.progress = numeric;
                    needsRender = true;
                  }
                }
                if (needsRender) {
                  renderArtifactDetails();
                }
              }
            } catch (err) {
              rlog(
                "Failed to parse status event: " +
                  (err && err.message ? err.message : err)
              );
            }
          });
          source.addEventListener("log", (event) => {
            try {
              const data = JSON.parse(event.data);
              appendStatusLogEntry(data);
            } catch (err) {
              rlog(
                "Failed to parse log event: " +
                  (err && err.message ? err.message : err)
              );
            }
          });
          source.addEventListener("result", (event) => {
            try {
              const data = JSON.parse(event.data);
              setStatusState(data && data.status ? data.status : "done");
              if (artifactDetailsState.open && artifactDetailsState.taskId === taskId) {
                if (data && Number.isFinite(data.progress)) {
                  artifactDetailsState.progress = Number(data.progress);
                } else {
                  artifactDetailsState.progress = null;
                }
                if (artifactDetailsState.task && data && typeof data.status === "string") {
                  artifactDetailsState.task.status = data.status;
                }
                renderArtifactDetails();
              }
              updateArtifactLinks();
              setTimeout(() => {
                if (statusSource === source) {
                  closeStatusSource();
                }
              }, 3000);
            } catch (err) {
              rlog(
                "Failed to parse result event: " +
                  (err && err.message ? err.message : err)
              );
            }
          });
          source.addEventListener("preview", (event) => {
            try {
              const data = JSON.parse(event.data);
              appendStatusLogEntry({
                message: "Preview updated",
              });
              if (!artifactsState.loading && artifactsState.initialized) {
                fetchArtifacts();
              }
              if (artifactDetailsState.open && artifactDetailsState.taskId === taskId) {
                if (typeof data.hasPreview === "boolean") {
                  artifactDetailsState.hasPreview = data.hasPreview;
                } else {
                  artifactDetailsState.hasPreview = true;
                }
                if (typeof data.previewUrl === "string") {
                  artifactDetailsState.previewUrl = data.previewUrl;
                }
                if (Number.isFinite(data.previewUpdatedAt)) {
                  artifactDetailsState.previewUpdatedAt = Number(data.previewUpdatedAt);
                }
                renderArtifactDetails();
              }
            } catch (err) {
              rlog(
                "Failed to parse preview event: " +
                  (err && err.message ? err.message : err)
              );
            }
          });
          source.onerror = () => {
            if (source.readyState === EventSource.CLOSED) {
              setConnectionState("closed", "disconnected");
            } else {
              setConnectionState("error", "error (retrying)");
            }
            rlog(`SSE connection error for task ${taskId}`);
          };
        } catch (err) {
          setConnectionState("error", "error");
          rlog(
            "Failed to open SSE subscription: " +
              (err && err.message ? err.message : err)
          );
        }
      };

      window.addEventListener("beforeunload", () => {
        closeStatusSource();
      });

      setStatusLogs([]);
      setStatusState("idle");
      setConnectionState("closed", "disconnected");
      updateArtifactLinks();
      const sample = {
        meta: { specVersion: "0.1", id: "landing-v1" },
        target: {
          fileId: "REPLACE_WITH_FILE_ID",
          pageName: "Landing",
          frameName: "Home",
          frameSize: { w: 1440, h: 1024 },
        },
        grid: { container: 1200, columns: 12, gap: 24, margins: 24 },
        tokens: {
          fontFamily: "Inter",
          colors: { primary: "#6C5CE7", text: "#111827" },
        },
        sections: [
          {
            type: "hero",
            name: "Hero",
            padding: [64, 24],
            spacing: 24,
            layout: "stack",
            content: {
              title: "Заголовок",
              subtitle: "Подзаголовок",
              cta: "Купить",
            },
          },
          {
            type: "features",
            name: "Преимущества",
            layout: "grid-3",
            spacing: 32,
            content: {
              items: [
                { title: "Быстро" },
                { title: "Дёшево" },
                { title: "Точно" },
              ],
            },
          },
          {
            type: "cta",
            name: "Призыв",
            padding: [48, 24],
            content: { text: "Начать сейчас", button: "Попробовать" },
          },
          { type: "footer", name: "Подвал", padding: [48, 24] },
        ],
        acceptance: { maxSpacingDeviation: 2, checkAutoLayout: true },
      };
      setTaskSpecTextarea(sample);
      setValidateState("idle", {
        message: "Готово к проверке. Нажмите Validate.",
        keepSpec: true,
        skipReset: true,
      });
      renderImportState();
      renderBuildState();
      renderExportState();
      updateActionButtons();

      const post = (type, overrideSpec) => {
        const textarea = document.getElementById("spec");
        const val =
          overrideSpec != null
            ? overrideSpec
            : textarea && typeof textarea.value === "string"
              ? textarea.value
              : "";
        parent.postMessage({ pluginMessage: { type, taskSpec: val } }, "*");
      };

      if (validateButton) {
        validateButton.addEventListener("click", async () => {
          if (validateInProgress) return;
          const raw = getCurrentSpecString();
          if (!raw || !raw.trim()) {
            const message = "TaskSpec пуст. Вставьте JSON для проверки.";
            setValidateState("error", { message });
            showToast({ message, type: "error" });
            log(message);
            return;
          }

          let parsed;
          try {
            parsed = JSON.parse(raw);
          } catch (error) {
            const message = `Некорректный JSON: ${error && error.message ? error.message : error}`;
            setValidateState("error", { message });
            showToast({ message, type: "error" });
            log(`Validate error: ${message}`);
            return;
          }

          validateInProgress = true;
          updateActionButtons();
          const guardToken = validateRequestGuard.start();

          try {
            const remoteResult = await tryRemoteTaskSpecValidation(parsed, guardToken);
            if (!validateRequestGuard.isActive(guardToken.token)) {
              return;
            }

            let hint = "";
            if (remoteResult && remoteResult.attempted && !remoteResult.ok) {
              if (remoteResult.unauthorized || remoteResult.networkError) {
                hint = VALIDATOR_AUTH_HINT;
                showToast({ message: VALIDATOR_AUTH_HINT, type: "error", duration: 5200 });
              } else if (remoteResult.message) {
                hint = remoteResult.message;
                showToast({ message: remoteResult.message, type: "error" });
              }
            }

            const localResult = validateTaskSpecSchema(parsed);
            let finalState = "valid";
            let finalMessage = "TaskSpec валиден";
            let errors = [];

            if (remoteResult && remoteResult.attempted && remoteResult.ok && !remoteResult.valid) {
              finalState = "invalid";
              errors = normalizeSchemaErrors(remoteResult.errors);
              finalMessage = "TaskSpec не проходит проверку схемы";
            } else if (!localResult.valid) {
              finalState = "invalid";
              errors = localResult.errors;
              finalMessage = "TaskSpec не проходит проверку схемы";
            } else if (remoteResult && remoteResult.attempted && !remoteResult.ok) {
              finalMessage = "TaskSpec валиден (offline)";
            }

            if (finalState === "invalid") {
              if (!errors.length && remoteResult && remoteResult.errors) {
                errors = normalizeSchemaErrors(remoteResult.errors);
              }
              if (!errors.length && localResult && Array.isArray(localResult.errors)) {
                errors = localResult.errors;
              }
              if (errors.length) {
                log("TaskSpec schema validation failed:");
                errors.forEach((entry) => {
                  const path = entry && entry.path ? entry.path : "/";
                  const text = entry && entry.message ? entry.message : "Invalid value";
                  log(` - ${path}: ${text}`);
                });
              }
              setValidateState("invalid", { message: finalMessage, errors, hint });
              showToast({ message: finalMessage, type: "error" });
              log("TaskSpec schema validation failed");
              return;
            }

            setValidateState("valid", {
              message: finalMessage,
              hint,
              specString: raw,
              errors: [],
            });
            showToast({ message: finalMessage, type: "success" });
            operationContext.validateSpec = raw;
            inflightOperations.validate = true;
            post("validate", raw);
          } catch (error) {
            const message = parseServerError(error, "Ошибка валидации");
            setValidateState("error", { message });
            showToast({ message, type: "error" });
            log(`Validate error: ${message}`);
          } finally {
            if (validateRequestGuard.isActive(guardToken.token)) {
              validateRequestGuard.finish(guardToken.token);
            }
            validateInProgress = false;
            updateActionButtons();
          }
        });
      }
      if (buildButton) {
        buildButton.addEventListener("click", () => {
          if (!triggerBuild()) {
            showToast({ message: "Build доступен после успешной Validate.", type: "error" });
          }
        });
      }
      if (importButton) {
        importButton.addEventListener("click", () => {
          if (!canImport()) {
            showToast({
              message: "Импорт доступен при выделении одного фрейма.",
              type: "error",
            });
            return;
          }
          requestSelectionImport();
        });
      }
      if (proposeButton) {
        proposeButton.addEventListener("click", () => {
          if (!canProposeTaskSpec()) {
            showToast({
              message: "Сначала выполните Import из выделения.",
              type: "error",
            });
            return;
          }
          post("propose:taskspec");
        });
      }
      if (inferButton) {
        inferButton.addEventListener("click", () => {
          if (isRunnerActive()) {
            showToast({
              message: "Генерация недоступна при активном Runner.",
              type: "error",
            });
            return;
          }
          if (inflightOperations.import) {
            showToast({
              message: "Дождитесь завершения импорта перед генерацией TaskSpec.",
              type: "error",
            });
            return;
          }
          if (flowState.import.exportSpec) {
            runTaskSpecInference(flowState.import.exportSpec, { source: "import" });
            return;
          }
          if (!selectionState.isSingleFrame) {
            showToast({
              message: "Выделите один фрейм для генерации TaskSpec.",
              type: "error",
            });
            return;
          }
          pendingInference = { source: "selection" };
          log("Inference: requesting ExportSpec from selection");
          requestSelectionImport();
        });
      }
      if (importSaveButton) {
        importSaveButton.addEventListener("click", () => {
          if (!flowState.import.downloadUrl) return;
          const link = document.createElement("a");
          link.href = flowState.import.downloadUrl;
          link.download =
            flowState.import.downloadFilename || "ExportSpec.selection.json";
          document.body.appendChild(link);
          link.click();
          setTimeout(() => link.remove(), 0);
        });
      }
      if (exportButton) {
        exportButton.addEventListener("click", () => {
          if (!triggerExport()) {
            showToast({ message: "Export доступен после успешного Build.", type: "error" });
          }
        });
      }
      document.getElementById("btn-fetch").onclick = async () => {
        try {
          if (pullModeEnabled) {
            const url = new URL(buildRelayUrl(`/tasks/pull`));
            const pluginId = getRunnerPluginId();
            if (pluginId) {
              url.searchParams.set("pluginId", pluginId);
            }
            const res = await relayFetch(url.toString());
            if (!res.ok) {
              return rlog(`Pull failed: ${res.status}`);
            }
            const data = await res.json();
            await assignFetchedTask(
              data && data.taskId ? data.taskId : null,
              data ? data.taskSpec : null,
              "Pull",
              "Plugin: pulled task into textarea"
            );
          } else {
            const res = await relayFetch(
              buildRelayUrl(`/tasks/latest?status=pending`),
            );
            if (!res.ok) {
              return rlog(`Fetch failed: ${res.status}`);
            }
            const data = await res.json();
            await assignFetchedTask(
              data && data.id ? data.id : null,
              data ? data.taskSpec : null,
              "Fetched",
              "Plugin: fetched task into textarea"
            );
          }
        } catch (e) {
          rlog("Fetch error: " + (e && e.message ? e.message : e));
        }
      };
      document.getElementById("btn-close").onclick = () => {
        closeStatusSource();
        lastTaskId = null;
        updateArtifactLinks();
        post("close");
      };

      onmessage = async (e) => {
        const msg = e.data && e.data.pluginMessage;
        if (!msg) return;
        if (msg.type === "selection:update") {
          updateImportSelectionState(msg.selection || null);
          renderImportState();
          updateActionButtons();
          return;
        }
        if (msg.type === "import:ok") {
          inflightOperations.import = false;
          updateImportSelectionState(msg.selection || null);
          const exportSpec = msg.exportSpec;
          if (!exportSpec) {
            setImportState("error", { message: "ExportSpec отсутствует" });
            updateActionButtons();
            return;
          }
          const specString = stringifyJson(exportSpec) || "";
          let downloadUrl = null;
          try {
            downloadUrl = URL.createObjectURL(
              new Blob([specString], { type: "application/json" }),
            );
          } catch (_) {}
          const summaryWarnings =
            exportSpec &&
            exportSpec.summary &&
            Array.isArray(exportSpec.summary.warnings)
              ? exportSpec.summary.warnings
              : [];
          const extraWarnings = Array.isArray(msg.warnings) ? msg.warnings : [];
          const warnings = Array.from(
            new Set(
              [...summaryWarnings, ...extraWarnings].map((entry) =>
                typeof entry === "string" ? entry : String(entry),
              ),
            ),
          );
          const fallbackName = selectionState.isSingleFrame && selectionState.frameName
            ? `ExportSpec - ${selectionState.frameName}`
            : "ExportSpec.selection";
          const rawFilename =
            typeof msg.filename === "string" && msg.filename.trim()
              ? msg.filename.trim()
              : fallbackName;
          const sanitizedName = sanitizeFilename(rawFilename, "ExportSpec.selection");
          const finalFilename = /\.json$/i.test(sanitizedName)
            ? sanitizedName
            : `${sanitizedName}.json`;
          setImportState("done", {
            message: "ExportSpec импортирован из выделения",
            warnings,
            specString,
            downloadUrl,
            downloadFilename: finalFilename,
            hint: flowState.import.hint,
            exportSpec,
          });
          showToast({ message: "Import завершён", type: "success" });
          log("Import OK");
          operationContext.importSpec = exportSpec;
          if (pendingInference) {
            const context = pendingInference;
            pendingInference = null;
            runTaskSpecInference(exportSpec, {
              source: context.source || "selection",
            });
          }
          return;
        }
        if (msg.type === "import:error") {
          inflightOperations.import = false;
          updateImportSelectionState(msg.selection || null);
          const message = msg.error ? String(msg.error) : "Import error";
          const warnings = Array.isArray(msg.warnings) ? msg.warnings : [];
          setImportState("error", { message, warnings, hint: flowState.import.hint });
          if (pendingInference) {
            pendingInference = null;
          }
          showToast({ message, type: "error" });
          log(`Import error: ${message}`);
          updateActionButtons();
          return;
        }
        if (msg.type === "propose:taskspec:ok") {
          const draft = msg.taskSpec || null;
          const warnings = Array.isArray(msg.warnings) ? msg.warnings : [];
          if (draft) {
            setTaskSpecTextarea(draft);
            log("Propose TaskSpec OK");
            showToast({ message: "Черновик TaskSpec вставлен", type: "success" });
          }
          if (warnings.length) {
            warnings.forEach((entry) => {
              const text = typeof entry === "string" ? entry : String(entry);
              log(`Propose warning: ${text}`);
            });
            showToast({ message: warnings[0], type: "warning" });
          }
          updateActionButtons();
          return;
        }
        if (msg.type === "propose:taskspec:error") {
          const message = msg.error ? String(msg.error) : "Propose error";
          showToast({ message, type: "error" });
          log(`Propose error: ${message}`);
          updateActionButtons();
          return;
        }
        if (msg.type === "validate:ok") {
          inflightOperations.validate = false;
          operationContext.validateSpec = null;
          validateInProgress = false;
          if (flowState.validate.state !== "valid") {
            setValidateState("valid", {
              message: "TaskSpec валиден",
              specString: getCurrentSpecString(),
            });
          }
          updateActionButtons();
          log("Validate OK");
          return;
        }
        if (msg.type === "validate:error") {
          inflightOperations.validate = false;
          operationContext.validateSpec = null;
          validateInProgress = false;
          const rawMessage = msg.error ? String(msg.error) : "Validate error";
          const normalizedErrors = normalizeSchemaErrors(msg.errors);
          const message =
            normalizedErrors.length && (!rawMessage || rawMessage === "Validate error")
              ? "TaskSpec не проходит проверку схемы"
              : rawMessage;
          if (normalizedErrors.length) {
            setValidateState("invalid", { message, errors: normalizedErrors });
            log("TaskSpec schema validation failed:");
            normalizedErrors.forEach((entry) => {
              const path = entry && entry.path ? entry.path : "/";
              const text = entry && entry.message ? entry.message : "Invalid value";
              log(` - ${path}: ${text}`);
            });
          } else {
            setValidateState("error", { message });
          }
          showToast({ message, type: "error" });
          log(`ERROR: ${message}`);
          updateActionButtons();
          return;
        }
        if (msg.type === "build:ok") {
          inflightOperations.build = false;
          const specString = operationContext.buildSpec || getCurrentSpecString();
          operationContext.buildSpec = null;

          const summary = msg.report
            ? {
                created: Number.isFinite(msg.report.created) ? msg.report.created : 0,
                updated: Number.isFinite(msg.report.updated) ? msg.report.updated : 0,
                removed: Number.isFinite(msg.report.removed) ? msg.report.removed : 0,
              }
            : null;
          const warnings =
            msg.report && Array.isArray(msg.report.warnings) ? msg.report.warnings : [];
          const logs = Array.isArray(msg.logs) ? msg.logs : [];
          const messageLabel = Number.isFinite(msg.sections)
            ? `Build завершён (sections=${msg.sections})`
            : "Build завершён";

          setBuildState("done", {
            message: messageLabel,
            summary,
            warnings,
            logs,
            specString,
          });
          setExportState("idle", { message: "Готов к Export" });
          showToast({ message: "Build завершён", type: "success" });

          log("Build OK: sections=" + msg.sections);
          if (summary) {
            log(
              `Build summary → created: ${summary.created}, updated: ${summary.updated}, removed: ${summary.removed}`,
            );
            warnings.forEach((warning) => {
              log(`Warning: ${warning}`);
            });
          }

          if (runnerState.processing) {
            runnerState.summary = summary;
            runnerState.warnings = warnings;
            renderRunnerState();
          }

          if (runnerState.processing && runnerState.waitingFor === "build") {
            appendRunnerLog(
              `Build OK${Number.isFinite(msg.sections) ? ` (sections=${msg.sections})` : ""}`,
            );
            runnerState.waitingFor = "export";
            if (runnerState.currentSpecString) {
              setRunnerStatus("running", "export");
              appendRunnerLog("Running export…");
              triggerExport(runnerState.currentSpecString, {
                source: "runner",
                skipBuildCheck: true,
              });
            } else {
              appendRunnerLog("Missing TaskSpec for export");
              await finalizeRunnerFailure("Missing TaskSpec");
            }
          }
          return;
        }
        if (msg.type === "export:ok") {
          inflightOperations.export = false;
          const exportSpec = msg.exportSpec;
          const previewPayload = msg.preview;
          const previewError = msg.previewError;
          const exportLogs = Array.isArray(msg.logs) ? msg.logs : [];
          const specString = operationContext.exportSpec || getCurrentSpecString();
          operationContext.exportSpec = null;

          let validationFailed = false;
          let validationErrors = [];
          let validationMessage = "ExportSpec не проходит проверку схемы";
          let fallbackMessage = "";
          if (exportSpec) {
            try {
              const res = await relayFetch(buildRelayUrl(`/validate/exportSpec`), {
                method: "POST",
                headers: { "Content-Type": "application/json" },
                body: JSON.stringify({ exportSpec }),
              });
              if (res.ok) {
                const data = await res.json();
                if (!data.valid) {
                  validationFailed = true;
                  validationErrors = Array.isArray(data.errors) ? data.errors : [];
                }
              } else if (res.status === 401) {
                fallbackMessage = "ExportSpec готов (валидация оффлайн)";
                showToast({ message: VALIDATOR_AUTH_HINT, type: "error", duration: 5200 });
              } else {
                let payload = null;
                try {
                  payload = await res.json();
                } catch (_) {
                  try {
                    payload = await res.text();
                  } catch (_) {}
                }
                const message = parseServerError(payload, `HTTP ${res.status}`);
                rlog(`ExportSpec validation request failed: ${message}`);
                showToast({ message, type: "error" });
                fallbackMessage = `ExportSpec готов (валидатор: ${message})`;
              }
            } catch (err) {
              const message = parseServerError(err);
              rlog(`ExportSpec validation request error: ${message}`);
              showToast({ message, type: "error" });
              fallbackMessage = "ExportSpec готов (валидация оффлайн)";
            }
          } else {
            validationFailed = true;
            validationErrors = [{ path: "/", message: "ExportSpec отсутствует" }];
            validationMessage = "ExportSpec отсутствует";
          }

          if (validationFailed) {
            const normalizedErrors = normalizeSchemaErrors(validationErrors);
            if (normalizedErrors.length) {
              log("ExportSpec schema validation failed:");
              normalizedErrors.forEach((entry) => {
                const path = entry && entry.path ? entry.path : "/";
                const text = entry && entry.message ? entry.message : "Invalid value";
                log(` - ${path}: ${text}`);
              });
            }
            setExportState("error", {
              message: validationMessage,
              errors: normalizedErrors,
              logs: exportLogs,
              specString,
            });
            showToast({ message: validationMessage, type: "error" });
            log("ExportSpec schema validation failed");
            return;
          }

          log(exportSpec);
          const blob = new Blob([JSON.stringify(exportSpec, null, 2)], {
            type: "application/json",
          });
          const downloadUrl = URL.createObjectURL(blob);
          const successMessage = fallbackMessage || "ExportSpec готов";
          setExportState("done", {
            message: successMessage,
            errors: [],
            logs: exportLogs,
            specString,
            downloadUrl,
            downloadFilename: msg.filename || "ExportSpec.json",
          });
          showToast({ message: successMessage, type: "success" });

          let runnerPostErrorMessage = null;
          if (lastTaskId) {
            let resultPosted = false;
            try {
              const resultPayload = {
                taskId: lastTaskId,
                exportSpec,
                logs: buildRunnerResultLogs(flowState.build.logs, exportLogs),
              };
              if (runnerState.summary) {
                resultPayload.summary = {
                  created: Number(runnerState.summary.created) || 0,
                  updated: Number(runnerState.summary.updated) || 0,
                  removed: Number(runnerState.summary.removed) || 0,
                };
              }
              if (Array.isArray(runnerState.warnings) && runnerState.warnings.length) {
                resultPayload.warnings = runnerState.warnings;
              }
              const resultResponse = await relayFetch(buildRelayUrl(`/results`), {
                method: "POST",
                headers: { "Content-Type": "application/json" },
                body: JSON.stringify(resultPayload),
              });
              if (!resultResponse.ok) {
                let message = `HTTP ${resultResponse.status}`;
                try {
                  const payload = await resultResponse.json();
                  message = parseServerError(payload, message);
                } catch (_) {
                  try {
                    const text = await resultResponse.text();
                    if (text && text.trim()) {
                      message = text.trim();
                    }
                  } catch (_) {}
                }
                if (resultResponse.status === 401) {
                  runnerState.hintMessage = RUNNER_AUTH_HINT;
                } else if (resultResponse.status === 413) {
                  runnerState.hintMessage = RUNNER_PAYLOAD_HINT;
                }
                rlog(`Result post failed: ${message}`);
                runnerPostErrorMessage = runnerPostErrorMessage || message;
              } else {
                resultPosted = true;
                runnerState.hintMessage = null;
                rlog(`Result posted for task ${lastTaskId}`);
                if (runnerState.processing && runnerState.waitingFor === "export") {
                  appendRunnerLog("Result posted");
                }
                updateArtifactLinks();
                const logOk = await runnerPostLog(
                  lastTaskId,
                  "Plugin: result posted (export:ok)",
                );
                if (!logOk) {
                  runnerPostErrorMessage = runnerPostErrorMessage || "Task log append failed";
                }
              }
            } catch (err) {
              rlog(
                "Result post error: " +
                  (err && err.message ? err.message : err)
              );
              runnerPostErrorMessage =
                runnerPostErrorMessage || (err && err.message ? err.message : String(err));
            }

            if (
              resultPosted &&
              previewPayload &&
              typeof previewPayload.base64 === "string" &&
              previewPayload.base64 &&
              previewPayload.contentType === "image/png"
            ) {
              try {
                const response = await relayFetch(buildRelayUrl(`/tasks/${lastTaskId}/preview`), {
                  method: "POST",
                  headers: { "Content-Type": "application/json" },
                  body: JSON.stringify({
                    contentType: "image/png",
                    base64: previewPayload.base64,
                  }),
                });
                if (response.ok) {
                  rlog(
                    `Preview uploaded for task ${lastTaskId}` +
                      (previewPayload.size ? ` (${previewPayload.size} bytes)` : ""),
                  );
                  if (runnerState.processing && runnerState.waitingFor === "export") {
                    appendRunnerLog("Preview uploaded");
                  }
                  if (artifactsState.initialized) {
                    fetchArtifacts();
                  }
                  if (artifactDetailsState.open && artifactDetailsState.taskId === lastTaskId) {
                    artifactDetailsState.hasPreview = true;
                    artifactDetailsState.previewUrl = `/tasks/${lastTaskId}/preview.png`;
                    artifactDetailsState.previewUpdatedAt = Date.now();
                    renderArtifactDetails();
                  }
                } else {
                  let message = `HTTP ${response.status}`;
                  try {
                    const payload = await response.json();
                    if (payload && typeof payload.error === "string" && payload.error.trim()) {
                      message = payload.error.trim();
                    }
                  } catch (err) {
                    try {
                      const text = await response.text();
                      if (text && text.trim()) {
                        message = text.trim();
                      }
                    } catch (_) {}
                  }
                  rlog(`Preview upload failed: ${message}`);
                  runnerPostErrorMessage = runnerPostErrorMessage || message;
                }
              } catch (previewErr) {
                rlog(
                  "Preview upload error: " +
                    (previewErr && previewErr.message ? previewErr.message : previewErr)
                );
                runnerPostErrorMessage =
                  runnerPostErrorMessage ||
                  (previewErr && previewErr.message
                    ? previewErr.message
                    : String(previewErr));
              }
            } else if (previewError) {
              rlog(`Preview unavailable: ${previewError}`);
              if (runnerState.processing && runnerState.waitingFor === "export") {
                appendRunnerLog(`Preview unavailable: ${previewError}`);
              }
            }
          } else if (runnerState.processing && runnerState.waitingFor === "export") {
            runnerPostErrorMessage = runnerPostErrorMessage || "Task ID missing";
          }
          if (runnerState.processing && runnerState.waitingFor === "export") {
            if (runnerPostErrorMessage) {
              appendRunnerLog(`Runner export failed: ${runnerPostErrorMessage}`);
              await finalizeRunnerFailure(runnerPostErrorMessage);
            } else {
              appendRunnerLog("Export OK");
              await finalizeRunnerSuccess();
            }
          }
          return;
        }
        if (msg.type === "error") {
          const errorMessage = msg.error ? String(msg.error) : "Unknown error";
          log("ERROR: " + errorMessage);
          if (inflightOperations.export) {
            inflightOperations.export = false;
            const specString = operationContext.exportSpec || getCurrentSpecString();
            operationContext.exportSpec = null;
            setExportState("error", { message: errorMessage, logs: [], errors: [], specString });
          } else if (inflightOperations.import) {
            inflightOperations.import = false;
            setImportState("error", { message: errorMessage });
          } else if (inflightOperations.build) {
            inflightOperations.build = false;
            operationContext.buildSpec = null;
            setBuildState("error", { message: errorMessage });
          } else if (inflightOperations.validate) {
            inflightOperations.validate = false;
            operationContext.validateSpec = null;
            validateInProgress = false;
            setValidateState("error", { message: errorMessage });
          }
          updateActionButtons();
          if (runnerState.processing) {
            appendRunnerLog(`Plugin error: ${errorMessage}`);
            await finalizeRunnerFailure(errorMessage);
          }
          showToast({ message: errorMessage, type: "error" });
          return;
        }
        log(msg);
      };
    </script>
  </body>
</html>
